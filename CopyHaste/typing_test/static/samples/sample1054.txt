
def r_singletons(sad):
	return 100 * sad.count(1)/len(sad)
def p_ZPtOne(sad):
	N = sum(sad)
	S = len(sad)
	sad = np.array(sad)/N
	sad = sad*100
	sad = sad.tolist()
	numR = 0
	for sp in sad:
		if sp < 0.1:
			numR += 1
	return numR/S
def Rlogskew(sad):
	S = len(sad)
	if S <= 2.0:
		print 'S < 2, cannot compute log-skew'
		sys.exit()
	sad = np.log10(sad)
	mu = np.mean(sad)
	num = 0
	denom = 0
	for ni in sad:
		num += ((ni - mu)**3.0)/S
		denom += ((ni - mu)**2.0)/S
	t1 = num/(denom**(3.0/2.0))
	t2 = (S/(S - 2.0)) * np.sqrt((S - 1.0)/S)
	return t1 * t2
def Preston(sad):
	N = sum(sad)
	Nmax = max(sad)
	left = (2 * N)/(np.sqrt(np.pi) * Nmax)
	func = lambda a : left - (math.erf(np.log(2)/a) / a)
	guess = 0.1
	a = fsolve(func, guess)
	expS = (np.