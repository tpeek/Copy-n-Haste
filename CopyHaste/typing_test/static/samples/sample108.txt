TOLERANCE = m.pow(10, -10)
def CosF(t):
	return m.cos((m.pi / 2) * m.pow(t, 2))
def SinF(t):
	return m.sin((m.pi / 2) * m.pow(t, 2))
def C(t):
	return quad(CosF, 0, t, limit=50000)[0]
def S(t):
	return quad(SinF, 0, t, limit=50000)[0]
def eval_x_y_a_large(a, b, k):
	X, Y = [0] * (k + 1), [0] * (k + 1)
	s = a / m.fabs(a)
	z = m.sqrt(m.fabs(a)) / m.sqrt(m.pi)
	l = s * b / (z * m.pi)
	gamma = - s * m.pow(b, 2) / (2 * m.fabs(a))
	t = 0.5 * a + b
	DC0 = C(l + z) - C(l)
	DS0 = S(l + z) - S(l)
	X[0] = (m.cos(gamma) * DC0 - s * m.sin(gamma) * DS0) / z
	Y[0] = (m.sin(gamma) * DC0 + s * m.cos(gamma) * DS0) / z
	X[1] = (m.sin(t) - b * X[0]) / a
	Y[1] = (1 - m.cos(t) - b * Y[0]) / a
	for j in range(1, k):
		X[j + 1] = (m.sin(t) - b * X[j] - j * Y[j - 1]) / a
		Y[j + 1] = (j * X[j - 1] - b * Y[j] - m.cos(t)) / a
	return [X, Y]
def r_lommel(mu, nu, b):
	t = (1 / (mu + nu + 1)) * (1 / (mu - nu + 1))
	r = t
	n = 2
	while m.fabs(t) > TOLERANCE:
		t *= ((-b) / (mu + 2 * n - 1 - nu)) * (b / (mu + 2 * n - 1 + nu))
		r += t
		n += 1
	return r
def eval_x_y_a_zero(b, k):
	X, Y = [0] * (k + 1), [0] * (k + 1)
	if m.fabs(b) < TOLERANCE:
		X[0] = 1 - (m.pow(b, 2) / 6) * (1 - m.pow(b, 2) / 20)
		Y[0] = (m.pow