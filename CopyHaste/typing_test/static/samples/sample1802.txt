
			   LockTimeout)

class PIDLockFile(LockBase):
	def __init__(self, path, threaded=False):
		LockBase.__init__(self, path, False)
		dirname = os.path.dirname(self.lock_file)
		basename = os.path.split(self.path)[-1]
		self.unique_name = self.path
	def read_pid(self):
		return read_pid_
	def is_locked(self):
		return os.path.exists(self.path)
	def i_am_locking(self):
		return self.is_locked() and os.getpid() == self.read_pid()
	def acquire(self, timeout=None):
		end_time = time.time()
		if timeout is not None and timeout > 0:
			end_time += timeout
		while True:
			try:
				write_pid_to_pidfile(self.path)
			except OSError, exc:
				if exc.errno == errno.EEXIST:
					if timeout is not None and time.time() > end_time:
						if timeout > 0: