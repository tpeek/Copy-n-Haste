
def naive_accuracy(confusion):
	
	return p.trace(confusion) / np.sum(confusion)
	
def get_beta_parameters(confusion):
	alphas, betas = [], []
	k = len(confusion)
	
	for i in range(k):
		alphas.append(1 + confusion[i, i])
		betas.append(1 + confusion.sum(axis=1)[i] - confusion[i, i])
	
	return list(zip(alphas, betas))
	
def convolve_betas(parameters, res=0.001):
	k = len(parameters)
	x = np.arange(0, k+res, res)
	pdfs = []
	for par in parameters:
		pdfs.append(beta.pdf(x, par[0], par[1]))
	convolution = pdfs[0]
	for i in range(1, k):
		convolution = np.convolve(convolution, pdfs[i])
	convolution = convolution[0:len(x)]
	convolution = convolution / (sum(convolution) * res)
	
	return convolution
	
	
def balanced_accuracy_expected(confusion):
