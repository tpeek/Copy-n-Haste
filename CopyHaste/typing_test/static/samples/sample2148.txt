
def gen_landscape(x, Type):
	s = [0] * len(x)
	for i in range(0, len(x) - 1):
		s[i + 1] = s[i] + np.linalg.norm(x[i + 1] - x[i])
	if Type == "elevation":
		xlnglat = proj.geospatials_to_latlngs(x, config.PROJ)
		z = elevation.usgs_elevation(xlnglat)
	elif Type == "velocity":
		R = [curvature.points_to_radius(x[i - 1:i + 2])
			 for i in range(1, len(x) - 1)]
		z = [0] + [min(np.sqrt(r * parameters.MAX_LATERAL_ACCEL),
					   parameters.MAX_SPEED) for r in R] + [0]
	return [s, z]
def sort_indices(z, Type):
	z_indices = range(len(z))
	if Type == "elevation":
		return sorted(z_indices, key=lambda i: z[i], reverse=True)
	elif Type == "velocity":
		return sorted(z_indices, key=lambda i: z[i], reverse=False)
def match_landscape(s, z, Type, trad