class Preempted(object):
	def __init__(self, by, usage_since):
		self.by = by
		self.usage_since = usage_since
class Request(base.Put):
	def __exit__(self, exc_type, value, traceback):
		super(Request, self).__exit__(exc_type, value, traceback)
		self.resource.release(self)
class Release(base.Get):
	def __init__(self, resource, request):
		self.request = request
		super(Release, self).__init__(resource)
class PriorityRequest(Request):
	def __init__(self, resource, priority=0, preempt=True):
		self.priority = priority
		self.preempt = preempt
		self.time = resource._env.now
		self.key = (self.priority, self.time, not self.preempt)
		super(PriorityRequest, self).__init__(resource)
class SortedQueue(list):
	def __init__(self, maxlen=None):
		super(SortedQueue, self).__init__()
		self.maxlen = maxlen
	def append(self, item):
		if self.maxlen is not None and len(self) >= self.maxlen:
			raise RuntimeError('Cannot append event. Queue is full.')
		super(SortedQueue, self).append(item)
		super(SortedQueue, self).sort(key=lambda e: e.key)
class Resource(base.BaseResource):
	def __init__(self, env, capacity=1):
		if capacity <= 0:
			raise ValueError('"capacity" must be > 0.')
		super(Resource, self).__init__(env, capacity)
		self.users = []
		self.queue = self.put_queue
	@property
	def count(self):
		return len(self.users)
	request = BoundClass(Request)
	release = BoundClass(Release)
	def _do_put(self, event):
		if len(self.users) < self.capacity:
			self.users.append(event)
			event.succeed()
	def _do_get(self, event):
		try:
			self.users.remove(event.request)
		except ValueError:
			pass
		event.succeed()
class PriorityResource(Resource):
	PutQueue = SortedQueue
	GetQueue = list
	def __init__(self, env, capacity=1):
		super(PriorityResource, self).__init__(env, capacity)
	request = BoundClass(PriorityRequest)
	release = BoundClass(Release)
class PreemptiveResource(PriorityResource):
	def _do_put(self, event):
		if len(self.users) >= self.capacity and event.preempt:
			preempt = sorted(self.users, key=lambda e: e.key)[-1]
			if preempt.key > event.key:
				self.users.remove(preempt)
				preempt.proc.interrupt(Preempted(by=event.proc,
												 usage_since=preempt.time))
		return super(PreemptiveResource, self)._do_put(event)