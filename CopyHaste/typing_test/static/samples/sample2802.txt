SUFFIX_JAVASCRIPT = ".js"
RE_REQUIRE = "@requires:? (.*)\n"
class SourceFile:
	def __init__(self, filepath, source):
		self.filepath = filepath
		self.source = source
		self.requiredBy = []
	def _getRequirements(self):
		return re.findall(RE_REQUIRE, self.source)
	requires = property(fget=_getRequirements, doc="")
def usage(filename):
	print "%s [-c <config file>] <output.js> <directory> [...]" % filename
class Config:
	def __init__(self, filename):
		lines = [re.sub("
				 for line in open(filename)
				 if line.strip() and not line.strip().startswith("
		self.forceFirst = lines[lines.index("[first]") + 1:lines.index("[last]")]
		self.forceLast = lines[lines.index("[last]") + 1:lines.index("[include]")]
		self.include =  lines[lines.index("[include]") + 1:lines.index("[exclude]")]
		self.exclude =  lines[lines.index("[exclude]") + 1:]
def run (sourceDirectory, outputFilename = None, configFile = None):
	cfg = None
	if configFile:
		cfg = Config(configFile)
	allFiles = []
	for root, dirs, files in os.walk(sourceDirectory):
		for filename in files:
			if filename.endswith(SUFFIX_JAVASCRIPT) and not filename.startswith("."):
				filepath = os.path.join(root, filename)[len(sourceDirectory)+1:]
				filepath = filepath.replace("\\", "/")
				if cfg and cfg.include:
					if filepath in cfg.include or filepath in cfg.forceFirst:
						allFiles.append(filepath)
				elif (not cfg) or (filepath not in cfg.exclude):
					allFiles.append(filepath)
	HEADER = "/* " + "=" * 70 + "\n	%s\n" + "   " + "=" * 70 + " */\n\n"
	files = {}
	order = []
	for filepath in allFiles:
		print "Importing: %s" % filepath
		fullpath = os.path.join(sourceDirectory, filepath).strip()
		content = open(fullpath, "U").read()
		files[filepath] = SourceFile(filepath, content)
	print
	complete = False
	resolution_pass = 1
	while not complete:
		order = []
		nodes = []
		routes = []
		print "Resolution pass %s... " % resolution_pass
		resolution_pass += 1 
		for filepath, info in files.items():
			nodes.append(filepath)
			for neededFilePath in info.requires:
				routes.append((neededFilePath, filepath))
		for dependencyLevel in toposort(nodes, routes):
			for filepath in dependencyLevel:
				order.append(filepath)
				if not files.has_key(filepath):
					print "Importing: %s" % filepath
					fullpath = os.path.join(sourceDirectory, filepath).strip()
					content = open(fullpath, "U").read()
					files[filepath] = SourceFile(filepath, content)
		complete = True
		try:
			for fp in order:
				if max([order.index(rfp) for rfp in files[fp].requires] +
					   [order.index(fp)]) != order.index(fp):
					complete = False
		except:
			complete = False
		
		print
	if cfg:
		print "Re-ordering files..."
		order = cfg.forceFirst + [item
					 for item in order
					 if ((item not in cfg.forceFirst) and
						 (item not in cfg.forceLast))] + cfg.forceLast
	
	print
	result = []
	for fp in order:
		f = files[fp]
		print "Exporting: ", f.filepath
		result.append(HEADER % f.filepath)
		source = f.source
		result.append(source)
		if not source.endswith("\n"):
			result.append("\n")
	print "\nTotal files merged: %d " % len(files)
	if outputFilename:
		print "\nGenerating: %s" % (outputFilename)
		open(outputFilename, "w").write("".join(result))
	return "".join(result)
if __name__ == "__main__":
	options, args = getopt.getopt(sys.argv[1:], "-c:")
	
	try:
		outputFilename = args[0]
	except IndexError:
		usage(sys.argv[0])
		raise SystemExit
	else:
		sourceDirectory = args[1]
		if not sourceDirectory:
			usage(sys.argv[0])
			raise SystemExit
	configFile = None
	if options and options[0][0] == "-c":
		configFile = options[0][1]
		print "Parsing configuration file: %s" % filename
	run( sourceDirectory, outputFilename, configFile )