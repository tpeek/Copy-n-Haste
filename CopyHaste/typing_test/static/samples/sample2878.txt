DependencyError, get_plugins, phase_methods, plugin_schemas, PluginError, PluginWarning, task_phases)
log = logging.getLogger('task')
Base = db_schema.versioned_base('feed', 0)
class TaskConfigHash(Base):
	__tablename__ = 'feed_config_hash'
	id = Column(Integer, primary_key=True)
	task = Column('name', Unicode, index=True, nullable=False)
	hash = Column('hash', String)
	def __repr__(self):
		return '<TaskConfigHash(task=%s,hash=%s)>' % (self.task, self.hash)
@with_session
def config_changed(task=None, session=None):
	log.debug('Marking config for %s as changed.' % (task or 'all tasks'))
	task_hash = session.query(TaskConfigHash)
	if task:
		task_hash = task_hash.filter(TaskConfigHash.task == task)
	task_hash.delete()
def use_task_logging(func):
	@wraps(func)
	def wrapper(self, *args, **kw):
		with logger.task_logging(self.name):
			if self.output:
				with capture_output(self.output, loglevel=self.loglevel):
					return func(self, *args, **kw)
			else:
				return func(self, *args, **kw)
	return wrapper
class EntryIterator(object):
	def __init__(self, entries, states):
		self.all_entries = entries
		if isinstance(states, basestring):
			states = [states]
		self.filter = lambda e: e._state in states
	def __iter__(self):
		return itertools.ifilter(self.filter, self.all_entries)
	def __bool__(self):
		return any(e for e in self)
	def __len__(self):
		return sum(1 for e in self)
	def __add__(self, other):
		return itertools.chain(self, other)
	def __radd__(self, other):
		return itertools.chain(other, self)
	def __getitem__(self, item):
		if not isinstance(item, int):
			raise ValueError('Index must be integer.')
		for index, entry in enumerate(self):
			if index == item:
				return entry
		else:
			raise IndexError('%d is out of bounds' % item)
	def __getslice__(self, a, b):
		return list(itertools.islice(self, a, b))
	def reverse(self):
		self.all_entries.sort(reverse=True)
	def sort(self, *args, **kwargs):
		self.all_entries.sort(*args, **kwargs)
class EntryContainer(list):
	def __init__(self, iterable=None):
		list.__init__(self, iterable or [])
		self._entries = EntryIterator(self, ['undecided', 'accepted'])
		self._accepted = EntryIterator(self, 'accepted')
		self._rejected = EntryIterator(self, 'rejected')
		self._failed = EntryIterator(self, 'failed')
		self._undecided = EntryIterator(self, 'undecided')
	entries = property(lambda self: self._entries)
	accepted = property(lambda self: self._accepted)
	rejected = property(lambda self: self._rejected)
	failed = property(lambda self: self._failed)
	undecided = property(lambda self: self._undecided)
	def __repr__(self):
		return '<EntryContainer(%s)>' % list.__repr__(self)
class TaskAbort(Exception):
	def __init__(self, reason, silent=False):
		self.reason = reason
		self.silent = silent
	def __repr__(self):
		return 'TaskAbort(reason=%s, silent=%s)' % (self.reason, self.silent)
class Task(object):
	max_reruns = 5
	_counter = itertools.count()
	def __init__(self, manager, name, config=None, options=None, output=None, loglevel=None, priority=None):
		self.name = unicode(name)
		self.manager = manager
		if config is None:
			config = manager.config['tasks'].get(name, {})
		self.config = copy.deepcopy(config)
		self.prepared_config = None
		if options is None:
			options = copy.copy(self.manager.options.execute)
		elif isinstance(options, dict):
			options_namespace = copy.copy(self.manager.options.execute)
			options_namespace.__dict__.update(options)
			options = options_namespace
		self.options = options
		self.output = output
		self.loglevel = loglevel
		if priority is None:
			self.priority = 10 if self.options.cron else 0
		else:
			self.priority = priority
		self.priority = priority
		self._count = next(self._counter)
		self.finished_event = threading.Event()
		self.simple_persistence = SimpleTaskPersistence(self)
		self._rerun_count = 0
		self.config_modified = None
		self.enabled = not self.name.startswith('_')
		self.aborted = False
		self.abort_reason = None
		self.silent_abort = False
		self.session = None
		self.requests = requests.Session()
		self._all_entries = EntryContainer()
		self._rerun = False
		self.disabled_phases = []
		self.current_phase = None
		self.current_plugin = None
	@property
	def undecided(self):
		return self.all_entries.undecided
	@property
	def failed(self):
		return self.all_entries.failed
	@property
	def rejected(self):
		return self.all_entries.rejected
	@property
	def accepted(self):
		return self.all_entries.accepted
	@property
	def entries(self):
		return self.all_entries.entries
	@property
	def all_entries(self):
		return self._all_entries
	@property
	def is_rerun(self):
		return self._rerun_count
	def __cmp__(self, other):
		return cmp((self.priority, self._count), (other.priority, other._count))
	def __str__(self):
		return '<Task(name=%s,aborted=%s)>' % (self.name, self.aborted)
	def disable_phase(self, phase):
		if phase not in task_phases:
			raise ValueError('%s is not a valid phase' % phase)
		if phase not in self.disabled_phases:
			log.debug('Disabling %s phase' % phase)
			self.disabled_phases.append(phase)
	def abort(self, reason='Unknown', silent=False):
		self.aborted = True
		self.abort_reason = reason
		self.silent_abort = silent
		if not self.silent_abort:
			log.warning('Aborting task (plugin: %s)' % self.current_plugin)
		else:
			log.debug('Aborting task (plugin: %s)' % self.current_plugin)
		raise TaskAbort(reason, silent=silent)
	def find_entry(self, category='entries', **values):
		cat = getattr(self, category)
		if not isinstance(cat, EntryIterator):
			raise TypeError('category must be a EntryIterator')
		for entry in cat:
			for k, v in values.iteritems():
				if not (k in entry and entry[k] == v):
					break
			else:
				return entry
		return None
	def plugins(self, phase=None):
		if phase:
			plugins = sorted(get_plugins(phase=phase), key=lambda p: p.phase_handlers[phase], reverse=True)
		else:
			plugins = all_plugins.itervalues()
		return (p for p in plugins if p.name in self.config or p.builtin)
	def __run_task_phase(self, phase):
		if phase not in phase_methods:
			raise Exception('%s is not a valid task phase' % phase)
		if phase in ['input', 'filter', 'output']:
			if not self.manager.unit_test:
				for p in self.plugins(phase):
					if not p.builtin:
						break
				else:
					if phase == 'filter':
						log.warning('Task does not have any filter plugins to accept entries. '
									'You need at least one to accept the entries you  want.')
					else:
						log.warning('Task doesn\'t have any %s plugins, you should add (at least) one!' % phase)
		for plugin in self.plugins(phase):
			if phase in self.disabled_phases:
				return
			self.current_phase = phase
			self.current_plugin = plugin.name
			if plugin.api_ver == 1:
				args = (self,)
			else:
				args = (self, copy.copy(self.config.get(plugin.name)))
			with Session() as session:
				self.session = session
				try:
					fire_event('task.execute.before_plugin', self, plugin.name)
					response = self.__run_plugin(plugin, phase, args)
					if phase == 'input' and response:
						for e in response:
							e.task = self
						self.all_entries.extend(response)
				finally:
					fire_event('task.execute.after_plugin', self, plugin.name)
				self.session = None
	def __run_plugin(self, plugin, phase, args=None, kwargs=None):
		keyword = plugin.name
		method = plugin.phase_handlers[phase]
		if args is None:
			args = []
		if kwargs is None:
			kwargs = {}
		try:
			return method(*args, **kwargs)
		except TaskAbort:
			raise
		except PluginWarning as warn:
			if warn.kwargs.get('log_once', False):
				log_once(warn.value, warn.log)
			else:
				warn.log.warning(warn)
		except EntryUnicodeError as eue:
			msg = ('Plugin %s tried to create non-unicode compatible entry (key: %s, value: %r)' %
				   (keyword, eue.key, eue.value))
			log.critical(msg)
			self.abort(msg)
		except PluginError as err:
			err.log.critical(err.value)
			self.abort(err.value)
		except DependencyError as e:
			msg = ('Plugin `%s` cannot be used because dependency `%s` is missing.' %
				   (keyword, e.missing))
			log.critical(msg)
			log.debug(e.message)
			self.abort(msg)
		except Warning as e:
			msg = 'Warning during plugin %s: %s' % (keyword, e)
			log.exception(msg)
			self.abort(msg)
		except Exception as e:
			msg = 'BUG: Unhandled error in plugin %s: %s' % (keyword, e)
			log.critical(msg)
			self.manager.crash_report()
			self.abort(msg)
	def rerun(self):
		msg = 'Plugin %s has requested task to be ran again after execution has completed.' % self.current_plugin
		log.debug(msg) if self._rerun else log.info(msg)
		self._rerun = True
	def config_changed(self):
		self.config_modified = True
	def _execute(self):
		if not self.enabled:
			log.debug('Not running disabled task %s' % self.name)
			return
		log.debug('executing %s' % self.name)
		if self.options.learn:
			log.info('Disabling download and output phases because of --learn')
			self.disable_phase('download')
			self.disable_phase('output')
		if self.options.disable_phases:
			map(self.disable_phase, self.options.disable_phases)
		if self.options.inject:
			self.disable_phase('input')
			self.all_entries.extend(self.options.inject)
		with Session() as session:
			config_hash = hashlib.md5(str(sorted(self.config.items()))).hexdigest()
			last_hash = session.query(TaskConfigHash).filter(TaskConfigHash.task == self.name).first()
			if self.is_rerun:
				if self.prepared_config:
					self.config = copy.deepcopy(self.prepared_config)
				else:
					log.error('BUG: No prepared_config on rerun, please report.')
				self.config_modified = False
			elif not last_hash:
				self.config_modified = True
				last_hash = TaskConfigHash(task=self.name, hash=config_hash)
				session.add(last_hash)
			elif last_hash.hash != config_hash:
				self.config_modified = True
				last_hash.hash = config_hash
			else:
				self.config_modified = False
		try:
			for phase in task_phases:
				if phase in self.disabled_phases:
					for plugin in self.plugins(phase):
						if plugin.name in self.config:
							log.info('Plugin %s is not executed because %s phase is disabled (e.g. --test)' %
									 (plugin.name, phase))
					continue
				if phase == 'start' and self.is_rerun:
					log.debug('skipping task_start during rerun')
				elif phase == 'exit' and self._rerun:
					log.debug('not running task_exit yet because task will rerun')
				else:
					self.__run_task_phase(phase)
					if phase == 'start':
						self.prepared_config = copy.deepcopy(self.config)
		except TaskAbort:
			try:
				self.__run_task_phase('abort')
			except TaskAbort as e:
				log.exception('abort handlers aborted: %s' % e)
			raise
		else:
			for entry in self.all_entries:
				entry.complete()
	@use_task_logging
	def execute(self):
		try:
			if self.options.cron:
				self.manager.db_cleanup()
			fire_event('task.execute.started', self)
			while True:
				self._execute()
				if self._rerun and self._rerun_count < self.max_reruns:
					log.info('Rerunning the task in case better resolution can be achieved.')
					self._rerun_count += 1
					self._all_entries = EntryContainer()
					self._rerun = False
					continue
				elif self._rerun:
					log.info('Task has been re-run %s times already, stopping for now' % self._rerun_count)
				break
			fire_event('task.execute.completed', self)
		finally:
			self.finished_event.set()
	@staticmethod
	def validate_config(config):
		schema = plugin_schemas(context='task')
		schema['patternProperties'] = {'^_': {}}
		return config_schema.process_config(config, schema)
	def __copy__(self):
		new = type(self)(self.manager, self.name, self.config, self.options)
		new.__dict__.update(self.__dict__)
		new.options = copy.copy(self.options)
		new.config = copy.deepcopy(self.config)
		return new
	copy = __copy__
@event('config.register')
def register_config_key():
	task_config_schema = {
		'type': 'object',
		'additionalProperties': plugin_schemas(context='task')
	}
	config_schema.register_config_key('tasks', task_config_schema, required=True)