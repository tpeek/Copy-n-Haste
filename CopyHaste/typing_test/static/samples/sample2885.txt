log = logging.getLogger('sql_utils')
def table_exists(name, session):
	try:
		table_schema(name, session)
	except NoSuchTableError:
		return False
	return True
def table_schema(name, session):
	return Table(name, MetaData(bind=session.bind), autoload=True)
def table_columns(table, session):
	res = []
	if isinstance(table, basestring):
		table = table_schema(table, session)
	for column in table.columns:
		res.append(column.name)
	return res
def table_add_column(table, name, col_type, session, default=None):
	if isinstance(table, basestring):
		table = table_schema(table, session)
	if name in table_columns(table, session):
		return
	if not isinstance(col_type, TypeEngine):
		col_type = col_type()
	type_string = session.bind.engine.dialect.type_compiler.process(col_type)
	statement = 'ALTER TABLE %s ADD %s %s' % (table.name, name, type_string)
	session.execute(statement)
	if default is not None:
		table = table_schema(table.name, session)
		if not isinstance(default, (ColumnDefault, Sequence)):
			default = ColumnDefault(default)
		default._set_parent(getattr(table.c, name))
		statement = table.update().values({name: default.execute(bind=session.bind)})
		session.execute(statement)
def drop_tables(names, session):
	metadata = MetaData()
	metadata.reflect(bind=session.bind)
	for table in metadata.sorted_tables:
		if table.name in names:
			table.drop()
def get_index_by_name(table, name):
	for index in table.indexes:
		if index.name == name:
			return index
def create_index(table_name, session, *column_names):
	index_name = '_'.join(['ix', table_name] + list(column_names))
	table = table_schema(table_name, session)
	columns = [getattr(table.c, column) for column in column_names]
	try:
		Index(index_name, *columns).create(bind=session.bind)
	except OperationalError:
		log.debug('Error creating index.', exc_info=True)
class ContextSession(sqlalchemy.orm.Session):
	def __enter__(self):
		return self
	def __exit__(self, exc_type, exc_val, exc_tb):
		try:
			if exc_type is None:
				self.commit()
			else:
				self.rollback()
		finally:
			self.close()