log = logging.getLogger('tests')
VCR_CASSETTE_DIR = os.path.join(os.path.dirname(__file__), 'cassettes')
VCR_RECORD_MODE = os.environ.get('VCR_RECORD_MODE', 'once')
vcr = VCR(cassette_library_dir=VCR_CASSETTE_DIR, record_mode=VCR_RECORD_MODE)
test_arguments = None
plugins_loaded = False
def setup_logging_level():
	level = logging.DEBUG
	if "--verbose" in sys.argv or "-v" in sys.argv:
		level = flexget.logger.TRACE
	elif "--quiet" in sys.argv or "-q" in sys.argv:
		level = logging.INFO
	logging.getLogger().setLevel(level)
	return level
def setup_once():
	global plugins_loaded, test_arguments
	if not plugins_loaded:
		flexget.logger.initialize(True)
		setup_logging_level()
		if VCR_RECORD_MODE != 'off':
			try:
				warnings.simplefilter('ignore', SecurityWarning)
			except ImportError:
				pass
		load_plugins()
		plugins_loaded = True
def use_vcr(func=None, **kwargs):
	if func is None:
		return functools.partial(use_vcr, **kwargs)
	module = func.__module__.split('tests.')[-1]
	class_name = inspect.stack()[1][3]
	cassette_name = '.'.join([module, class_name, func.__name__])
	kwargs.setdefault('path', cassette_name)
	cassette_path = os.path.join(VCR_CASSETTE_DIR, cassette_name)
	online = True
	if vcr.record_mode == 'none':
		online = False
	elif vcr.record_mode == 'once':
		online = not os.path.exists(cassette_path)
	func = attr(online=online, vcr=True)(func)
	if not online:
		func = mock.patch('flexget.utils.requests.wait_for_domain', new=mock.MagicMock())(func)
	if VCR_RECORD_MODE == 'off':
		return func
	else:
		return vcr.use_cassette(**kwargs)(func)
class MockManager(Manager):
	unit_test = True
	def __init__(self, config_text, config_name, db_uri=None):
		self.config_text = config_text
		self._db_uri = db_uri or 'sqlite:///:memory:'
		super(MockManager, self).__init__(['execute'])
		self.config_name = config_name
		self.database_uri = self._db_uri
		log.debug('database_uri: %s' % self.database_uri)
		self.initialize()
	def find_config(self, *args, **kwargs):
		try:
			self.config = yaml.safe_load(self.config_text) or {}
			self.config_base = os.path.dirname(os.path.abspath(sys.path[0]))
		except Exception:
			print 'Invalid configuration'
			raise
	def load_config(self):
		pass
	def validate_config(self, config=None):
		try:
			return super(MockManager, self).validate_config(config)
		except ValueError as e:
			for error in getattr(e, 'errors', []):
				log.critical(error)
	@contextmanager
	def acquire_lock(self, **kwargs):
		self._has_lock = True
		yield
	def release_lock(self):
		pass
def build_parser_function(parser_name):
	def parser_function(task_name, task_definition):
		task_definition['parsing'] = {'series': parser_name, 'movie': parser_name}
	return parser_function
class FlexGetBase(object):
	__yaml__ =
	__tmp__ = False
	def __init__(self):
		self.log = log
		self.manager = None
		self.task = None
		self.database_uri = None
		self.base_path = os.path.dirname(__file__)
		self.config_functions = []
		self.tasks_functions = []
	def add_config_function(self, config_function):
		self.config_functions.append(config_function)
	def add_tasks_function(self, tasks_function):
		self.tasks_functions.append(tasks_function)
	def setup(self):
		setup_once()
		if self.__tmp__:
			self.__tmp__ = util.maketemp() + '/'
			self.__yaml__ = self.__yaml__.replace("__tmp__", self.__tmp__)
		self.manager = MockManager(self.__yaml__, self.__class__.__name__, db_uri=self.database_uri)
		for config_function in self.config_functions:
			config_function(self.manager.config)
		if self.tasks_functions and 'tasks' in self.manager.config:
			for task_name, task_definition in self.manager.config['tasks'].items():
				for task_function in self.tasks_functions:
					task_function(task_name, task_definition)
	def teardown(self):
		try:
			try:
				self.task.session.close()
			except:
				pass
			self.manager.shutdown()
			self.manager.__del__()
		finally:
			if self.__tmp__:
				log.trace('Removing tmpdir %r' % self.__tmp__)
				shutil.rmtree(self.__tmp__.rstrip(os.sep))
	def execute_task(self, name, abort_ok=False, options=None):
		log.info('********** Running task: %s ********** ' % name)
		config = self.manager.config['tasks'][name]
		if hasattr(self, 'task'):
			if hasattr(self, 'session'):
				self.task.session.close()
		self.task = Task(self.manager, name, config=config, options=options)
		try:
			self.task.execute()
		except TaskAbort:
			if not abort_ok:
				raise
	def dump(self):
		print '\n-- ENTRIES: -----------------------------------------------------'
		dump(self.task.entries, True)
		print '-- ACCEPTED: ----------------------------------------------------'
		dump(self.task.entries, True)
		print '-- REJECTED: ----------------------------------------------------'
		dump(self.task.entries, True)
class with_filecopy(object):
	def __init__(self, src, dst):
		self.src = src
		self.dst = dst
	def __call__(self, func):
		def wrapper(*args, **kwargs):
			dst = self.dst
			if "__tmp__" in dst:
				dst = dst.replace('__tmp__', 'tmp/%s/' % util.find_test_name().replace(':', '_'))
			src = self.src
			if isinstance(src, basestring):
				src = [self.src]
			files = []
			for pattern in src:
				files.extend(glob.glob(pattern))
			if len(src) > 1 or set(files) != set(src):
				pairs = [(i, dst + i) for i in files]
			else:
				pairs = [(self.src, dst)]
			for src, dst in pairs:
				log.trace("Copying %r to %r" % (src, dst))
				shutil.copy(src, dst)
			try:
				return func(*args, **kwargs)
			finally:
				for _, dst in pairs:
					if os.path.exists(dst):
						log.trace("Removing %r" % dst)
						os.remove(dst)
		wrapper = make_decorator(func)(wrapper)
		return wrapper