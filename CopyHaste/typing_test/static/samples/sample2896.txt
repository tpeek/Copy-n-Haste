__doc__ =
__always_supported = ('md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512')
algorithms_guaranteed = set(__always_supported)
algorithms_available = set(__always_supported)
__all__ = __always_supported + ('new', 'algorithms_guaranteed',
								'algorithms_available', 'pbkdf2_hmac')
__builtin_constructor_cache = {}
def __get_builtin_constructor(name):
	cache = __builtin_constructor_cache
	constructor = cache.get(name)
	if constructor is not None:
		return constructor
	try:
		if name in ('SHA1', 'sha1'):
			cache['SHA1'] = cache['sha1'] = _sha1.sha1
		elif name in ('MD5', 'md5'):
			cache['MD5'] = cache['md5'] = _md5.md5
		elif name in ('SHA256', 'sha256', 'SHA224', 'sha224'):
			cache['SHA224'] = cache['sha224'] = _sha256.sha224
			cache['SHA256'] = cache['sha256'] = _sha256.sha256
		elif name in ('SHA512', 'sha512', 'SHA384', 'sha384'):
			cache['SHA384'] = cache['sha384'] = _sha512.sha384
			cache['SHA512'] = cache['sha512'] = _sha512.sha512
	except ImportError:
		pass
	constructor = cache.get(name)
	if constructor is not None:
		return constructor
	raise ValueError('unsupported hash type ' + name)
def __get_openssl_constructor(name):
	try:
		f = getattr(_hashlib, 'openssl_' + name)
		f()
		return f
	except (AttributeError, ValueError):
		return __get_builtin_constructor(name)
def __py_new(name, data=b''):
	return __get_builtin_constructor(name)(data)
def __hash_new(name, data=b''):
	try:
		return _hashlib.new(name, data)
	except ValueError:
		return __get_builtin_constructor(name)(data)
try:
	new = __hash_new
	__get_hash = __get_openssl_constructor
	algorithms_available = algorithms_available.union(
			_hashlib.openssl_md_meth_names)
except ImportError:
	new = __py_new
	__get_hash = __get_builtin_constructor
try:
except ImportError:
	_trans_5C = bytes((x ^ 0x5C) for x in range(256))
	_trans_36 = bytes((x ^ 0x36) for x in range(256))
	def pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None):
		if not isinstance(hash_name, str):
			raise TypeError(hash_name)
		if not isinstance(password, (bytes, bytearray)):
			password = bytes(memoryview(password))
		if not isinstance(salt, (bytes, bytearray)):
			salt = bytes(memoryview(salt))
		inner = new(hash_name)
		outer = new(hash_name)
		blocksize = getattr(inner, 'block_size', 64)
		if len(password) > blocksize:
			password = new(hash_name, password).digest()
		password = password + b'\x00' * (blocksize - len(password))
		inner.update(password.translate(_trans_36))
		outer.update(password.translate(_trans_5C))
		def prf(msg, inner=inner, outer=outer):
			icpy = inner.copy()
			ocpy = outer.copy()
			icpy.update(msg)
			ocpy.update(icpy.digest())
			return ocpy.digest()
		if iterations < 1:
			raise ValueError(iterations)
		if dklen is None:
			dklen = outer.digest_size
		if dklen < 1:
			raise ValueError(dklen)
		dkey = b''
		loop = 1
		while len(dkey) < dklen:
			prev = prf(salt + loop.to_bytes(4, 'big'))
			rkey = int.
			for i in range(iterations - 1):
				prev = prf(prev)
				rkey ^=
			loop += 1
			dkey += rkey.to_bytes(inner.digest_size, 'big')
		return dkey[:dklen]
for __func_name in __always_supported:
	try:
		globals()[__func_name] = __get_hash(__func_name)
	except ValueError:
		logging.exception('code for hash %s was not found.', __func_name)
del __always_supported, __func_name, __get_hash
del __py_new, __hash_new, __get_openssl_constructor