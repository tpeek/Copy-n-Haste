trans_5C = bytes((x ^ 0x5C) for x in range(256))
trans_36 = bytes((x ^ 0x36) for x in range(256))
digest_size = None
class HMAC:
	blocksize = 64
	def __init__(self, key, msg = None, digestmod = None):
		if not isinstance(key, (bytes, bytearray)):
			raise TypeError("key: expected bytes or bytearray, but got %r" % type(key).__name__)
		if digestmod is None:
			_warnings.warn("HMAC() without an explicit digestmod argument "
						   "is deprecated.", PendingDeprecationWarning, 2)
			digestmod = _hashlib.md5
		if callable(digestmod):
			self.digest_cons = digestmod
		elif isinstance(digestmod, str):
			self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
		else:
			self.digest_cons = lambda d=b'': digestmod.new(d)
		self.outer = self.digest_cons()
		self.inner = self.digest_cons()
		self.digest_size = self.inner.digest_size
		if hasattr(self.inner, 'block_size'):
			blocksize = self.inner.block_size
			if blocksize < 16:
				_warnings.warn('block_size of %d seems too small; using our '
							   'default of %d.' % (blocksize, self.blocksize),
							   RuntimeWarning, 2)
				blocksize = self.blocksize
		else:
			_warnings.warn('No block_size attribute on given digest object; '
						   'Assuming %d.' % (self.blocksize),
						   RuntimeWarning, 2)
			blocksize = self.blocksize
		self.block_size = blocksize
		if len(key) > blocksize:
			key = self.digest_cons(key).digest()
		key = key + bytes(blocksize - len(key))
		self.outer.update(key.translate(trans_5C))
		self.inner.update(key.translate(trans_36))
		if msg is not None:
			self.update(msg)
	@property
	def name(self):
		return "hmac-" + self.inner.name
	def update(self, msg):
		self.inner.update(msg)
	def copy(self):
		other = self.__class__.__new__(self.__class__)
		other.digest_cons = self.digest_cons
		other.digest_size = self.digest_size
		other.inner = self.inner.copy()
		other.outer = self.outer.copy()
		return other
	def _current(self):
		h = self.outer.copy()
		h.update(self.inner.digest())
		return h
	def digest(self):
		h = self._current()
		return h.digest()
	def hexdigest(self):
		h = self._current()
		return h.hexdigest()
def new(key, msg = None, digestmod = None):
	return HMAC(key, msg, digestmod)