args = None
def _parse_trans_unit(trans_unit):
	def get_value(tag_name):
		elts = trans_unit.getElementsByTagName(tag_name)
		if not elts:
			return None
		elif len(elts) == 1:
			return ''.join([child.toxml() for child in elts[0].childNodes])
		else:
			raise InputError('', 'Unable to extract ' + tag_name)
	result = {}
	key = trans_unit.getAttribute('id')
	if not key:
		raise InputError('', 'id attribute not found')
	result['key'] = key
	try:
		result['source'] = get_value('source')
		result['target'] = get_value('target')
	except InputError, e:
		raise InputError(key, e.msg)
	notes = trans_unit.getElementsByTagName('note')
	for note in notes:
		if
			result[
		else:
			raise InputError(key, 'Unable to extract ' +
	return result
def _process_file(filename):
	try:
		results = []
		names = []
		try:
			parsed_xml = minidom.parse(filename)
		except IOError:
			raise
		except Exception, e:
			print
			raise InputError(filename, str(e))
		for trans_unit in parsed_xml.getElementsByTagName('trans-unit'):
			unit = _parse_trans_unit(trans_unit)
			for key in ['description', 'meaning', 'source']:
				if not key in unit or not unit[key]:
					raise InputError(filename + ':' + unit['key'],
									 key + ' not found')
			if unit['description'].lower() == 'ibid':
			  if unit['meaning'] not in names:
				raise InputError(
					filename,
					'First encountered definition of: ' + unit['meaning']
					+ ' has definition: ' + unit['description']
					+ '.  This error can occur if the definition was not'
					+ ' provided on the first appearance of the message'
					+ ' or if the source (English-language) messages differ.')
			  else:
				pass
			else:
			  if unit['meaning'] in names:
				raise InputError(filename,
								 'Second definition of: ' + unit['meaning'])
			  names.append(unit['meaning'])
			  results.append(unit)
		return results
	except IOError, e:
		print 'Error with file {0}: {1}'.format(filename, e.strerror)
		sys.exit(1)
def sort_units(units, templates):
	def key_function(unit):
		match = re.search(
			'\\smeaning\\s*=\\s*"{0}"\\s'.format(unit['meaning']),
			templates)
		if match:
			return match.start()
		else:
			raise InputError(args.templates,
							 'msg definition for meaning not found: ' +
							 unit['meaning'])
	return sorted(units, key=key_function)
def main():
	parser = argparse.ArgumentParser(description='Create translation files.')
	parser.add_argument(
		'--author',
		default='Ellen Spertus <ellen.spertus@gmail.com>',
		help='name and email address of contact for translators')
	parser.add_argument('--lang', default='en',
						help='ISO 639-1 source language code')
	parser.add_argument('--output_dir', default='json',
						help='relative directory for output files')
	parser.add_argument('--xlf', help='file containing xlf definitions')
	parser.add_argument('--templates', default=['template.soy'], nargs='+',
						help='relative path to Soy templates, comma or space '
						'separated (used for ordering messages)')
	global args
	args = parser.parse_args()
	if (not args.output_dir.endswith(os.path.sep)):
	  args.output_dir += os.path.sep
	units = _process_file(args.xlf)
	files = []
	for arg in args.templates:
	  for filename in arg.split(','):
		filename = filename.strip();
		if filename:
		  with open(filename) as myfile:
			files.append(' '.join(line.strip() for line in myfile))
	sorted_units = sort_units(units, ' '.join(files))
	write_files(args.author, args.lang, args.output_dir, sorted_units, True)
	os.remove(args.xlf)
	print('Removed ' + args.xlf)
if __name__ == '__main__':
	main()