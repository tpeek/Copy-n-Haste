__author__ = 'Marcel Hellkamp'
__version__ = '0.10.6'
__license__ = 'MIT'
if __name__ == '__main__':
	_cmd_parser = OptionParser(usage="usage: %prog [options] package.module:app")
	_opt = _cmd_parser.add_option
	_opt("--version", action="store_true", help="show version number.")
	_opt("-b", "--bind", metavar="ADDRESS", help="bind socket to ADDRESS.")
	_opt("-s", "--server", default='wsgiref', help="use SERVER as backend.")
	_opt("-p", "--plugin", action="append", help="install additional plugin/s.")
	_opt("--debug", action="store_true", help="start server in debug mode.")
	_opt("--reload", action="store_true", help="auto-reload on file changes.")
	_cmd_options, _cmd_args = _cmd_parser.parse_args()
	if _cmd_options.server and _cmd_options.server.startswith('gevent'):
urlencode = urllib.urlencode
urlquote = urllib.quote
urlunquote = urllib.unquote
try:
except ImportError:
try:
except ImportError:
try:
except ImportError:
try:
except ImportError:
	try:
	except ImportError:
		try:
		except ImportError:
			def json_dumps(data):
				raise ImportError("JSON support requires Python 2.6 or simplejson.")
			json_lds = json_dumps
py3k = sys.version_info >= (3,0,0)
NCTextIOWrapper = None
if sys.version_info < (2,6,0):
	msg = "Python 2.5 support may be dropped in future versions of Bottle."
	warnings.warn(msg, DeprecationWarning)
if py3k:
	json_loads = lambda s: json_lds(touni(s))
	def touni(x, enc='utf8', err='strict'):
		return str(x, enc, err) if isinstance(x, bytes) else str(x)
	if sys.version_info < (3,2,0):
		class NCTextIOWrapper(TextIOWrapper):
			def close(self): pass
else:
	json_loads = json_lds
	bytes = str
	def touni(x, enc='utf8', err='strict'):
		return x if isinstance(x, unicode) else unicode(str(x), enc, err)
def tob(data, enc='utf8'):
	return data.encode(enc) if isinstance(data, unicode) else bytes(data)
tonat = touni if py3k else tob
tonat.__doc__ =
def try_update_wrapper(wrapper, wrapped, *a, **ka):
	try:
		functools.update_wrapper(wrapper, wrapped, *a, **ka)
	except AttributeError: pass
def depr(message):
	warnings.warn(message, DeprecationWarning, stacklevel=3)
def makelist(data):
	if isinstance(data, (tuple, list, set, dict)): return list(data)
	elif data: return [data]
	else: return []
class DictProperty(object):
	def __init__(self, attr, key=None, read_only=False):
		self.attr, self.key, self.read_only = attr, key, read_only
	def __call__(self, func):
		functools.update_wrapper(self, func, updated=[])
		self.getter, self.key = func, self.key or func.__name__
		return self
	def __get__(self, obj, cls):
		if obj is None: return self
		key, storage = self.key, getattr(obj, self.attr)
		if key not in storage: storage[key] = self.getter(obj)
		return storage[key]
	def __set__(self, obj, value):
		if self.read_only: raise AttributeError("Read-Only property.")
		getattr(obj, self.attr)[self.key] = value
	def __delete__(self, obj):
		if self.read_only: raise AttributeError("Read-Only property.")
		del getattr(obj, self.attr)[self.key]
class CachedProperty(object):
	def __init__(self, func):
		self.func = func
	def __get__(self, obj, cls):
		if obj is None: return self
		value = obj.__dict__[self.func.__name__] = self.func(obj)
		return value
cached_property = CachedProperty
class lazy_attribute(object):
	def __init__(self, func):
		functools.update_wrapper(self, func, updated=[])
		self.getter = func
	def __get__(self, obj, cls):
		value = self.getter(cls)
		setattr(cls, self.__name__, value)
		return value
class BottleException(Exception):
	pass
class HTTPResponse(BottleException):
	def __init__(self, output='', status=200, header=None):
		super(BottleException, self).__init__("HTTP Response %d" % status)
		self.status = int(status)
		self.output = output
		self.headers = HeaderDict(header) if header else None
	def apply(self, response):
		if self.headers:
			for key, value in self.headers.iterallitems():
				response.headers[key] = value
		response.status = self.status
class HTTPError(HTTPResponse):
	def __init__(self, code=500, output='Unknown Error', exception=None,
				 traceback=None, header=None):
		super(HTTPError, self).__init__(output, code, header)
		self.exception = exception
		self.traceback = traceback
	def __repr__(self):
		return tonat(template(ERROR_PAGE_TEMPLATE, e=self))
class RouteError(BottleException):
class RouteReset(BottleException):
class RouterUnknownModeError(RouteError): pass
class RouteSyntaxError(RouteError):
class RouteBuildError(RouteError):
class Router(object):
	default_pattern = '[^/]+'
	default_filter   = 're'
	rule_syntax = re.compile('(\\\\*)'\
		'(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:
		  '|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'\
			'(?::((?:\\\\.|[^\\\\>]+)+)?)?)?>))')
	def __init__(self, strict=False):
		self.rules	= {}
		self.builder  = {}
		self.static   = {}
		self.dynamic  = []
		self.strict_order = strict
		self.filters = {'re': self.re_filter, 'int': self.int_filter,
						'float': self.float_filter, 'path': self.path_filter}
	def re_filter(self, conf):
		return conf or self.default_pattern, None, None
	def int_filter(self, conf):
		return r'-?\d+', int, lambda x: str(int(x))
	def float_filter(self, conf):
		return r'-?[\d.]+', float, lambda x: str(float(x))
	def path_filter(self, conf):
		return r'.*?', None, None
	
	def add_filter(self, name, func):
		self.filters[name] = func
	
	def parse_rule(self, rule):
		offset, prefix = 0, ''
		for match in self.rule_syntax.finditer(rule):
			prefix += rule[offset:match.start()]
			g = match.groups()
			if len(g[0])%2:
				prefix += match.group(0)[len(g[0]):]
				offset = match.end()
				continue
			if prefix: yield prefix, None, None
			name, filtr, conf = g[1:4] if not g[2] is None else g[4:7]
			if not filtr: filtr = self.default_filter
			yield name, filtr, conf or None
			offset, prefix = match.end(), ''
		if offset <= len(rule) or prefix:
			yield prefix+rule[offset:], None, None
	def add(self, rule, method, target, name=None):
		if rule in self.rules:
			self.rules[rule][method] = target
			if name: self.builder[name] = self.builder[rule]
			return
		target = self.rules[rule] = {method: target}
		anons = 0
		pattern = ''
		filters = []
		builder = []
		is_static = True
		for key, mode, conf in self.parse_rule(rule):
			if mode:
				is_static = False
				mask, in_filter, out_filter = self.filters[mode](conf)
				if key:
					pattern += '(?P<%s>%s)' % (key, mask)
				else:
					pattern += '(?:%s)' % mask
					key = 'anon%d' % anons; anons += 1
				if in_filter: filters.append((key, in_filter))
				builder.append((key, out_filter or str))
			elif key:
				pattern += re.escape(key)
				builder.append((None, key))
		self.builder[rule] = builder
		if name: self.builder[name] = builder
		if is_static and not self.strict_order:
			self.static[self.build(rule)] = target
			return
		def fpat_sub(m):
			return m.group(0) if len(m.group(1)) % 2 else m.group(1) + '(?:'
		flat_pattern = re.sub(r'(\\*)(\(\?P<[^>]*>|\((?!\?))', fpat_sub, pattern)
		try:
			re_match = re.compile('^(%s)$' % pattern).match
		except re.error, e:
			raise RouteSyntaxError("Could not add Route: %s (%s)" % (rule, e))
		def match(path):
			url_args = re_match(path).groupdict()
			for name, wildcard_filter in filters:
				try:
					url_args[name] = wildcard_filter(url_args[name])
				except ValueError:
					raise HTTPError(400, 'Path has wrong format.')
			return url_args
		try:
			combined = '%s|(^%s$)' % (self.dynamic[-1][0].pattern, flat_pattern)
			self.dynamic[-1] = (re.compile(combined), self.dynamic[-1][1])
			self.dynamic[-1][1].append((match, target))
		except (AssertionError, IndexError), e:
			self.dynamic.append((re.compile('(^%s$)' % flat_pattern),
								[(match, target)]))
		return match
	def build(self, _name, *anons, **query):
		builder = self.builder.get(_name)
		if not builder: raise RouteBuildError("No route with that name.", _name)
		try:
			for i, value in enumerate(anons): query['anon%d'%i] = value
			url = ''.join([f(query.pop(n)) if n else f for (n,f) in builder])
			return url if not query else url+'?'+urlencode(query)
		except KeyError, e:
			raise RouteBuildError('Missing URL argument: %r' % e.args[0])
	def match(self, environ):
		path, targets, urlargs = environ['PATH_INFO'] or '/', None, {}
		if path in self.static:
			targets = self.static[path]
		else:
			for combined, rules in self.dynamic:
				match = combined.match(path)
				if not match: continue
				getargs, targets = rules[match.lastindex - 1]
				urlargs = getargs(path) if getargs else {}
				break
		if not targets:
			raise HTTPError(404, "Not found: " + repr(environ['PATH_INFO']))
		method = environ['REQUEST_METHOD'].upper()
		if method in targets:
			return targets[method], urlargs
		if method == 'HEAD' and 'GET' in targets:
			return targets['GET'], urlargs
		if 'ANY' in targets:
			return targets['ANY'], urlargs
		allowed = [verb for verb in targets if verb != 'ANY']
		if 'GET' in allowed and 'HEAD' not in allowed:
			allowed.append('HEAD')
		raise HTTPError(405, "Method not allowed.",
						header=[('Allow',",".join(allowed))])
class Route(object):
	def __init__(self, app, rule, method, callback, name=None,
				 plugins=None, skiplist=None, **config):
		self.app = app
		self.rule = rule
		self.method = method
		self.callback = callback
		self.name = name or None
		self.plugins = plugins or []
		self.skiplist = skiplist or []
		self.config = ConfigDict(config)
	def __call__(self, *a, **ka):
		depr("Some APIs changed to return Route() instances instead of"\
			 " callables. Make sure to use the Route.call method and not to"\
			 " call Route instances directly.")
		return self.call(*a, **ka)
	@cached_property
	def call(self):
		return self._make_callback()
	def reset(self):
		self.__dict__.pop('call', None)
	def prepare(self):
		self.call
	@property
	def _context(self):
		depr('Switch to Plugin API v2 and access the Route object directly.')
		return dict(rule=self.rule, method=self.method, callback=self.callback,
					name=self.name, app=self.app, config=self.config,
					apply=self.plugins, skip=self.skiplist)
	def all_plugins(self):
		unique = set()
		for p in reversed(self.app.plugins + self.plugins):
			if True in self.skiplist: break
			name = getattr(p, 'name', False)
			if name and (name in self.skiplist or name in unique): continue
			if p in self.skiplist or type(p) in self.skiplist: continue
			if name: unique.add(name)
			yield p
	def _make_callback(self):
		callback = self.callback
		for plugin in self.all_plugins():
			try:
				if hasattr(plugin, 'apply'):
					api = getattr(plugin, 'api', 1)
					context = self if api > 1 else self._context
					callback = plugin.apply(callback, context)
				else:
					callback = plugin(callback)
			except RouteReset:
				return self._make_callback()
			if not callback is self.callback:
				try_update_wrapper(callback, self.callback)
		return callback
class Bottle(object):
	def __init__(self, catchall=True, autojson=True, config=None):
		self.routes = []
		self.router = Router()
		self.plugins = []
		self.error_handler = {}
		self.config = ConfigDict(config or {})
		self.catchall = catchall
		self.hooks = HooksPlugin()
		self.install(self.hooks)
		if autojson:
			self.install(JSONPlugin())
		self.install(TemplatePlugin())
	def mount(self, prefix, app, **options):
		if isinstance(app, basestring):
			prefix, app = app, prefix
			depr('Parameter order of Bottle.mount() changed.')
		parts = filter(None, prefix.split('/'))
		if not parts: raise ValueError('Empty path prefix.')
		path_depth = len(parts)
		options.setdefault('skip', True)
		options.setdefault('method', 'ANY')
		@self.route('/%s/:
		def mountpoint():
			try:
				request.path_shift(path_depth)
				rs = BaseResponse([], 200)
				def start_response(status, header):
					rs.status = status
					for name, value in header: rs.add_header(name, value)
					return rs.body.append
				rs.body = itertools.chain(rs.body, app(request.environ, start_response))
				return HTTPResponse(rs.body, rs.status, rs.headers)
			finally:
				request.path_shift(-path_depth)
		if not prefix.endswith('/'):
			self.route('/' + '/'.join(parts), callback=mountpoint, **options)
	def install(self, plugin):
		if hasattr(plugin, 'setup'): plugin.setup(self)
		if not callable(plugin) and not hasattr(plugin, 'apply'):
			raise TypeError("Plugins must be callable or implement .apply()")
		self.plugins.append(plugin)
		self.reset()
		return plugin
	def uninstall(self, plugin):
		removed, remove = [], plugin
		for i, plugin in list(enumerate(self.plugins))[::-1]:
			if remove is True or remove is plugin or remove is type(plugin) \
			or getattr(plugin, 'name', True) == remove:
				removed.append(plugin)
				del self.plugins[i]
				if hasattr(plugin, 'close'): plugin.close()
		if removed: self.reset()
		return removed
	def reset(self, route=None):
		if route is None: routes = self.routes
		elif isinstance(route, Route): routes = [route]
		else: routes = [self.routes[route]]
		for route in routes: route.reset()
		if DEBUG:
			for route in routes: route.prepare()
		self.hooks.trigger('app_reset')
	def close(self):
		for plugin in self.plugins:
			if hasattr(plugin, 'close'): plugin.close()
		self.stopped = True
	def match(self, environ):
		return self.router.match(environ)
	def get_url(self, routename, **kargs):
		scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'
		location = self.router.build(routename, **kargs).lstrip('/')
		return urljoin(urljoin('/', scriptname), location)
	def route(self, path=None, method='GET', callback=None, name=None,
			  apply=None, skip=None, **config):
		if callable(path): path, callback = None, path
		plugins = makelist(apply)
		skiplist = makelist(skip)
		def decorator(callback):
			if isinstance(callback, basestring): callback = load(callback)
			for rule in makelist(path) or yieldroutes(callback):
				for verb in makelist(method):
					verb = verb.upper()
					route = Route(self, rule, verb, callback, name=name,
								  plugins=plugins, skiplist=skiplist, **config)
					self.routes.append(route)
					self.router.add(rule, verb, route, name=name)
					if DEBUG: route.prepare()
			return callback
		return decorator(callback) if callback else decorator
	def get(self, path=None, method='GET', **options):
		return self.route(path, method, **options)
	def post(self, path=None, method='POST', **options):
		return self.route(path, method, **options)
	def put(self, path=None, method='PUT', **options):
		return self.route(path, method, **options)
	def delete(self, path=None, method='DELETE', **options):
		return self.route(path, method, **options)
	def error(self, code=500):
		def wrapper(handler):
			self.error_handler[int(code)] = handler
			return handler
		return wrapper
	def hook(self, name):
		def wrapper(func):
			self.hooks.add(name, func)
			return func
		return wrapper
	def handle(self, path, method='GET'):
		depr("This method will change semantics in 0.10. Try to avoid it.")
		if isinstance(path, dict):
			return self._handle(path)
		return self._handle({'PATH_INFO': path, 'REQUEST_METHOD': method.upper()})
	def _handle(self, environ):
		try:
			route, args = self.router.match(environ)
			environ['route.handle'] = environ['bottle.route'] = route
			environ['route.url_args'] = args
			return route.call(**args)
		except HTTPResponse, r:
			return r
		except RouteReset:
			route.reset()
			return self._handle(environ)
		except (KeyboardInterrupt, SystemExit, MemoryError):
			raise
		except Exception, e:
			if not self.catchall: raise
			stacktrace = format_exc(10)
			environ['wsgi.errors'].write(stacktrace)
			return HTTPError(500, "Internal Server Error", e, stacktrace)
	def _cast(self, out, request, response, peek=None):
		if not out:
			response['Content-Length'] = 0
			return []
		if isinstance(out, (tuple, list))\
		and isinstance(out[0], (bytes, unicode)):
			out = out[0][0:0].join(out)
		if isinstance(out, unicode):
			out = out.encode(response.charset)
		if isinstance(out, bytes):
			response['Content-Length'] = len(out)
			return [out]
		if isinstance(out, HTTPError):
			out.apply(response)
			out = self.error_handler.get(out.status, repr)(out)
			if isinstance(out, HTTPResponse):
				depr('Error handlers must not return :exc:`HTTPResponse`.')
			return self._cast(out, request, response)
		if isinstance(out, HTTPResponse):
			out.apply(response)
			return self._cast(out.output, request, response)
		if hasattr(out, 'read'):
			if 'wsgi.file_wrapper' in request.environ:
				return request.environ['wsgi.file_wrapper'](out)
			elif hasattr(out, 'close') or not hasattr(out, '__iter__'):
				return WSGIFileWrapper(out)
		try:
			out = iter(out)
			first = out.next()
			while not first:
				first = out.next()
		except StopIteration:
			return self._cast('', request, response)
		except HTTPResponse, e:
			first = e
		except Exception, e:
			first = HTTPError(500, 'Unhandled exception', e, format_exc(10))
			if isinstance(e, (KeyboardInterrupt, SystemExit, MemoryError))\
			or not self.catchall:
				raise
		if isinstance(first, HTTPResponse):
			return self._cast(first, request, response)
		if isinstance(first, bytes):
			return itertools.chain([first], out)
		if isinstance(first, unicode):
			return itertools.imap(lambda x: x.encode(response.charset),
								  itertools.chain([first], out))
		return self._cast(HTTPError(500, 'Unsupported response type: %s'\
										 % type(first)), request, response)
	def wsgi(self, environ, start_response):
		try:
			environ['bottle.app'] = self
			request.bind(environ)
			response.bind()
			out = self._cast(self._handle(environ), request, response)
			if response._status_code in (100, 101, 204, 304)\
			or request.method == 'HEAD':
				if hasattr(out, 'close'): out.close()
				out = []
			start_response(response._status_line, list(response.iter_headers()))
			return out
		except (KeyboardInterrupt, SystemExit, MemoryError):
			raise
		except Exception, e:
			if not self.catchall: raise
			err = '<h1>Critical error while processing request: %s</h1>' \
				  % html_escape(environ.get('PATH_INFO', '/'))
			if DEBUG:
				err += '<h2>Error:</h2>\n<pre>\n%s\n</pre>\n' \
					   '<h2>Traceback:</h2>\n<pre>\n%s\n</pre>\n' \
					   % (html_escape(repr(e)), html_escape(format_exc(10)))
			environ['wsgi.errors'].write(err)
			headers = [('Content-Type', 'text/html; charset=UTF-8')]
			start_response('500 INTERNAL SERVER ERROR', headers)
			return [tob(err)]
	def __call__(self, environ, start_response):
		return self.wsgi(environ, start_response)
class BaseRequest(DictMixin):
	MEMFILE_MAX = 102400
	def __init__(self, environ):
		self.environ = environ
		environ['bottle.request'] = self
	@property
	def path(self):
		return '/' + self.environ.get('PATH_INFO','').lstrip('/')
	@property
	def method(self):
		return self.environ.get('REQUEST_METHOD', 'GET').upper()
	@DictProperty('environ', 'bottle.request.headers', read_only=True)
	def headers(self):
		return WSGIHeaderDict(self.environ)
	def get_header(self, name, default=None):
		return self.headers.get(name, default)
	@DictProperty('environ', 'bottle.request.cookies', read_only=True)
	def cookies(self):
		cookies = SimpleCookie(self.environ.get('HTTP_COOKIE',''))
		return FormsDict((c.key, c.value) for c in cookies.itervalues())
	def get_cookie(self, key, default=None, secret=None):
		value = self.cookies.get(key)
		if secret and value:
			dec = cookie_decode(value, secret)
			return dec[1] if dec and dec[0] == key else default
		return value or default
	@DictProperty('environ', 'bottle.request.query', read_only=True)
	def query(self):
		data = parse_qs(self.query_string, keep_blank_values=True)
		get = self.environ['bottle.get'] = FormsDict()
		for key, values in data.iteritems():
			for value in values:
				get[key] = value
		return get
	@DictProperty('environ', 'bottle.request.forms', read_only=True)
	def forms(self):
		forms = FormsDict()
		for name, item in self.POST.iterallitems():
			if not hasattr(item, 'filename'):
				forms[name] = item
		return forms
	@DictProperty('environ', 'bottle.request.params', read_only=True)
	def params(self):
		params = FormsDict()
		for key, value in self.query.iterallitems():
			params[key] = value
		for key, value in self.forms.iterallitems():
			params[key] = value
		return params
	@DictProperty('environ', 'bottle.request.files', read_only=True)
	def files(self):
		files = FormsDict()
		for name, item in self.POST.iterallitems():
			if hasattr(item, 'filename'):
				files[name] = item
		return files
	@DictProperty('environ', 'bottle.request.json', read_only=True)
	def json(self):
		if 'application/json' in self.environ.get('CONTENT_TYPE', '') \
		and 0 < self.content_length < self.MEMFILE_MAX:
			return json_loads(self.body.read(self.MEMFILE_MAX))
		return None
	@DictProperty('environ', 'bottle.request.body', read_only=True)
	def _body(self):
		maxread = max(0, self.content_length)
		stream = self.environ['wsgi.input']
		body = BytesIO() if maxread < self.MEMFILE_MAX else TemporaryFile(mode='w+b')
		while maxread > 0:
			part = stream.read(min(maxread, self.MEMFILE_MAX))
			if not part: break
			body.write(part)
			maxread -= len(part)
		self.environ['wsgi.input'] = body
		body.seek(0)
		return body
	@property
	def body(self):
		self._body.seek(0)
		return self._body
	GET = query
	@DictProperty('environ', 'bottle.request.post', read_only=True)
	def POST(self):
		post = FormsDict()
		safe_env = {'QUERY_STRING':''}
		for key in ('REQUEST_METHOD', 'CONTENT_TYPE', 'CONTENT_LENGTH'):
			if key in self.environ: safe_env[key] = self.environ[key]
		if NCTextIOWrapper:
			fb = NCTextIOWrapper(self.body, encoding='ISO-8859-1', newline='\n')
		else:
			fb = self.body
		data = cgi.FieldStorage(fp=fb, environ=safe_env, keep_blank_values=True)
		for item in data.list or []:
			post[item.name] = item if item.filename else item.value
		return post
	@property
	def COOKIES(self):
		depr('BaseRequest.COOKIES was renamed to BaseRequest.cookies (lowercase).')
		return self.cookies
	@property
	def url(self):
		return self.urlparts.geturl()
	@DictProperty('environ', 'bottle.request.urlparts', read_only=True)
	def urlparts(self):
		env = self.environ
		http = env.get('wsgi.url_scheme', 'http')
		host = env.get('HTTP_X_FORWARDED_HOST') or env.get('HTTP_HOST')
		if not host:
			host = env.get('SERVER_NAME', '127.0.0.1')
			port = env.get('SERVER_PORT')
			if port and port != ('80' if http == 'http' else '443'):
				host += ':' + port
		path = urlquote(self.fullpath)
		return UrlSplitResult(http, host, path, env.get('QUERY_STRING'), '')
	@property
	def fullpath(self):
		return urljoin(self.script_name, self.path.lstrip('/'))
	@property
	def query_string(self):
		return self.environ.get('QUERY_STRING', '')
	@property
	def script_name(self):
		script_name = self.environ.get('SCRIPT_NAME', '').strip('/')
		return '/' + script_name + '/' if script_name else '/'
	def path_shift(self, shift=1):
		script = self.environ.get('SCRIPT_NAME','/')
		self['SCRIPT_NAME'], self['PATH_INFO'] = path_shift(script, self.path, shift)
	@property
	def content_length(self):
		return int(self.environ.get('CONTENT_LENGTH') or -1)
	@property
	def is_xhr(self):
		requested_with = self.environ.get('HTTP_X_REQUESTED_WITH','')
		return requested_with.lower() == 'xmlhttprequest'
	@property
	def is_ajax(self):
		return self.is_xhr
	@property
	def auth(self):
		basic = parse_auth(self.environ.get('HTTP_AUTHORIZATION',''))
		if basic: return basic
		ruser = self.environ.get('REMOTE_USER')
		if ruser: return (ruser, None)
		return None
	@property
	def remote_route(self):
		proxy = self.environ.get('HTTP_X_FORWARDED_FOR')
		if proxy: return [ip.strip() for ip in proxy.split(',')]
		remote = self.environ.get('REMOTE_ADDR')
		return [remote] if remote else []
	@property
	def remote_addr(self):
		route = self.remote_route
		return route[0] if route else None
	def copy(self):
		return Request(self.environ.copy())
	def __getitem__(self, key): return self.environ[key]
	def __delitem__(self, key): self[key] = ""; del(self.environ[key])
	def __iter__(self): return iter(self.environ)
	def __len__(self): return len(self.environ)
	def keys(self): return self.environ.keys()
	def __setitem__(self, key, value):
		if self.environ.get('bottle.request.readonly'):
			raise KeyError('The environ dictionary is read-only.')
		self.environ[key] = value
		todelete = ()
		if key == 'wsgi.input':
			todelete = ('body', 'forms', 'files', 'params', 'post', 'json')
		elif key == 'QUERY_STRING':
			todelete = ('query', 'params')
		elif key.startswith('HTTP_'):
			todelete = ('headers', 'cookies')
		for key in todelete:
			self.environ.pop('bottle.request.'+key, None)
	def __repr__(self):
		return '<%s: %s %s>' % (self.__class__.__name__, self.method, self.url)
def _hkey(s):
	return s.title().replace('_','-')
class HeaderProperty(object):
	def __init__(self, name, reader=None, writer=str, default=''):
		self.name, self.reader, self.writer, self.default = name, reader, writer, default
		self.__doc__ = 'Current value of the %r header.' % name.title()
	def __get__(self, obj, cls):
		if obj is None: return self
		value = obj.headers.get(self.name)
		return self.reader(value) if (value and self.reader) else (value or self.default)
	def __set__(self, obj, value):
		if self.writer: value = self.writer(value)
		obj.headers[self.name] = value
	def __delete__(self, obj):
		if self.name in obj.headers:
			del obj.headers[self.name]
class BaseResponse(object):
	default_status = 200
	default_content_type = 'text/html; charset=UTF-8'
	bad_headers = {
		204: set(('Content-Type',)),
		304: set(('Allow', 'Content-Encoding', 'Content-Language',
				  'Content-Length', 'Content-Range', 'Content-Type',
				  'Content-Md5', 'Last-Modified'))}
	def __init__(self, body='', status=None, **headers):
		self._status_line = None
		self._status_code = None
		self.body = body
		self._cookies = None
		self._headers = {'Content-Type': [self.default_content_type]}
		self.status = status or self.default_status
		if headers:
			for name, value in headers.items():
				self[name] = value
	def copy(self):
		copy = Response()
		copy.status = self.status
		copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())
		return copy
	def __iter__(self):
		return iter(self.body)
	def close(self):
		if hasattr(self.body, 'close'):
			self.body.close()
	@property
	def status_line(self):
		return self._status_line
	@property
	def status_code(self):
		return self._status_code
	def _set_status(self, status):
		if isinstance(status, int):
			code, status = status, _HTTP_STATUS_LINES.get(status)
		elif ' ' in status:
			status = status.strip()
			code   = int(status.split()[0])
		else:
			raise ValueError('String status line without a reason phrase.')
		if not 100 <= code <= 999: raise ValueError('Status code out of range.')
		self._status_code = code
		self._status_line = status or ('%d Unknown' % code)
	def _get_status(self):
		depr('BaseReuqest.status will change to return a string in 0.11. Use'\
			 ' status_line and status_code to make sure.')
		return self._status_code
	status = property(_get_status, _set_status, None,)
	del _get_status, _set_status
	@property
	def headers(self):
		self.__dict__['headers'] = hdict = HeaderDict()
		hdict.dict = self._headers
		return hdict
	def __contains__(self, name): return _hkey(name) in self._headers
	def __delitem__(self, name):  del self._headers[_hkey(name)]
	def __getitem__(self, name):  return self._headers[_hkey(name)][-1]
	def __setitem__(self, name, value): self._headers[_hkey(name)] = [str(value)]
	def get_header(self, name, default=None):
		return self._headers.get(_hkey(name), [default])[-1]
	def set_header(self, name, value, append=False):
		if append:
			self.add_header(name, value)
		else:
			self._headers[_hkey(name)] = [str(value)]
	def add_header(self, name, value):
		self._headers.setdefault(_hkey(name), []).append(str(value))
	def iter_headers(self):
		headers = self._headers.iteritems()
		bad_headers = self.bad_headers.get(self.status_code)
		if bad_headers:
			headers = [h for h in headers if h[0] not in bad_headers]
		for name, values in headers:
			for value in values:
				yield name, value
		if self._cookies:
			for c in self._cookies.values():
				yield 'Set-Cookie', c.OutputString()
	def wsgiheader(self):
		depr('The wsgiheader method is deprecated. See headerlist.')
		return self.headerlist
	@property
	def headerlist(self):
		return list(self.iter_headers())
	content_type = HeaderProperty('Content-Type')
	content_length = HeaderProperty('Content-Length', reader=int)
	@property
	def charset(self):
		if 'charset=' in self.content_type:
			return self.content_type.split('charset=')[-1].split(';')[0].strip()
		return 'UTF-8'
	@property
	def COOKIES(self):
		depr('The COOKIES dict is deprecated. Use `set_cookie()` instead.')
		if not self._cookies:
			self._cookies = SimpleCookie()
		return self._cookies
	def set_cookie(self, name, value, secret=None, **options):
		if not self._cookies:
			self._cookies = SimpleCookie()
		if secret:
			value = touni(cookie_encode((name, value), secret))
		elif not isinstance(value, basestring):
			raise TypeError('Secret key missing for non-string Cookie.')
		if len(value) > 4096: raise ValueError('Cookie value to long.')
		self._cookies[name] = value
		for key, value in options.iteritems():
			if key == 'max_age':
				if isinstance(value, timedelta):
					value = value.seconds + value.days * 24 * 3600
			if key == 'expires':
				if isinstance(value, (datedate, datetime)):
					value = value.timetuple()
				elif isinstance(value, (int, float)):
					value = time.gmtime(value)
				value = time.strftime("%a, %d %b %Y %H:%M:%S GMT", value)
			self._cookies[name][key.replace('_', '-')] = value
	def delete_cookie(self, key, **kwargs):
		kwargs['max_age'] = -1
		kwargs['expires'] = 0
		self.set_cookie(key, '', **kwargs)
	def __repr__(self):
		out = ''
		for name, value in self.headerlist:
			out += '%s: %s\n' % (name.title(), value.strip())
		return out
class LocalRequest(BaseRequest, threading.local):
	def __init__(self): pass
	bind = BaseRequest.__init__
class LocalResponse(BaseResponse, threading.local):
	bind = BaseResponse.__init__
Response = LocalResponse
Request  = LocalRequest
class PluginError(BottleException): pass
class JSONPlugin(object):
	name = 'json'
	api  = 2
	def __init__(self, json_dumps=json_dumps):
		self.json_dumps = json_dumps
	def apply(self, callback, context):
		dumps = self.json_dumps
		if not dumps: return callback
		def wrapper(*a, **ka):
			rv = callback(*a, **ka)
			if isinstance(rv, dict):
				json_response = dumps(rv)
				response.content_type = 'application/json'
				return json_response
			return rv
		return wrapper
class HooksPlugin(object):
	name = 'hooks'
	api  = 2
	_names = 'before_request', 'after_request', 'app_reset'
	def __init__(self):
		self.hooks = dict((name, []) for name in self._names)
		self.app = None
	def _empty(self):
		return not (self.hooks['before_request'] or self.hooks['after_request'])
	def setup(self, app):
		self.app = app
	def add(self, name, func):
		was_empty = self._empty()
		self.hooks.setdefault(name, []).append(func)
		if self.app and was_empty and not self._empty(): self.app.reset()
	def remove(self, name, func):
		was_empty = self._empty()
		if name in self.hooks and func in self.hooks[name]:
			self.hooks[name].remove(func)
		if self.app and not was_empty and self._empty(): self.app.reset()
	def trigger(self, name, *a, **ka):
		hooks = self.hooks[name]
		if ka.pop('reversed', False): hooks = hooks[::-1]
		return [hook(*a, **ka) for hook in hooks]
	def apply(self, callback, context):
		if self._empty(): return callback
		def wrapper(*a, **ka):
			self.trigger('before_request')
			rv = callback(*a, **ka)
			self.trigger('after_request', reversed=True)
			return rv
		return wrapper
class TemplatePlugin(object):
	name = 'template'
	api  = 2
	def apply(self, callback, route):
		conf = route.config.get('template')
		if isinstance(conf, (tuple, list)) and len(conf) == 2:
			return view(conf[0], **conf[1])(callback)
		elif isinstance(conf, str) and 'template_opts' in route.config:
			depr('The `template_opts` parameter is deprecated.')
			return view(conf, **route.config['template_opts'])(callback)
		elif isinstance(conf, str):
			return view(conf)(callback)
		else:
			return callback
class _ImportRedirect(object):
	def __init__(self, name, impmask):
		self.name = name
		self.impmask = impmask
		self.module = sys.modules.setdefault(name, imp.new_module(name))
		self.module.__dict__.update({'__file__': __file__, '__path__': [],
									'__all__': [], '__loader__': self})
		sys.meta_path.append(self)
	def find_module(self, fullname, path=None):
		if '.' not in fullname: return
		packname, modname = fullname.rsplit('.', 1)
		if packname != self.name: return
		return self
	def load_module(self, fullname):
		if fullname in sys.modules: return sys.modules[fullname]
		packname, modname = fullname.rsplit('.', 1)
		realname = self.impmask % modname
		__
		module = sys.modules[fullname] = sys.modules[realname]
		setattr(self.module, modname, module)
		module.__loader__ = self
		return module
class MultiDict(DictMixin):
	def __init__(self, *a, **k):
		self.dict = dict((k, [v]) for k, v in dict(*a, **k).iteritems())
	def __len__(self): return len(self.dict)
	def __iter__(self): return iter(self.dict)
	def __contains__(self, key): return key in self.dict
	def __delitem__(self, key): del self.dict[key]
	def __getitem__(self, key): return self.dict[key][-1]
	def __setitem__(self, key, value): self.append(key, value)
	def iterkeys(self): return self.dict.iterkeys()
	def itervalues(self): return (v[-1] for v in self.dict.itervalues())
	def iteritems(self): return ((k, v[-1]) for (k, v) in self.dict.iteritems())
	def iterallitems(self):
		for key, values in self.dict.iteritems():
			for value in values:
				yield key, value
	keys	 = iterkeys	 if py3k else lambda self: list(self.iterkeys())
	values   = itervalues   if py3k else lambda self: list(self.itervalues())
	items	= iteritems	if py3k else lambda self: list(self.iteritems())
	allitems = iterallitems if py3k else lambda self: list(self.iterallitems())
	def get(self, key, default=None, index=-1, type=None):
		try:
			val = self.dict[key][index]
			return type(val) if type else val
		except Exception, e:
			pass
		return default
	def append(self, key, value):
		self.dict.setdefault(key, []).append(value)
	def replace(self, key, value):
		self.dict[key] = [value]
	def getall(self, key):
		return self.dict.get(key) or []
	getone = get
	getlist = getall
class FormsDict(MultiDict):
	input_encoding = 'utf8'
	def getunicode(self, name, default=None, encoding=None):
		value, enc = self.get(name, default), encoding or self.input_encoding
		try:
			if isinstance(value, bytes):
				return value.decode(enc)
			elif isinstance(value, unicode):
				return value.encode('latin1').decode(enc)
			return value
		except UnicodeError, e:
			return default
	def __getattr__(self, name): return self.getunicode(name, default=u'')
class HeaderDict(MultiDict):
	def __init__(self, *a, **ka):
		self.dict = {}
		if a or ka: self.update(*a, **ka)
	def __contains__(self, key): return _hkey(key) in self.dict
	def __delitem__(self, key): del self.dict[_hkey(key)]
	def __getitem__(self, key): return self.dict[_hkey(key)][-1]
	def __setitem__(self, key, value): self.dict[_hkey(key)] = [str(value)]
	def append(self, key, value):
		self.dict.setdefault(_hkey(key), []).append(str(value))
	def replace(self, key, value): self.dict[_hkey(key)] = [str(value)]
	def getall(self, key): return self.dict.get(_hkey(key)) or []
	def get(self, key, default=None, index=-1):
		return MultiDict.get(self, _hkey(key), default, index)
	def filter(self, names):
		for name in map(_hkey, names):
			if name in self.dict:
				del self.dict[name]
class WSGIHeaderDict(DictMixin):
	cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')
	def __init__(self, environ):
		self.environ = environ
	def _ekey(self, key):
		key = key.replace('-','_').upper()
		if key in self.cgikeys:
			return key
		return 'HTTP_' + key
	def raw(self, key, default=None):
		return self.environ.get(self._ekey(key), default)
	def __getitem__(self, key):
		return tonat(self.environ[self._ekey(key)], 'latin1')
	def __setitem__(self, key, value):
		raise TypeError("%s is read-only." % self.__class__)
	def __delitem__(self, key):
		raise TypeError("%s is read-only." % self.__class__)
	def __iter__(self):
		for key in self.environ:
			if key[:5] == 'HTTP_':
				yield key[5:].replace('_', '-').title()
			elif key in self.cgikeys:
				yield key.replace('_', '-').title()
	def keys(self): return [x for x in self]
	def __len__(self): return len(self.keys())
	def __contains__(self, key): return self._ekey(key) in self.environ
class ConfigDict(dict):
	def __getattr__(self, key):
		if key not in self and key[0].isupper():
			self[key] = ConfigDict()
		return self.get(key)
	def __setattr__(self, key, value):
		if hasattr(dict, key):
			raise AttributeError('Read-only attribute.')
		if key in self and self[key] and isinstance(self[key], ConfigDict):
			raise AttributeError('Non-empty namespace attribute.')
		self[key] = value
	def __delattr__(self, key):
		if key in self: del self[key]
	def __call__(self, *a, **ka):
		for key, value in dict(*a, **ka).iteritems(): setattr(self, key, value)
		return self
class AppStack(list):
	def __call__(self):
		return self[-1]
	def push(self, value=None):
		if not isinstance(value, Bottle):
			value = Bottle()
		self.append(value)
		return value
class WSGIFileWrapper(object):
   def __init__(self, fp, buffer_size=1024*64):
	   self.fp, self.buffer_size = fp, buffer_size
	   for attr in ('fileno', 'close', 'read', 'readlines'):
		   if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))
   def __iter__(self):
	   read, buff = self.fp.read, self.buffer_size
	   while True:
		   part = read(buff)
		   if not part: break
		   yield part
def abort(code=500, text='Unknown Error: Application stopped.'):
	raise HTTPError(code, text)
def redirect(url, code=None):
	if code is None:
		code = 303 if request.get('SERVER_PROTOCOL') == "HTTP/1.1" else 302
	location = urljoin(request.url, url)
	raise HTTPResponse("", status=code, header=dict(Location=location))
def static_file(filename, root, mimetype='auto', download=False):
	root = os.path.abspath(root) + os.sep
	filename = os.path.abspath(os.path.join(root, filename.strip('/\\')))
	header = dict()
	if not filename.startswith(root):
		return HTTPError(403, "Access denied.")
	if not os.path.exists(filename) or not os.path.isfile(filename):
		return HTTPError(404, "File does not exist.")
	if not os.access(filename, os.R_OK):
		return HTTPError(403, "You do not have permission to access this file.")
	if mimetype == 'auto':
		mimetype, encoding = mimetypes.guess_type(filename)
		if mimetype: header['Content-Type'] = mimetype
		if encoding: header['Content-Encoding'] = encoding
	elif mimetype:
		header['Content-Type'] = mimetype
	if download:
		download = os.path.basename(filename if download == True else download)
		header['Content-Disposition'] = 'attachment; filename="%s"' % download
	stats = os.stat(filename)
	header['Content-Length'] = stats.st_size
	lm = time.strftime("%a, %d %b %Y %H:%M:%S GMT", time.gmtime(stats.st_mtime))
	header['Last-Modified'] = lm
	ims = request.environ.get('HTTP_IF_MODIFIED_SINCE')
	if ims:
		ims = parse_date(ims.split(";")[0].strip())
	if ims is not None and ims >= int(stats.st_mtime):
		header['Date'] = time.strftime("%a, %d %b %Y %H:%M:%S GMT", time.gmtime())
		return HTTPResponse(status=304, header=header)
	body = '' if request.method == 'HEAD' else open(filename, 'rb')
	return HTTPResponse(body, header=header)
def debug(mode=True):
	global DEBUG
	DEBUG = bool(mode)
def parse_date(ims):
	try:
		ts = email.utils.parsedate_tz(ims)
		return time.mktime(ts[:8] + (0,)) - (ts[9] or 0) - time.timezone
	except (TypeError, ValueError, IndexError, OverflowError):
		return None
def parse_auth(header):
	try:
		method, data = header.split(None, 1)
		if method.lower() == 'basic':
			user, pwd = touni(base64.b64decode(tob(data))).split(':',1)
			return user, pwd
	except (KeyError, ValueError):
		return None
def _lscmp(a, b):
	return not sum(0 if x==y else 1 for x, y in zip(a, b)) and len(a) == len(b)
def cookie_encode(data, key):
	msg = base64.b64encode(pickle.dumps(data, -1))
	sig = base64.b64encode(hmac.new(tob(key), msg).digest())
	return tob('!') + sig + tob('?') + msg
def cookie_decode(data, key):
	data = tob(data)
	if cookie_is_encoded(data):
		sig, msg = data.split(tob('?'), 1)
		if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(key), msg).digest())):
			return pickle.loads(base64.b64decode(msg))
	return None
def cookie_is_encoded(data):
	return bool(data.startswith(tob('!')) and tob('?') in data)
def html_escape(string):
	return string.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')\
				 .replace('"','&quot;').replace("'",'&
def html_quote(string):
	return '"%s"' % html_escape(string).replace('\n','%
					.replace('\r','&
def yieldroutes(func):
	path = '/' + func.__name__.replace('__','/').lstrip('/')
	spec = inspect.getargspec(func)
	argc = len(spec[0]) - len(spec[3] or [])
	path += ('/:%s' * argc) % tuple(spec[0][:argc])
	yield path
	for arg in spec[0][argc:]:
		path += '/:%s' % arg
		yield path
def path_shift(script_name, path_info, shift=1):
	if shift == 0: return script_name, path_info
	pathlist = path_info.strip('/').split('/')
	scriptlist = script_name.strip('/').split('/')
	if pathlist and pathlist[0] == '': pathlist = []
	if scriptlist and scriptlist[0] == '': scriptlist = []
	if shift > 0 and shift <= len(pathlist):
		moved = pathlist[:shift]
		scriptlist = scriptlist + moved
		pathlist = pathlist[shift:]
	elif shift < 0 and shift >= -len(scriptlist):
		moved = scriptlist[shift:]
		pathlist = moved + pathlist
		scriptlist = scriptlist[:shift]
	else:
		empty = 'SCRIPT_NAME' if shift < 0 else 'PATH_INFO'
		raise AssertionError("Cannot shift. Nothing left
	new_script_name = '/' + '/'.join(scriptlist)
	new_path_info = '/' + '/'.join(pathlist)
	if path_info.endswith('/') and pathlist: new_path_info += '/'
	return new_script_name, new_path_info
def validate(**vkargs):
	depr('Use route wildcard filters instead.')
	def decorator(func):
		@functools.wraps(func)
		def wrapper(*args, **kargs):
			for key, value in vkargs.iteritems():
				if key not in kargs:
					abort(403, 'Missing parameter: %s' % key)
				try:
					kargs[key] = value(kargs[key])
				except ValueError:
					abort(403, 'Wrong parameter format for: %s' % key)
			return func(*args, **kargs)
		return wrapper
	return decorator
def auth_basic(check, realm="private", text="Access denied"):
	def decorator(func):
	  def wrapper(*a, **ka):
		user, password = request.auth or (None, None)
		if user is None or not check(user, password):
		  response.headers['WWW-Authenticate'] = 'Basic realm="%s"' % realm
		  return HTTPError(401, text)
		return func(*a, **ka)
	  return wrapper
	return decorator
def make_default_app_wrapper(name):
	@functools.wraps(getattr(Bottle, name))
	def wrapper(*a, **ka):
		return getattr(app(), name)(*a, **ka)
	return wrapper
for name in.split():
	globals()[name] = make_default_app_wrapper(name)
url = make_default_app_wrapper('get_url')
del name
class ServerAdapter(object):
	quiet = False
	def __init__(self, host='127.0.0.1', port=8080, **config):
		self.options = config
		self.host = host
		self.port = int(port)
	def run(self, handler):
		pass
	def __repr__(self):
		args = ', '.join(['%s=%s'%(k,repr(v)) for k, v in self.options.items()])
		return "%s(%s)" % (self.__class__.__name__, args)
class CGIServer(ServerAdapter):
	quiet = True
	def run(self, handler):
		def fixed_environ(environ, start_response):
			environ.setdefault('PATH_INFO', '')
			return handler(environ, start_response)
		CGIHandler().run(fixed_environ)
class FlupFCGIServer(ServerAdapter):
	def run(self, handler):
		self.options.setdefault('bindAddress', (self.host, self.port))
		flup.server.fcgi.WSGIServer(handler, **self.options).run()
class WSGIRefServer(ServerAdapter):
	def run(self, handler):
		if self.quiet:
			class QuietHandler(WSGIRequestHandler):
				def log_request(*args, **kw): pass
			self.options['handler_class'] = QuietHandler
		srv = make_server(self.host, self.port, handler, **self.options)
		srv.serve_forever()
class CherryPyServer(ServerAdapter):
	def run(self, handler):
		server = wsgiserver.CherryPyWSGIServer((self.host, self.port), handler)
		try:
			server.start()
		finally:
			server.stop()
class PasteServer(ServerAdapter):
	def run(self, handler):
		if not self.quiet:
			handler = TransLogger(handler)
		httpserver.serve(handler, host=self.host, port=str(self.port),
						 **self.options)
class MeinheldServer(ServerAdapter):
	def run(self, handler):
		server.listen((self.host, self.port))
		server.run(handler)
class FapwsServer(ServerAdapter):
	def run(self, handler):
		port = self.port
		if float(config.SERVER_IDENT[-2:]) > 0.4:
			port = str(port)
		evwsgi.start(self.host, port)
		if 'BOTTLE_CHILD' in os.environ and not self.quiet:
			print "WARNING: Auto-reloading does not work with Fapws3."
			print "		 (Fapws3 breaks python thread support)"
		evwsgi.set_base_module(base)
		def app(environ, start_response):
			environ['wsgi.multiprocess'] = False
			return handler(environ, start_response)
		evwsgi.wsgi_cb(('', app))
		evwsgi.run()
class TornadoServer(ServerAdapter):
	def run(self, handler):
		container = tornado.wsgi.WSGIContainer(handler)
		server = tornado.httpserver.HTTPServer(container)
		server.listen(port=self.port)
		tornado.ioloop.IOLoop.instance().start()
class AppEngineServer(ServerAdapter):
	quiet = True
	def run(self, handler):
		module = sys.modules.get('__main__')
		if module and not hasattr(module, 'main'):
			module.main = lambda: util.run_wsgi_app(handler)
		util.run_wsgi_app(handler)
class TwistedServer(ServerAdapter):
	def run(self, handler):
		thread_pool = ThreadPool()
		thread_pool.start()
		reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)
		factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))
		reactor.listenTCP(self.port, factory, interface=self.host)
		reactor.run()
class DieselServer(ServerAdapter):
	def run(self, handler):
		app = WSGIApplication(handler, port=self.port)
		app.run()
class GeventServer(ServerAdapter):
	def run(self, handler):
		if self.options.get('monkey', True):
			if not threading.local is local.local: monkey.patch_all()
		wsgi = wsgi_fast if self.options.get('fast') else pywsgi
		wsgi.WSGIServer((self.host, self.port), handler).serve_forever()
class GunicornServer(ServerAdapter):
	def run(self, handler):
		config = {'bind': "%s:%d" % (self.host, int(self.port))}
		config.update(self.options)
		class GunicornApplication(Application):
			def init(self, parser, opts, args):
				return config
			def load(self):
				return handler
		GunicornApplication().run()
class EventletServer(ServerAdapter):
	def run(self, handler):
		wsgi.server(listen((self.host, self.port)), handler)
class RocketServer(ServerAdapter):
	def run(self, handler):
		server = Rocket((self.host, self.port), 'wsgi', { 'wsgi_app' : handler })
		server.start()
class BjoernServer(ServerAdapter):
	def run(self, handler):
		run(handler, self.host, self.port)
class AutoServer(ServerAdapter):
	adapters = [PasteServer, TwistedServer, CherryPyServer, WSGIRefServer]
	def run(self, handler):
		for sa in self.adapters:
			try:
				return sa(self.host, self.port, **self.options).run(handler)
			except ImportError:
				pass
server_names = {
	'cgi': CGIServer,
	'flup': FlupFCGIServer,
	'wsgiref': WSGIRefServer,
	'cherrypy': CherryPyServer,
	'paste': PasteServer,
	'fapws3': FapwsServer,
	'tornado': TornadoServer,
	'gae': AppEngineServer,
	'twisted': TwistedServer,
	'diesel': DieselServer,
	'meinheld': MeinheldServer,
	'gunicorn': GunicornServer,
	'eventlet': EventletServer,
	'gevent': GeventServer,
	'rocket': RocketServer,
	'bjoern' : BjoernServer,
	'auto': AutoServer,
}
def load(target, **namespace):
	module, target = target.split(":", 1) if ':' in target else (target, None)
	if module not in sys.modules: __
	if not target: return sys.modules[module]
	if target.isalnum(): return getattr(sys.modules[module], target)
	package_name = module.split('.')[0]
	namespace[package_name] = sys.modules[package_name]
	return eval('%s.%s' % (module, target), namespace)
def load_app(target):
	global NORUN; NORUN, nr_old = True, NORUN
	try:
		tmp = default_app.push()
		rv = load(target)
		return rv if callable(rv) else tmp
	finally:
		default_app.remove(tmp)
		NORUN = nr_old
def run(app=None, server='wsgiref', host='127.0.0.1', port=8080,
		interval=1, reloader=False, quiet=False, plugins=None, **kargs):
	if NORUN: return
	if reloader and not os.environ.get('BOTTLE_CHILD'):
		try:
			fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')
			os.close(fd)
			while os.path.exists(lockfile):
				args = [sys.executable] + sys.argv
				environ = os.environ.copy()
				environ['BOTTLE_CHILD'] = 'true'
				environ['BOTTLE_LOCKFILE'] = lockfile
				p = subprocess.Popen(args, env=environ)
				while p.poll() is None:
					os.utime(lockfile, None)
					time.sleep(interval)
				if p.poll() != 3:
					if os.path.exists(lockfile): os.unlink(lockfile)
					sys.exit(p.poll())
		except KeyboardInterrupt:
			pass
		finally:
			if os.path.exists(lockfile):
				os.unlink(lockfile)
		return
	stderr = sys.stderr.write
	try:
		app = app or default_app()
		if isinstance(app, basestring):
			app = load_app(app)
		if not callable(app):
			raise ValueError("Application is not callable: %r" % app)
		for plugin in plugins or []:
			app.install(plugin)
		if server in server_names:
			server = server_names.get(server)
		if isinstance(server, basestring):
			server = load(server)
		if isinstance(server, type):
			server = server(host=host, port=port, **kargs)
		if not isinstance(server, ServerAdapter):
			raise ValueError("Unknown or unsupported server: %r" % server)
		server.quiet = server.quiet or quiet
		if not server.quiet:
			stderr("Bottle server starting up (using %s)...\n" % repr(server))
			stderr("Listening on http://%s:%d/\n" % (server.host, server.port))
			stderr("Hit Ctrl-C to quit.\n\n")
		if reloader:
			lockfile = os.environ.get('BOTTLE_LOCKFILE')
			bgcheck = FileCheckerThread(lockfile, interval)
			with bgcheck:
				server.run(app)
			if bgcheck.status == 'reload':
				sys.exit(3)
		else:
			server.run(app)
	except KeyboardInterrupt:
		pass
	except (SyntaxError, ImportError):
		if not reloader: raise
		if not getattr(server, 'quiet', False): print_exc()
		sys.exit(3)
	finally:
		if not getattr(server, 'quiet', False): stderr('Shutdown...\n')
class FileCheckerThread(threading.Thread):
	def __init__(self, lockfile, interval):
		threading.Thread.__init__(self)
		self.lockfile, self.interval = lockfile, interval
		self.status = None
	def run(self):
		exists = os.path.exists
		mtime = lambda path: os.stat(path).st_mtime
		files = dict()
		for module in sys.modules.values():
			path = getattr(module, '__file__', '')
			if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]
			if path and exists(path): files[path] = mtime(path)
		while not self.status:
			if not exists(self.lockfile)\
			or mtime(self.lockfile) < time.time() - self.interval - 5:
				self.status = 'error'
				thread.interrupt_main()
			for path, lmtime in files.iteritems():
				if not exists(path) or mtime(path) > lmtime:
					self.status = 'reload'
					thread.interrupt_main()
					break
			time.sleep(self.interval)
	
	def __enter__(self):
		self.start()
	
	def __exit__(self, exc_type, exc_val, exc_tb):
		if not self.status: self.status = 'exit'
		self.join()
		return issubclass(exc_type, KeyboardInterrupt)
class TemplateError(HTTPError):
	def __init__(self, message):
		HTTPError.__init__(self, 500, message)
class BaseTemplate(object):
	extensions = ['tpl','html','thtml','stpl']
	settings = {}
	defaults = {}
	def __init__(self, source=None, name=None, lookup=[], encoding='utf8', **settings):
		self.name = name
		self.source = source.read() if hasattr(source, 'read') else source
		self.filename = source.filename if hasattr(source, 'filename') else None
		self.lookup = map(os.path.abspath, lookup)
		self.encoding = encoding
		self.settings = self.settings.copy()
		self.settings.update(settings)
		if not self.source and self.name:
			self.filename = self.search(self.name, self.lookup)
			if not self.filename:
				raise TemplateError('Template %s not found.' % repr(name))
		if not self.source and not self.filename:
			raise TemplateError('No template specified.')
		self.prepare(**self.settings)
	@classmethod
	def search(cls, name, lookup=[]):
		if os.path.isfile(name): return name
		for spath in lookup:
			fname = os.path.join(spath, name)
			if os.path.isfile(fname):
				return fname
			for ext in cls.extensions:
				if os.path.isfile('%s.%s' % (fname, ext)):
					return '%s.%s' % (fname, ext)
	@classmethod
	def global_config(cls, key, *args):
		if args:
			cls.settings = cls.settings.copy()
			cls.settings[key] = args[0]
		else:
			return cls.settings[key]
	def prepare(self, **options):
		raise NotImplementedError
	def render(self, *args, **kwargs):
		raise NotImplementedError
class MakoTemplate(BaseTemplate):
	def prepare(self, **options):
		options.update({'input_encoding':self.encoding})
		options.setdefault('format_exceptions', bool(DEBUG))
		lookup = TemplateLookup(directories=self.lookup, **options)
		if self.source:
			self.tpl = Template(self.source, lookup=lookup, **options)
		else:
			self.tpl = Template(uri=self.name, filename=self.filename, lookup=lookup, **options)
	def render(self, *args, **kwargs):
		for dictarg in args: kwargs.update(dictarg)
		_defaults = self.defaults.copy()
		_defaults.update(kwargs)
		return self.tpl.render(**_defaults)
class CheetahTemplate(BaseTemplate):
	def prepare(self, **options):
		self.context = threading.local()
		self.context.vars = {}
		options['searchList'] = [self.context.vars]
		if self.source:
			self.tpl = Template(source=self.source, **options)
		else:
			self.tpl = Template(file=self.filename, **options)
	def render(self, *args, **kwargs):
		for dictarg in args: kwargs.update(dictarg)
		self.context.vars.update(self.defaults)
		self.context.vars.update(kwargs)
		out = str(self.tpl)
		self.context.vars.clear()
		return out
class Jinja2Template(BaseTemplate):
	def prepare(self, filters=None, tests=None, **kwargs):
		if 'prefix' in kwargs:
			raise RuntimeError('The keyword argument `prefix` has been removed. '
				'Use the full jinja2 environment name line_statement_prefix instead.')
		self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)
		if filters: self.env.filters.update(filters)
		if tests: self.env.tests.update(tests)
		if self.source:
			self.tpl = self.env.
		else:
			self.tpl = self.env.get_template(self.filename)
	def render(self, *args, **kwargs):
		for dictarg in args: kwargs.update(dictarg)
		_defaults = self.defaults.copy()
		_defaults.update(kwargs)
		return self.tpl.render(**_defaults)
	def loader(self, name):
		fname = self.search(name, self.lookup)
		if fname:
			with open(fname, "rb") as f:
				return f.read().decode(self.encoding)
class SimpleTALTemplate(BaseTemplate):
	def prepare(self, **options):
		if self.source:
			self.tpl = simpleTAL.compileHTMLTemplate(self.source)
		else:
			with open(self.filename, 'rb') as fp:
				self.tpl = simpleTAL.compileHTMLTemplate(tonat(fp.read()))
	def render(self, *args, **kwargs):
		for dictarg in args: kwargs.update(dictarg)
		context = simpleTALES.Context()
		for k,v in self.defaults.items():
			context.addGlobal(k, v)
		for k,v in kwargs.items():
			context.addGlobal(k, v)
		output = StringIO()
		self.tpl.expand(context, output)
		return output.getvalue()
class SimpleTemplate(BaseTemplate):
	blocks = ('if', 'elif', 'else', 'try', 'except', 'finally', 'for', 'while',
			  'with', 'def', 'class')
	dedent_blocks = ('elif', 'else', 'except', 'finally')
	@lazy_attribute
	def re_pytokens(cls):
		return re.compile(r, re.VERBOSE)
	def prepare(self, escape_func=html_escape, noescape=False, **kwargs):
		self.cache = {}
		enc = self.encoding
		self._str = lambda x: touni(x, enc)
		self._escape = lambda x: escape_func(touni(x, enc))
		if noescape:
			self._str, self._escape = self._escape, self._str
	@classmethod
	def split_comment(cls, code):
		if '
		subf = lambda m: '' if m.group(0)[0]=='
		return re.sub(cls.re_pytokens, subf, code)
	@cached_property
	def co(self):
		return compile(self.code, self.filename or '<string>', 'exec')
	@cached_property
	def code(self):
		stack = []
		lineno = 0
		ptrbuffer = []
		codebuffer = []
		multiline = dedent = oneline = False
		template = self.source or open(self.filename, 'rb').read()
		def yield_tokens(line):
			for i, part in enumerate(re.split(r'\{\{(.*?)\}\}', line)):
				if i % 2:
					if part.startswith('!'): yield 'RAW', part[1:]
					else: yield 'CMD', part
				else: yield 'TXT', part
		def flush():
			if not ptrbuffer: return
			cline = ''
			for line in ptrbuffer:
				for token, value in line:
					if token == 'TXT': cline += repr(value)
					elif token == 'RAW': cline += '_str(%s)' % value
					elif token == 'CMD': cline += '_escape(%s)' % value
					cline +=  ', '
				cline = cline[:-2] + '\\\n'
			cline = cline[:-2]
			if cline[:-1].endswith('\\\\\\\\\\n'):
				cline = cline[:-7] + cline[-1]
			cline = '_printlist([' + cline + '])'
			del ptrbuffer[:]
			code(cline)
		def code(stmt):
			for line in stmt.splitlines():
				codebuffer.append('  ' * len(stack) + line.strip())
		for line in template.splitlines(True):
			lineno += 1
			line = line if isinstance(line, unicode)\
						else unicode(line, encoding=self.encoding)
			if lineno <= 2:
				m = re.search(r"%.*coding[:=]\s*([-\w\.]+)", line)
				if m: self.encoding = m.group(1)
				if m: line = line.replace('coding','coding (removed)')
			if line.strip()[:2].count('%') == 1:
				line = line.split('%',1)[1].lstrip()
				cline = self.split_comment(line).strip()
				cmd = re.split(r'[^a-zA-Z0-9_]', cline)[0]
				flush()
				if cmd in self.blocks or multiline:
					cmd = multiline or cmd
					dedent = cmd in self.dedent_blocks
					if dedent and not oneline and not multiline:
						cmd = stack.pop()
					code(line)
					oneline = not cline.endswith(':')
					multiline = cmd if cline.endswith('\\') else False
					if not oneline and not multiline:
						stack.append(cmd)
				elif cmd == 'end' and stack:
					code('
				elif cmd == 'include':
					p = cline.split(None, 2)[1:]
					if len(p) == 2:
						code("_=_include(%s, _stdout, %s)" % (repr(p[0]), p[1]))
					elif p:
						code("_=_include(%s, _stdout)" % repr(p[0]))
					else:
						code("_printlist(_base)")
				elif cmd == 'rebase':
					p = cline.split(None, 2)[1:]
					if len(p) == 2:
						code("globals()['_rebase']=(%s, dict(%s))" % (repr(p[0]), p[1]))
					elif p:
						code("globals()['_rebase']=(%s, {})" % repr(p[0]))
				else:
					code(line)
			else:
				if line.strip().startswith('%%'):
					line = line.replace('%%', '%', 1)
				ptrbuffer.append(yield_tokens(line))
		flush()
		return '\n'.join(codebuffer) + '\n'
	def subtemplate(self, _name, _stdout, *args, **kwargs):
		for dictarg in args: kwargs.update(dictarg)
		if _name not in self.cache:
			self.cache[_name] = self.__class__(name=_name, lookup=self.lookup)
		return self.cache[_name].execute(_stdout, kwargs)
	def execute(self, _stdout, *args, **kwargs):
		for dictarg in args: kwargs.update(dictarg)
		env = self.defaults.copy()
		env.update({'_stdout': _stdout, '_printlist': _stdout.extend,
			   '_include': self.subtemplate, '_str': self._str,
			   '_escape': self._escape, 'get': env.get,
			   'setdefault': env.setdefault, 'defined': env.__contains__})
		env.update(kwargs)
		eval(self.co, env)
		if '_rebase' in env:
			subtpl, rargs = env['_rebase']
			rargs['_base'] = _stdout[:]
			del _stdout[:]
			return self.subtemplate(subtpl,_stdout,rargs)
		return env
	def render(self, *args, **kwargs):
		for dictarg in args: kwargs.update(dictarg)
		stdout = []
		self.execute(stdout, kwargs)
		return ''.join(stdout)
def template(*args, **kwargs):
	tpl = args[0] if args else None
	template_adapter = kwargs.pop('template_adapter', SimpleTemplate)
	if tpl not in TEMPLATES or DEBUG:
		settings = kwargs.pop('template_settings', {})
		lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)
		if isinstance(tpl, template_adapter):
			TEMPLATES[tpl] = tpl
			if settings: TEMPLATES[tpl].prepare(**settings)
		elif "\n" in tpl or "{" in tpl or "%" in tpl or '$' in tpl:
			TEMPLATES[tpl] = template_adapter(source=tpl, lookup=lookup, **settings)
		else:
			TEMPLATES[tpl] = template_adapter(name=tpl, lookup=lookup, **settings)
	if not TEMPLATES[tpl]:
		abort(500, 'Template (%s) not found' % tpl)
	for dictarg in args[1:]: kwargs.update(dictarg)
	return TEMPLATES[tpl].render(kwargs)
mako_template = functools.partial(template, template_adapter=MakoTemplate)
cheetah_template = functools.partial(template, template_adapter=CheetahTemplate)
jinja2_template = functools.partial(template, template_adapter=Jinja2Template)
simpletal_template = functools.partial(template, template_adapter=SimpleTALTemplate)
def view(tpl_name, **defaults):
	def decorator(func):
		@functools.wraps(func)
		def wrapper(*args, **kwargs):
			result = func(*args, **kwargs)
			if isinstance(result, (dict, DictMixin)):
				tplvars = defaults.copy()
				tplvars.update(result)
				return template(tpl_name, **tplvars)
			return result
		return wrapper
	return decorator
mako_view = functools.partial(view, template_adapter=MakoTemplate)
cheetah_view = functools.partial(view, template_adapter=CheetahTemplate)
jinja2_view = functools.partial(view, template_adapter=Jinja2Template)
simpletal_view = functools.partial(view, template_adapter=SimpleTALTemplate)
TEMPLATE_PATH = ['./', './views/']
TEMPLATES = {}
DEBUG = False
NORUN = False
HTTP_CODES = httplib.responses
HTTP_CODES[418] = "I'm a teapot"
HTTP_CODES[428] = "Precondition Required"
HTTP_CODES[429] = "Too Many Requests"
HTTP_CODES[431] = "Request Header Fields Too Large"
HTTP_CODES[511] = "Network Authentication Required"
_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.iteritems())
ERROR_PAGE_TEMPLATE =
request = Request()
response = Response()
local = threading.local()
app = default_app = AppStack()
app.push()
ext = _ImportRedirect(__name__+'.ext', 'bottle_%s').module
if __name__ == '__main__':
	opt, args, parser = _cmd_options, _cmd_args, _cmd_parser
	if opt.version:
		print 'Bottle', __version__; sys.exit(0)
	if not args:
		parser.print_help()
		print '\nError: No application specified.\n'
		sys.exit(1)
	try:
		sys.path.insert(0, '.')
		sys.modules.setdefault('bottle', sys.modules['__main__'])
	except (AttributeError, ImportError), e:
		parser.error(e.args[0])
	if opt.bind and ':' in opt.bind:
		host, port = opt.bind.rsplit(':', 1)
	else:
		host, port = (opt.bind or 'localhost'), 8080
	debug(opt.debug)
	run(args[0], host=host, port=port, server=opt.server, reloader=opt.reload, plugins=opt.plugin)