KEYSPACE = "salvus"
NODES = []
last_node = -1
def set_nodes(nodes):
	global NODES, last_node, pool
	pool = {}
	NODES = nodes
	last_node = random.randrange(len(NODES)) if len(NODES) else -1
def get_node():
	global NODES, last_node
	if len(NODES) == 0: raise RuntimeError("there are no cassandra nodes")
	last_node = (last_node + 1)%len(NODES)
	return NODES[last_node]
def time_to_timestamp(t):
	return int(t*1000)
def timestamp_to_time(t):
	return float(t)/1000
def time_to_ascii(t):
	s = _time.localtime(t)
	return _time.strftime("%Y-%m-%d %H:%M:%S", s)
def now():
	return Time(_time.time())
class Time(float):
	def __repr__(self):
		return time_to_ascii(self)
	def to_cassandra(self):
		return time_to_timestamp(self)
pool = {}
def connect(keyspace=None, use_cache=True, user=None, password=None):
	key = (keyspace, user)
	if keyspace is None:
		keyspace = KEYSPACE
	if use_cache and pool.has_key(key):
		return pool[key]
	for i in range(len(NODES)):
		try:
			node = get_node()
			con = cql.connect(node, keyspace=keyspace, cql_version='3.0.0', user=user, password=password)
			print "Connected to %s"%node
			pool[key] = con
			return con
		except Exception, msg:
			print msg
	raise RuntimeError("no cassandra nodes are up!! (selecting
def cursor(keyspace=None, use_cache=True, user=None, password=None):
	if keyspace is None:
		keyspace = KEYSPACE
	return connect(keyspace=keyspace, use_cache=use_cache, user=user, password=password).cursor()
def cursor_execute(query, param_dict=None, keyspace=None, timeout=1, user=None, password=None):
	if keyspace is None:
		keyspace = KEYSPACE
	if param_dict is None: param_dict = {}
	for k, v in param_dict.iteritems():
		if hasattr(v, 'to_cassandra'):
			param_dict[k] = v.to_cassandra()
	def f(*a):
		raise KeyboardInterrupt
	try:
		signal.signal(signal.SIGALRM, f)
		signal.alarm(timeout)
		try:
			cur = cursor(keyspace=keyspace, user=user, password=password)
			cur.execute(query, param_dict)
		except (KeyboardInterrupt, Exception), msg:
			print msg
			cur = cursor(keyspace=keyspace, use_cache=False, user=user, password=password)
			cur.execute(query, param_dict)
	finally:
		signal.signal(signal.SIGALRM, signal.SIG_IGN)
	return cur
def keyspace_exists(keyspace):
	try:
		con = connect(keyspace="")
		con.cursor().execute("use " + keyspace)
		return True
	except cql.ProgrammingError:
		return False
def init_salvus_schema(keyspace=None):
	if keyspace is None:
		keyspace = KEYSPACE
	con = connect(keyspace='')
	cursor = con.cursor()
	if not keyspace_exists(keyspace):
		cursor.execute("CREATE KEYSPACE %s WITH REPLICATION = {'class' : 'NetworkTopologyStrategy', 'DC0' : 1, 'DC1' : 1}"%keyspace)
	cursor.execute("USE %s"%keyspace)
	for s in open('db_schema.cql').read().split('CREATE'):
		if s:
			cql = "CREATE " + s
			print cql
			try:
				cursor.execute(cql)
			except Exception, msg:
				if 'already existing column family' not in str(msg) and 'Index already exists' not in str(msg):
					print msg
					print cql
	cursor.execute("UPDATE plans SET current=true, name='Free', session_limit=3, storage_limit=250, max_session_time=30, ram_limit=2000, support_level='None' WHERE plan_id=13814000-1dd2-11b2-0000-fe8ebeead9df")
def to_json(x):
	return json.dumps(x, separators=(',',':'))
def
	return json.loads(x)
class DBObject(object):
	def __repr__(self):
		return '<%s: %s>'%(str(type(self)).split('.')[-1].split("'")[0], self.__dict__)
class Plans(DBObject):
	def create_plan(self, name):
		plan = Plan(uuid.uuid4())
		plan.name = name
		plan.save()
		cursor_execute("UPDATE newest_plans SET  plan_id = :plan_id WHERE name = :name",
					   {'name':name, 'plan_id':plan.plan_id})
		return plan
	def plan(self, plan_id):
		return Plan(plan_id)
	def newest_plan(self, name):
		c = cursor_execute("SELECT plan_id FROM newest_plans WHERE name = :name", {'name':name}).fetchone()
		if c is not None:
			return Plan(c[0])
class Plan(DBObject):
	def __init__(self, plan_id, data=None):
		self.plan_id = plan_id
		c = cursor_execute("SELECT name, data, time FROM plans WHERE plan_id = :plan_id", {'plan_id':plan_id}).fetchone()
		if c is not None:
			self.name = c[0]
			self.data =
			self.time = Time(c[2])
		else:
			self.name = ''
			self.data = data
			self.time = now()
	def save(self):
		cursor_execute("UPDATE plans SET name = :name, data = :data, time = :time WHERE plan_id = :plan_id",
					   {'name':self.name, 'data':to_json(self.data),
						'time':self.time, 'plan_id':self.plan_id})
	def number_of_accounts_with_this_plan(self):
		return cursor_execute("SELECT COUNT(*) FROM accounts WHERE plan_id = :plan_id",
					   {'plan_id':self.plan_id}).fetchone()[0]
class Accounts(DBObject):
	def create_account(self):
		account = Account(uuid.uuid4())
		account.save()
		return account
	def account_
		return Account(account_id)
	def accounts_with_email(self, email):
		return [Account(account_id=e[0]) for e in cursor_execute("SELECT account_id FROM accounts WHERE email = :email", {'email':email})]
	def accounts_with_auth(self, provider, login_name):
		c = cursor_execute("SELECT account_id FROM auths WHERE provider = :provider AND login_name = :login_name",
						   {'provider':provider, 'login_name':login_name})
		return [Account(account_id=e[0]) for e in c]
	def accounts_with_username(self, username):
		c = cursor_execute("SELECT account_id FROM accounts WHERE username = :username", {'username':username})
		return [Account(account_id=e[0]) for e in c]
	def number_of_accounts(self):
		return cursor_execute("SELECT COUNT(*) FROM accounts").fetchone()[0]
	__len__ = number_of_accounts
	def ids_of_accounts_with_event_in_last_n_seconds(self, n):
		return set([x[0] for x in cursor_execute("SELECT account_id FROM account_events WHERE time >= :time",
								   {'time':Time(_time.time()-n)})])
class Account(DBObject):
	def __init__(self, account_id):
		self.account_id = account_id
		c = cursor_execute("SELECT creation_time, username, passwd_hash, email, plan_id, plan_starttime, prefs FROM accounts WHERE account_id = :account_id",
						   {'account_id':account_id}).fetchone()
		if c is not None:
			self.creation_time = Time(c[0])
			self.username = c[1]
			self.passwd_hash = c[2]
			self.email = c[3]
			self.plan_id = c[4]
			self.plan_starttime = Time(c[5])
			self.prefs =
		else:
			self.creation_time = now()
			self.username = ''
			self.passwd_hash = ''
			self.email = ''
			self.plan_id = Plans().newest_plan('free').plan_id
			self.plan_starttime = now()
			self.prefs = {}
	def events(self, max_age=None):
		if max_age is None:
			c = cursor_execute("SELECT time, event, value FROM account_events WHERE account_id = :account_id", {'account_id':self.account_id})
		else:
			min_time = Time(_time.time() - max_age)
			c = cursor_execute("SELECT time, event, value FROM account_events WHERE account_id = :account_id AND time >= :min_time",
							   {'account_id':self.account_id, 'min_time':min_time})
		return [AccountEvent(account_id=self.account_id, time=e[0], event=e[1], value=
	def create_event(self, event, value=''):
		x = AccountEvent(self.account_id, time=now(), event=event, value=value)
		x.save()
		return x
	def plan(self):
		return Plan(self.plan_id)
	def auths(self):
		c = cursor_execute("SELECT provider, login_name, info FROM auths WHERE account_id = :account_id", {'account_id':self.account_id})
		return [Auth(self.account_id, provider=x[0], login_name=x[1], info=
	def create_auth(self, provider, login_name, info):
		a = Auth(self.account_id, provider=provider, login_name=login_name, info=info)
		a.save()
		return a
	def save(self):
		opts = {'account_id':self.account_id, 'creation_time':time_to_timestamp(self.creation_time),
				'username':self.username, 'passwd_hash':self.passwd_hash,
				'email':self.email,'prefs':to_json(self.prefs),
				'plan_id':self.plan_id, 'plan_starttime':time_to_timestamp(self.plan_starttime)}
		cursor_execute("UPDATE accounts SET creation_time = :creation_time, username = :username, passwd_hash = :passwd_hash, email = :email, plan_id = :plan_id, plan_starttime = :plan_starttime, prefs = :prefs WHERE account_id = :account_id", opts)
	def delete(self):
		cursor_execute("DELETE FROM account_events WHERE account_id = :account_id", {'account_id':self.account_id})
		cursor_execute("DELETE FROM auths WHERE account_id = :account_id", {'account_id':self.account_id})
		cursor_execute("DELETE FROM accounts WHERE account_id = :account_id", {'account_id':self.account_id})
class Auth(DBObject):
	def __init__(self, account_id, provider, login_name, info):
		self.account_id = account_id
		self.provider = provider
		self.login_name = login_name
		self.info = info
	def save(self):
		cursor_execute("UPDATE auths SET info = :info WHERE account_id = :account_id AND provider = :provider AND login_name = :login_name",
					   {'info':to_json(self.info), 'login_name':self.login_name, 'provider':self.provider, 'account_id':self.account_id})
class AccountEvent(DBObject):
	def __init__(self, account_id=None, time=None, event=None, value=None):
		self.account_id = account_id
		self.time = Time(time); self.event = event; self.value = value
	def save(self):
		cursor_execute("UPDATE account_events SET event = :event, value = :value WHERE account_id = :account_id AND time = :time",
					   {'account_id':self.account_id, 'time':self.time, 'event':self.event, 'value':to_json(self.value)})
class UUIDValueStore(object):
	def __init__(self, name):
		self._name = name
	def __len__(self):
		return cursor_execute("SELECT COUNT(*) FROM key_value WHERE name = :name", {'name':self._name}).fetchone()[0]
	def __getitem__(self, uuid):
		c = cursor_execute("SELECT value FROM uuid_value WHERE name = :name AND uuid = :uuid LIMIT 1",
						   {'name':self._name, 'uuid':uuid}).fetchone()
		return
	def __setitem__(self, uuid, value):
		if value is None:
			del self[uuid]
		else:
			self.set(uuid, value)
	def set(self, uuid, value, ttl=0):
		cursor_execute("UPDATE uuid_value USING TTL :ttl SET value = :value WHERE name = :name and uuid = :uuid",
					   {'value':to_json(value), 'name':self._name, 'uuid':uuid, 'ttl':ttl})
	def __delitem__(self, uuid):
		cursor_execute("DELETE FROM uuid_value WHERE name = :name AND uuid = :uuid", {'name':self._name, 'uuid':uuid})
	def delete_all(self):
		cursor_execute("DELETE FROM uuid_value WHERE name = :name", {'name':self._name})
class KeyValueStore(object):
	def __init__(self, name):
		self._name = name
	def __len__(self):
		return cursor_execute("SELECT COUNT(*) FROM key_value WHERE name = :name", {'name':self._name}).fetchone()[0]
	def _to_json(self, x):
		return json.dumps(x, separators=(',',':'))
	def __getitem__(self, key):
		c = cursor_execute("SELECT value FROM key_value WHERE name = :name AND key = :key LIMIT 1",
						   {'name':self._name, 'key':to_json(key)}).fetchone()
		return
	def __setitem__(self, key, value):
		if value is None:
			del self[key]
		else:
			self.set(key, value)
	def set(self, key, value, ttl=0):
		cursor_execute("UPDATE key_value USING TTL :ttl SET value = :value WHERE name = :name and key = :key",
					   {'value':to_json(value), 'name':self._name, 'key':to_json(key), 'ttl':ttl})
	def __delitem__(self, key):
		cursor_execute("DELETE FROM key_value WHERE name = :name AND key = :key",
					   {'name':self._name, 'key':to_json(key)})
	def delete_all(self):
		cursor_execute("DELETE FROM key_value WHERE name = :name", {'name':self._name})
class StatelessExec(object):
	def hash(self, input):
		return sha.sha(input).hexdigest()
	def __getitem__(self, input):
		c = cursor_execute("SELECT output FROM stateless_exec WHERE input=:input LIMIT 1",
				 {'input':input}).fetchone()
		if c is not None and len(c) > 0 and c[0] == input:
			return cPickle.loads(str(c[1]))
	def __setitem__(self, input, output):
		cursor_execute("UPDATE stateless_exec SET output = :output WHERE input = :input",
					   {'input':input, 'output':cPickle.dumps(output)})
def running_compute_servers():
	return [host[0] for host in cursor_execute("SELECT host FROM compute_servers WHERE running='true'")]
def record_that_compute_server_started(host):
	cursor().execute("UPDATE compute_servers SET running = 'true', score=0 WHERE host = :host", {'host':host})
def record_that_compute_server_stopped(host):
	cursor().execute("UPDATE compute_servers SET running = 'false', score=0 WHERE host= :host", {'host':host})
def tokens(n):
	RING_SIZE = 2**127
	return [RING_SIZE / n * x for x in range(n)]
def july14_snap_commits_update(keep_server_id, repo_id):
	c = cursor()
	i = 0
	for commit in cursor_execute("SELECT server_id, project_id, timestamp, size FROM snap_commits LIMIT 1000000"):
		print commit
		server_id = commit[0]
		project_id = commit[1]
		timestamp = commit[2]
		print i, server_id, project_id, timestamp
		i += 1
		q = "DELETE FROM snap_commits WHERE server_id=%s AND project_id=%s AND timestamp='%s'"%(server_id, project_id, timestamp)
		print q
		if not c.execute(str(q)):
			print "error"
			break
		print server_id, type(server_id), keep_server_id
		if str(server_id) == keep_server_id:
			q = "UPDATE snap_commits SET repo_id=%s WHERE server_id=%s AND project_id=%s AND timestamp='%s'"%(repo_id, server_id, project_id, timestamp)
			print q
			if not c.execute(str(q)):
				print "error"
				break
def july14_delete_old_snap_commits(cutoff):
	c = cursor()
	i = 0
	for commit in cursor_execute("SELECT server_id, project_id, timestamp, repo_id FROM snap_commits LIMIT 1000000"):
		print commit
		server_id = commit[0]
		project_id = commit[1]
		timestamp = commit[2]
		print i, server_id, project_id, timestamp
		i += 1
		if timestamp < cutoff:
			q = "DELETE FROM snap_commits WHERE server_id=%s AND project_id=%s AND timestamp='%s'"%(server_id, project_id, timestamp)
			print q
			if not c.execute(str(q)):
				print "error"
				break