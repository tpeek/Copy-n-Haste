def option_parser():
	parser = OptionParser()
	parser.add_option("-i", nargs=3, action="append", dest="arguments")
	parser.add_option("-o", dest="output_file")	
	parser.add_option("-p", dest="plugin_path", help="OIIO plugin path")	
	(options, args) = parser.parse_args()
	coordinates = []
	images = []
	for i in options.arguments:
		xy = (int(i[0]), int(i[1]))
		filepath = i[2]
		coordinates.append(xy)
		images.append(filepath)
	plugin_path = options.plugin_path
	if not plugin_path:
		plugin_path = ""
	filename = options.output_file
	return (coordinates, images, plugin_path, filename)
def user_prompt():
	coordinates = []
	images = []
	filepath = raw_input("Enter the path to the image: ")
	while filepath != "":
		if not os.path.exists(filepath):
			return False
		xy = raw_input("Specify position of image inside the stitched image (x y): ")
		xy = (int(xy[0]), int(xy[2]))
		images.append(filepath)
		coordinates.append(xy)
		filepath = raw_input("Enter the path to the image: ")
	return (coordinates, images)
def validate_coordinates(images_info):
	coordinates = images_info[0]
	zipped = zip(*coordinates)
	xmax = max(zipped[0])
	ymax = max(zipped[1])
	for x in range(xmax):
		if list(zipped[0]).count(x) == 0:
			return False
	for y in range(ymax):
		if list(zipped[1]).count(y) == 0:
			return False
	return True
def open_images(filepaths):
	images = []
	for i in filepaths:
		inp = o.ImageInput.create(i, path)
		spec = o.ImageSpec()
		if inp.open(i, spec):
			images.append(inp)
		else:
			return False
	return images
def convert_to_grid(images_data):
	grid = {}
	for i in range(len(images_data[0])):
		grid[images_data[0][i]] = images_data[1][i]
	return grid
def check_row(images):
	spec_0 = images[0].spec()
	row_width = spec_0.width
	for i in images[1:]:
		spec_i = i.spec()
		if spec_i.height != spec_0.height:
			return False
		row_width += spec_i.width
	return row_width
def can_stitch(images_table):
	width = check_row(images_table[0])
	if width:
		for row in images_table[1:]:
			row_width = check_row(row)
			if row_width != width:
				return False
		return True
	else:
		return False
def stitch_row(images):
	arr = array.array("B")
	row_width = check_row(images)
	if row_width:
		spec_0 = images[0].spec()
		for row in range(spec_0.height):
			for i in images:
				spec_i = i.spec()
				arr_i = array.array("B", "\0" * spec_i.scanline_bytes())
				if i.read_scanline(row, 0, spec_i.format, arr_i):
					arr += arr_i
				else:
					return False
		return arr
	else:
		return False
def join_rows(rows):
	arr = array.array("B")
	for i in rows:
		arr += i
	return arr
def check_constraints(images):
	coordinates = images.keys()
	zipped = zip(*coordinates)
	n_columns_max = int(max(zipped[0])) + 1
	n_rows = int(max(zipped[1])) + 1
	height = 0
	for y in range(n_rows):		
		row_height = images[(0,y)].spec().height
		row_width = 0		
		for x in range(n_columns_max):
			if row_height == images[(x,y)].spec().height:
				row_width += images[(x,y)].spec().width
			else:
				return False
			if not images.get((x+1,y)):
				break
		height += row_height
		if y == 0:
			base_width = row_width
		else:
			if base_width != row_width:
				return False
	return (row_width, height)
def stitch_images(images, name):
	xy = check_constraints(images)
	if not xy:
		return False
	coordinates = images.keys()
	zipped = zip(*coordinates)
	n_columns_max = max(zipped[0]) + 1
	n_rows = max(zipped[1]) + 1
	rows = []
	for y in range(n_rows):
		row = []
		for x in range(n_columns_max):
			row.append(images[(x,y)])
			if images.get((x+1,y)) == None:
				break
		stitched_row = stitch_row(row)
		rows.append(stitched_row)
	data = join_rows(rows)
	if data:
		desc = images[(0,0)].spec().format
		spec = o.ImageSpec(xy[0], xy[1], images[(0,0)].spec().nchannels, desc)
		out = o.ImageOutput.create(name, path)
		out.open(name, spec, False)
		out.write_image(desc, data)
		out.close()
	else:
		return False
if __name__ == "__main__":
	if len(sys.argv) > 1:
		parsed = option_parser()
		filename = parsed[3]
		path = parsed[2]
		images_info = (parsed[0], parsed[1])
	else:
		filename = raw_input("Enter the desired name of the final stitched image: ")
		path = raw_input("Enter the path to the oiio plugin dir: ")
		images_info = user_prompt()
	if not validate_coordinates(images_info):
		print "Coordinates not valid"
	else:
		ii_instances = open_images(images_info[1])
		if not ii_instances:
			print "Can't open given images"
		else:
			images_info = (images_info[0], ii_instances)
			grid = convert_to_grid(images_info)
			print "Checking whether the images can be merged..."
			if check_constraints(grid):
				print "Check ok, merging images..."
				stitch_images(grid, filename)
				print "The merging is complete." 
			else:
				print "Can't stitch the images"
def stitch_halves(left, right):
	
	spec_left = o.ImageSpec()
	spec_right = o.ImageSpec()
	
	inp_left = o.ImageInput.create("jpg", "/home/dgaletic/code/oiio-trunk/dist/linux/lib")
	inp_right = o.ImageInput.create("jpg", "/home/dgaletic/code/oiio-trunk/dist/linux/lib")
	inp_left.open(left, spec_left)
	inp_right.open(right, spec_right)
	if spec_right.height == spec_left.height:
		xres = spec_left.width + spec_right.width
		yres = spec_left.height
		desc = spec_left.format
		spec_new = o.ImageSpec(xres, yres, spec_left.nchannels, desc)
		out = o.ImageOutput.create("jpg", "/home/dgaletic/code/oiio-trunk/dist/linux/lib")
		out.open("test-join.jpg", spec_new, False)
		for scanline in range(0, spec_left.height):
			arr_l = array.array("B", "\0" * spec_left.scanline_bytes())
			arr_r = array.array("B", "\0" * spec_right.scanline_bytes())
			arr_new = array.array("B")
			inp_left.read_scanline(scanline, 0, spec_left.format, arr_l)
			inp_right.read_scanline(scanline, 0, spec_right.format, arr_r)
			arr_new = arr_l + arr_r
			out.write_scanline(scanline, 0, spec_new.format, arr_new)
		out.close()
	else:
		print "Heights do not match"
def test_stitch_thirds():		   
	pic_third1 = "/home/dgaletic/code/oiio-testimages/stitch_me/tahoe-0.jpg"
	pic_third2 = "/home/dgaletic/code/oiio-testimages/stitch_me/tahoe-1.jpg"
	pic_third3 = "/home/dgaletic/code/oiio-testimages/stitch_me/tahoe-2.jpg"
	path = "/home/dgaletic/code/oiio-trunk/dist/linux/lib"
	spec1 = o.ImageSpec()
	spec2 = o.ImageSpec()
	spec3 = o.ImageSpec()
	pic1 = o.ImageInput.create("jpg", path)
	pic2 = o.ImageInput.create("jpg", path)
	pic3 = o.ImageInput.create("jpg", path)
	pic1.open(pic_third1, spec1)
	pic2.open(pic_third2, spec2)
	pic3.open(pic_third3, spec3)
	spec_stitched = o.ImageSpec(spec1.width + spec2.width + spec3.width, spec1.height, spec1.nchannels, spec1.format)
	images = [pic1, pic2, pic3]
	arr = stitch_row(images)
	if arr:
		out = o.ImageOutput.create("jpg", path)
		out.open("/home/dgaletic/code/branch/src/python/thirds.jpg", spec_stitched, False)  
		out.write_image(spec_stitched.format, arr)
		out.close()