class Process(ProcessErrors):
	TASKS_PER_DOC = 5
	TASKS_PER_XSL = 2
	TASKS_PER_PUBLISH = 2
	TASKS_IN_PREPARE = 1
	TASKS_IN_EXPORT = 2
	TASKS_IN_GENERATE = 2
	TASKS_IN_PUBLISH = 2
	TASKS_IN_FINISHUP = 1
	settings = None
	xmsf = None
	errorHandler = None
	tempDir = None
	fileAccess = None
	ucb = None
	myTask = None
	exporters = {}
	result = None
	def __init__(self, settings, xmsf, er):
		self.xmsf = xmsf
		self.settings = settings
		self.fileAccess = FileAccess(xmsf)
		self.errorHandler = er
		self.ucb = UCB(xmsf)
		self.taskSteps = self.getTaskSteps()
		self.myTask = Task(TASK, TASK_PREPARE, self.taskSteps)
	def countPublish(self):
		count = 0
		publishers = self.settings.cp_DefaultSession.cp_Publishing
		for e in publishers.childrenList:
			if e.cp_Publish:
				count += 1
		return count
	def getTaskSteps(self):
		docs = self.settings.cp_DefaultSession.cp_Content.cp_Documents.getSize()
		xsl = 0
		try:
			layout = self.settings.cp_DefaultSession.getLayout()
			xsl = len(layout.getTemplates(self.xmsf))
		except Exception:
			traceback.print_exc()
		publish = self.countPublish()
		return \
				self.TASKS_IN_PREPARE + \
				self.TASKS_IN_EXPORT + docs * self.TASKS_PER_DOC + \
				self.TASKS_IN_GENERATE + xsl * self.TASKS_PER_XSL + \
				self.TASKS_IN_PUBLISH + publish * self.TASKS_PER_PUBLISH + \
				self.TASKS_IN_FINISHUP
	def runProcess(self):
		self.myTask.start()
		try:
			try:
				self.result = self.createTempDir(self.myTask) and self.export(self.myTask) and self.generate(self.tempDir, self.myTask) and self.publish(self.tempDir, self.myTask)
			finally:
				self.result = self.result and self.cleanup(self.myTask)
		except Exception:
			traceback.print_exc()
			self.result = False
		if not self.result:
			self.myTask.fail()
		while (self.myTask.getStatus() < self.myTask.getMax()):
			self.myTask.advance(True)
	def createTempDir(self, task):
		try:
			self.tempDir = self.fileAccess.createNewDir(self.getSOTempDir(self.xmsf), "/wwiztemp")
		except Exception:
			traceback.print_exc()
		if self.tempDir is None:
			self.error(None, None, ProcessErrors.ERROR_MKDIR, ErrorHandler.ERROR_PROCESS_FATAL)
			return False
		else:
			task.advance(True)
			return True
	def getSOTempDir(self, xmsf):
		try:
			return FileAccess.getOfficePath(self.xmsf, "Temp", "")
		except Exception:
			traceback.print_exc()
		return None
	def cleanup(self, task):
		task.setSubtaskName(TASK_FINISH)
		b = self.fileAccess.delete(self.tempDir)
		if not b:
			self.error(None, None, ProcessErrors.ERROR_CLEANUP, ErrorHandler.ERROR_WARNING)
		task.advance(b)
		return b
	def copyMedia(self, copy, settings, targetDir, task):
		sourceDir = FileAccess.connectURLs(settings.workPath, "styles")
		filename = settings.cp_DefaultSession.getStyle().cp_CssHref
		copy.copy2(sourceDir, filename, targetDir, "style.css")
		task.advance(True)
		background = settings.cp_DefaultSession.cp_Design.cp_BackgroundImage
		if (background is not None and background is not ""):
			sourceDir = FileAccess.getParentDir(background)
			filename = background[len(sourceDir):]
			copy.copy2(sourceDir, filename, targetDir + "/images", "background.gif")
		task.advance(True)
	@classmethod
	def copyStaticImages(self, copy, settings, targetDir):
		source = FileAccess.connectURLs(settings.workPath, "images")
		target = targetDir + "/images"
		copy.copy(source, target)
	def publish(self, folder, task):
		task.setSubtaskName(TASK_PUBLISH_PREPARE)
		configSet = self.settings.cp_DefaultSession.cp_Publishing
		try:
			self.copyMedia(self.ucb, self.settings, folder, task)
			self.copyStaticImages(self.ucb, self.settings, folder)
			task.advance(True)
		except Exception as ex:
			traceback.print_exc()
			self.error(ex, "", ProcessErrors.ERROR_PUBLISH_MEDIA, ErrorHandler.ERROR_PROCESS_FATAL)
			return False
		for p in configSet.childrenList:
			if p.cp_Publish:
				key = configSet.getKey(p)
				task.setSubtaskName(key)
				if key is ZIP_PUBLISHER:
					self.fileAccess.delete(p.cp_URL)
				if (not self.publish1(folder, p, self.ucb, task)):
					return False
		return True
	def publish1(self, folder, publish, copy, task):
		try:
			task.advance(True)
			url = publish.url
			copy.copy(folder, url)
			task.advance(True)
			return True
		except Exception as e:
			task.advance(False)
			traceback.print_exc()
			return self.error(e, publish, ProcessErrors.ERROR_PUBLISH, ErrorHandler.ERROR_NORMAL_IGNORE)
	def generate(self, targetDir, task):
		result = False
		task.setSubtaskName(TASK_GENERATE_PREPARE)
		layout = self.settings.cp_DefaultSession.getLayout()
		try:
			doc = self.settings.cp_DefaultSession.createDOM1()
			self.generate1(self.xmsf, layout, doc, self.fileAccess, targetDir, task)
		except Exception as ex:
			traceback.print_exc()
			self.error(ex, "", ProcessErrors.ERROR_GENERATE_XSLT, ErrorHandler.ERROR_PROCESS_FATAL)
			return False
		try:
			task.setSubtaskName(TASK_GENERATE_COPY)
			self.copyLayoutFiles(self.ucb, self.fileAccess, self.settings, layout, targetDir)
			task.advance(True)
			result = True
		except Exception as ex:
			task.advance(False)
			traceback.print_exc()
			return self.error(ex, None, ProcessErrors.ERROR_GENERATE_COPY, ErrorHandler.ERROR_NORMAL_ABORT)
		return result
	@classmethod
	def copyLayoutFiles(self, ucb, fileAccess, settings, layout, targetDir):
		filesPath = fileAccess.getURL(FileAccess.connectURLs(settings.workPath, "layouts/"), layout.cp_FSName)
		ucb.copy1(filesPath, targetDir, ExtensionVerifier("xsl"))
	@classmethod
	def generate1(self, xmsf, layout, doc, fileAccess, targetPath, task):
		templates = layout.getTemplates(xmsf)
		self.node = doc
		task.advance1(True, TASK_GENERATE_XSL)
		for key in templates:
			temp = templates[key]
			fn = fileAccess.getPath(targetPath, key[:len(key) - 4])
			args = list(range(1))
			nv = NamedValue()
			nv.Name = "StylesheetURL"
			nv.Value = temp
			args[0] = nv
			arguments = list(range(1))
			arguments[0] = tuple(args)
			self.tf = Process.createTransformer(xmsf, arguments)
			self.node.normalize()
			task.advance(True)
			self.tf.addListener(StreamListenerProcAdapter(self,
														  self.streamTerminatedHandler,
														  self.streamStartedHandler,
														  self.streamClosedHandler,
														  self.streamErrorHandler))
			pipeout = xmsf.createInstance("com.sun.star.io.Pipe")
			pipein = pipeout
			self.xSaxWriter = xmsf.createInstance( "com.sun.star.xml.sax.Writer" )
			self.xSaxWriter.setOutputStream(pipeout)
			self.tf.setInputStream(pipein)
			xOutputStream = fileAccess.xInterface.openFileWrite(fn)
			self.tf.setOutputStream(xOutputStream)
			self.tf.start()
			while (not self.tfCompleted):
				pass
			self.tf.terminate()
			task.advance(True)
	@classmethod
	def createTransformer(self, xmsf, args):
		tf = xmsf.createInstanceWithArguments("com.sun.star.xml.xslt.XSLT2Transformer",
											  tuple(args))
		if (tf is None):
			tf = xmsf.createInstanceWithArguments("com.sun.star.xml.xslt.XSLTTransformer",
												  tuple(args))
		return tf
	def streamTerminatedHandler(self):
		parent.isTerminated = True
	def streamStartedHandler(self, parent):
		parent.tfCompleted = False
		parent.node.serialize(parent.xSaxWriter, tuple([StringPair()]))
	def streamErrorHandler(self, aException):
		print ("DEBUG !!! Stream 'error' event handler")
	def streamClosedHandler(self, parent):
		parent.tfCompleted = True
	def export(self, task):
		return self.export1(self.settings.cp_DefaultSession.cp_Content, self.tempDir, task)
	def export1(self, content, folder, task):
		toPerform = 1
		contentDir = None
		try:
			task.setSubtaskName(TASK_EXPORT_PREPARE)
			contentDir = self.fileAccess.createNewDir(folder, content.cp_Name);
			if (contentDir is None or contentDir is ""):
				raise IOException("Directory " + folder + " could not be created.")
			content.dirName = FileAccess.getFilename(contentDir)
			task.advance1(True, TASK_EXPORT_DOCUMENTS)
			toPerform -= 1
			for item in content.cp_Documents.childrenList:
				try:
					if (isinstance (item, CGDocument)):
						if (not self.export2(item, contentDir, task)):
							return False
					elif (not self.export2(item, contentDir, task)):
						return False
				except SecurityException as sx:
					traceback.print_exc()
					if (not self.error(sx, item, ProcessErrors.ERROR_EXPORT_SECURITY, ErrorHandler.ERROR_NORMAL_IGNORE)):
						return False
					self.result = False
		except IOException as iox:
			traceback.print_exc()
			return self.error(iox, content, ProcessErrors.ERROR_EXPORT_IO, ErrorHandler.ERROR_NORMAL_IGNORE)
		except SecurityException as se:
			traceback.print_exc()
			return self.error(se, content, ProcessErrors.ERROR_EXPORT_SECURITY, ErrorHandler.ERROR_NORMAL_IGNORE)
		self.failTask(task, toPerform)
		return True
	def export2(self, doc, folder, task):
		if (not doc.valid):
			try:
				doc.validate(self.xmsf, task)
			except Exception as ex:
				traceback.print_exc()
				self.error(ex, doc, ProcessErrors.ERROR_DOC_VALIDATE, ErrorHandler.ERROR_PROCESS_FATAL)
				return False
		exp = doc.cp_Exporter
		exporter = self.settings.cp_Exporters.getElement(exp)
		try:
			docFilename = FileAccess.getFilename(doc.cp_URL)
			docExt = FileAccess.getExtension(docFilename)
			fn = doc.localFilename[:len(doc.localFilename) - len(docExt) - 1]
			destExt = FileAccess.getExtension(docFilename) \
				if (exporter.cp_Extension is "") \
				else exporter.cp_Extension
			if (exporter.cp_OwnDirectory):
				folder = self.fileAccess.createNewDir(folder, fn)
				doc.dirName = FileAccess.getFilename(folder)
			f = self.fileAccess.getNewFile(folder, fn, destExt)
			doc.urlFilename = FileAccess.getFilename(f)
			task.advance(True)
			try:
				self.getExporter(exporter).export(doc, f, self.xmsf, task)
				task.advance(True)
			except Exception as ex:
				traceback.print_exc()
				if (not self.error(ex, doc, ProcessErrors.ERROR_EXPORT, ErrorHandler.ERROR_NORMAL_IGNORE)):
					return False
		except Exception as ex:
			traceback.print_exc()
			if (not self.error(ex, doc, ProcessErrors.ERROR_EXPORT_MKDIR, ErrorHandler.ERROR_NORMAL_ABORT)):
				return False
		return True
	def error(self, ex, arg1, arg2, errType):
		self.result = False
		return self.errorHandler.error(ex, arg1, arg2, errType)
	def failTask(self, task, count):
		while (count > 0):
			task.advance(False)
			count -= 1
	def createExporter(self, export):
		pkgname = ".".join(export.cp_ExporterClass.split(".")[3:])
		className = export.cp_ExporterClass.split(".")[-1]
		mod =
		return getattr(mod, className)(export)
	def getExporter(self, export):
		exp = self.exporters.get(export.cp_Name)
		if (exp is None):
			exp = self.createExporter(export)
			self.exporters[export.cp_Name] = exp
		return exp
	def getResult(self):
		return (self.myTask.getFailed() == 0) and self.result