localeNames = {'fr': 'French', 'hu': 'Hungarian', 'de': 'German'}
def getLocaleName (code):
	global localeNames
	if code in localeNames:
		return localeNames[code]
	else:
		return "(unknown locale)"
def getAscii (ords):
	ascii = ''
	for c in ords:
		ascii += chr(c)
	return ascii
class LocaleData(object):
	def __init__ (self, locale):
		self.locale = locale
		self.funcList = {}
	def addKeywordMap (self, funcName, localeName, engName):
		if not funcName in self.funcList:
			self.funcList[funcName] = []
		self.funcList[funcName].append([localeName, engName])
	def getLocaleFuncVarName (self, func, pair):
		return func.lower() + "_" + getAscii(pair[1]).lower() + "_" + self.locale
	def dumpCode (self):
		chars = ""
		chars += "// " + "-"*75 + "\n"
		chars += "// %s language locale (automatically generated)\n"%getLocaleName(self.locale)
		chars += "// " + "-"*75 + "\n"
		chars += "static const Locale a" + self.locale.capitalize() + "(OUString(\""
		chars += self.locale
		chars += "\"), OUString(), OUString());\n\n"
		funcs = sorted(self.funcList.keys())
		chars += "// pre instantiations of localized function names\n"
		for func in funcs:
			for item in self.funcList[func]:
				chars += "static const sal_Unicode " + self.getLocaleFuncVarName(func, item) + "[] = {\n"
				chars += "	"
				isFirst = True
				for uval in item[0]:
					if isFirst:
						isFirst = False
					else:
						chars += ", "
					chars += "0x%.4X"%uval
				if not isFirst:
					chars += ", "
				chars += "0x0000"
				chars += "};\n"
		chars += "\n"
		chars += "static const TransItem p" + self.locale.capitalize() + "[] = {\n"
		for func in funcs:
			for item in self.funcList[func]:
				chars += "	"
				chars += "{%s, \"%s\", %s},\n"%(self.getLocaleFuncVarName(func, item),
												getAscii(item[1]),
												"oc"+func.capitalize())
		chars += "	{NULL, NULL, ocNone}\n"
		chars += "};\n\n"
		chars += "addToMap(%s, %s);\n"%(
			"p"+self.locale.capitalize(), "a"+self.locale.capitalize())
		return chars
class Parser(object):
	def __init__ (self, args):
		self.infile = "./keywords_utf16.txt"
		self.outfile = "../../source/core/tool/cellkeywords.inl"
		if len(args) >= 2:
			self.infile = args[1]
		if len(args) >= 3:
			self.outfile = args[2]
	def getDByte (self):
		bh = self.bytes[self.i]
		bl = self.bytes[self.i+1]
		try:
			dbyte = ord(bl)*256 + ord(bh)
		except:
			dbyte = bl*256 + bh
		self.i += 2
		return dbyte
	def parseLine (self):
		buf = []
		while self.i < self.size:
			dbyte = self.getDByte()
			if dbyte == 0x000A:
				break
			buf.append(dbyte)
		return buf
	def dumpBuf (self, buf, linefeed=True):
		for item in buf:
			sys.stdout.write(chr(item))
		if linefeed:
			print ('')
	def parse (self):
		file = open(self.infile, 'rb')
		self.bytes = file.read()
		file.close()
		self.size = len(self.bytes)
		self.i = 0
		localeList = []
		funcName = None
		word = []
		wordPair = []
		while self.i < self.size:
			dbyte = self.getDByte()
			if dbyte == 0xFEFF and self.i == 2:
				pass
			elif dbyte == 0x0024:
				buf = self.parseLine()
				locale = getAscii(buf)
				localeList.append(LocaleData(locale))
			elif dbyte == 0x0040:
				buf = self.parseLine()
				funcName = getAscii(buf)
			elif dbyte == 0x002C:
				if len(word) > 0:
					wordPair.append(word)
					word = []
			elif dbyte == 0x000A:
				if len(word) > 0:
					wordPair.append(word)
					word = []
				if len(wordPair) >= 2:
					localeList[-1].addKeywordMap(funcName, wordPair[0], wordPair[1])
				wordPair = []
			elif dbyte in [0x0009, 0x0020]:
				pass
			else:
				word.append(dbyte)
		chars = "// This file has been automatically generated.  Do not hand-edit this!\n"
		for obj in localeList:
			chars += "\n" + obj.dumpCode()
		file = open(self.outfile, 'w')
		file.write(chars)
		file.close()
if __name__=='__main__':
	parser = Parser(sys.argv)
	parser.parse()