def decompose_graph(g):
	decomposed = []
	p = com.best_partition(g)
	partition_labels = np.unique(p.values())
	for pi in partition_labels:
		gi = g.copy()
		to_remove = [n for n in g.nodes_iter() if p[n] != pi]
		gi.remove_nodes_
		decomposed.append(gi)
	return decomposed
def print_info(g):
	print 'Graph composed of {0} nodes and {1} edges'.format(g.order(), g.size())
def write_mcl(communities, path):
	with open(path, 'w') as hout:
		keys = sorted(communities.keys())
		for k in keys:
			line = ' '.join(sorted(communities[k].keys()))
			hout.write(line.strip())
			hout.write('\n')
def plot_graph(part, g):
	color_list = Paired_12.mpl_colors + Set3_12.mpl_colors
	ncol = len(color_list)
	layouts = [nx.graphviz_layout, nx.spring_layout]
	for i in xrange(2):
		pos = layouts[i](g)
		plt.subplot(121 + i)
		for n, com in enumerate(set(part.values())):
			list_nodes = [nodes for nodes in part.keys() if part[nodes] == com]
			nx.draw_networkx_nodes(g, pos, list_nodes, node_size=30, node_color=color_list[n % ncol], alpha=1.0)
		nx.draw_networkx_edges(g, pos, alpha=0.5)
	plt.show()
if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Decompose a graph into its communities')
	parser.add_argument('--no-isolates', action='store_true', default=False, help='Remove isolated nodes')
	parser.add_argument('--otype', choices=['hard', 'soft', 'induced'], default='soft', help='Output type')
	parser.add_argument('input', nargs=1, help='Input graph (graphml format)')
	parser.add_argument('output', nargs=1, help='Output file')
	args = parser.parse_args()
	g = nx.read_graphml(args.input[0])
	print 'Initial statistics'
	print_info(g)
	if args.no_isolates:
		singletons = [n for n, degree in g.degree().items() if degree < 1]
		print 'Removed {0} isolated nodes
		g.remove_nodes_
		print_info(g)
	subgraphs = list(nx.connected_component_subgraphs(g))
	print 'The graph comprises {0} connected components'.format(len(subgraphs))
	print 'Components with more than one node:'
	for n, sg in enumerate(subgraphs, start=1):
		if sg.order() > 1:
			print '\tcomponent {0}: {1} nodes {2} edges'.format(n, sg.order(), sg.size())
	partitions = com.best_partition(g)
	com_ids = set(partitions.values())
	print 'There were {0} communities'.format(len(com_ids))
	print 'Communities with more than one node:'
	communities = {}
	for ci in com_ids:
		communities[ci] = dict((n, 1.0) for n, cj in partitions.iteritems() if cj == ci)
		if len(communities[ci]) > 1:
			print '\tcommunity {0}: {1} nodes'.format(ci, len(communities[ci]))
	if args.otype == 'hard':
		write_mcl(communities, args.output[0])
	elif args.otype == 'induced':
		induced = com.induced_graph(partitions, g)
		sub_ind = nx.connected_component_subgraphs(induced)
		groups = {}
		n = 1
		for sg in sub_ind:
			if sg.size() <= 2:
				continue
			cut, parts = nx.stoer_wagner(sg)
			for p in parts:
				if n not in groups:
					groups[n] = {}
				for pi in p:
						dt = dict((nid, 1.0) for nid, cj in partitions.iteritems() if cj == pi)
						groups[n].update(dt)
				n += 1
		write_mcl(groups, args.output[0])
	elif args.otype == 'soft':
		for n1 in g.nodes_iter():
			for n2 in nx.all_neighbors(g, n1):
				if partitions[n1] != partitions[n2]:
					communities[partitions[n1]][n2] = 0.5
					communities[partitions[n2]][n1] = 0.5
		write_mcl(communities, args.output[0])
	else:
		raise RuntimeError('Unsupported output type')