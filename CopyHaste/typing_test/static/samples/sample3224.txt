MINIMUM_GROUP_ID = 100
RANDOM_SCHEME = "random"
COHORT_SCHEME = "cohort"
CONTENT_GROUP_CONFIGURATION_DESCRIPTION = 'The groups in this configuration can be mapped to cohort groups in the LMS.'
CONTENT_GROUP_CONFIGURATION_NAME = 'Content Group Configuration'
log = logging.getLogger(__name__)
class GroupConfigurationsValidationError(Exception):
	pass
class GroupConfiguration(object):
	def __init__(self, json_string, course, configuration_id=None):
		self.configuration = GroupConfiguration.parse(json_string)
		self.course = course
		self.assign_id(configuration_id)
		self.assign_group_ids()
		self.validate()
	@staticmethod
	def parse(json_string):
		try:
			configuration = json.loads(json_string)
		except ValueError:
			raise GroupConfigurationsValidationError(_("invalid JSON"))
		configuration["version"] = UserPartition.VERSION
		return configuration
	def validate(self):
		if not self.configuration.get("name"):
			raise GroupConfigurationsValidationError(_("must have name of the configuration"))
		if len(self.configuration.get('groups', [])) < 1:
			raise GroupConfigurationsValidationError(_("must have at least one group"))
	def assign_id(self, configuration_id=None):
		if configuration_id:
			self.configuration['id'] = int(configuration_id)
		else:
			self.configuration['id'] = generate_int_id(
				MINIMUM_GROUP_ID, MYSQL_MAX_INT, GroupConfiguration.get_used_ids(self.course)
			)
	def assign_group_ids(self):
		used_ids = [g.id for p in self.course.user_partitions for g in p.groups]
		for group in self.configuration.get('groups', []):
			if group.get('id') is None:
				group["id"] = generate_int_id(MINIMUM_GROUP_ID, MYSQL_MAX_INT, used_ids)
				used_ids.append(group["id"])
	@staticmethod
	def get_used_ids(course):
		return set([p.id for p in course.user_partitions])
	def get_user_partition(self):
		return UserPartition.
	@staticmethod
	def _get_usage_info(course, unit, item, usage_info, group_id, scheme_name=None):
		unit_url = reverse_usage_url(
			'container_handler',
			course.location.course_key.make_usage_key(unit.location.block_type, unit.location.name)
		)
		usage_dict = {'label': u"{} / {}".format(unit.display_name, item.display_name), 'url': unit_url}
		if scheme_name == RANDOM_SCHEME:
			validation_summary = item.general_validation_message()
			usage_dict.update({'validation': validation_summary.to_json() if validation_summary else None})
		usage_info[group_id].append(usage_dict)
		return usage_info
	@staticmethod
	def get_content_experiment_usage_info(store, course):
		split_tests = store.get_items(course.id, qualifiers={'category': 'split_test'})
		return GroupConfiguration._get_content_experiment_usage_info(store, course, split_tests)
	@staticmethod
	def get_split_test_partitions_with_usage(store, course):
		usage_info = GroupConfiguration.get_content_experiment_usage_info(store, course)
		configurations = []
		for partition in get_split_user_partitions(course.user_partitions):
			configuration = partition.to_json()
			configuration['usage'] = usage_info.get(partition.id, [])
			configurations.append(configuration)
		return configurations
	@staticmethod
	def _get_content_experiment_usage_info(store, course, split_tests):
		usage_info = {}
		for split_test in split_tests:
			if split_test.user_partition_id not in usage_info:
				usage_info[split_test.user_partition_id] = []
			unit = split_test.get_parent()
			if not unit:
				log.warning("Unable to find parent for split_test %s", split_test.location)
				continue
			usage_info = GroupConfiguration._get_usage_info(
				course=course,
				unit=unit,
				item=split_test,
				usage_info=usage_info,
				group_id=split_test.user_partition_id,
				scheme_name=RANDOM_SCHEME
			)
		return usage_info
	@staticmethod
	def get_content_groups_usage_info(store, course):
		items = store.get_items(course.id, settings={'group_access': {'$exists': True}})
		return GroupConfiguration._get_content_groups_usage_info(course, items)
	@staticmethod
	def _get_content_groups_usage_info(course, items):
		usage_info = {}
		for item in items:
			if hasattr(item, 'group_access') and item.group_access:
				(__, group_ids), = item.group_access.items()
				for group_id in group_ids:
					if group_id not in usage_info:
						usage_info[group_id] = []
					unit = item.get_parent()
					if not unit:
						log.warning("Unable to find parent for component %s", item.location)
						continue
					usage_info = GroupConfiguration._get_usage_info(
						course,
						unit=unit,
						item=item,
						usage_info=usage_info,
						group_id=group_id
					)
		return usage_info
	@staticmethod
	def get_content_groups_items_usage_info(store, course):
		items = store.get_items(course.id, settings={'group_access': {'$exists': True}})
		return GroupConfiguration._get_content_groups_items_usage_info(course, items)
	@staticmethod
	def _get_content_groups_items_usage_info(course, items):
		usage_info = {}
		for item in items:
			if hasattr(item, 'group_access') and item.group_access:
				(__, group_ids), = item.group_access.items()
				for group_id in group_ids:
					if group_id not in usage_info:
						usage_info[group_id] = []
					usage_info = GroupConfiguration._get_usage_info(
						course,
						unit=item,
						item=item,
						usage_info=usage_info,
						group_id=group_id
					)
		return usage_info
	@staticmethod
	def update_usage_info(store, course, configuration):
		configuration_json = None
		if configuration.scheme.name == RANDOM_SCHEME:
			split_tests = store.get_items(
				course.id,
				category='split_test',
				content={'user_partition_id': configuration.id}
			)
			configuration_json = configuration.to_json()
			usage_information = GroupConfiguration._get_content_experiment_usage_info(store, course, split_tests)
			configuration_json['usage'] = usage_information.get(configuration.id, [])
		elif configuration.scheme.name == COHORT_SCHEME:
			configuration_json = GroupConfiguration.update_content_group_usage_info(store, course, configuration)
		return configuration_json
	@staticmethod
	def update_content_group_usage_info(store, course, configuration):
		usage_info = GroupConfiguration.get_content_groups_usage_info(store, course)
		content_group_configuration = configuration.to_json()
		for group in content_group_configuration['groups']:
			group['usage'] = usage_info.get(group['id'], [])
		return content_group_configuration
	@staticmethod
	def get_or_create_content_group(store, course):
		content_group_configuration = get_cohorted_user_partition(course.id)
		if content_group_configuration is None:
			content_group_configuration = UserPartition(
				id=generate_int_id(MINIMUM_GROUP_ID, MYSQL_MAX_INT, GroupConfiguration.get_used_ids(course)),
				name=CONTENT_GROUP_CONFIGURATION_NAME,
				description=CONTENT_GROUP_CONFIGURATION_DESCRIPTION,
				groups=[],
				scheme_id=COHORT_SCHEME
			)
			return content_group_configuration.to_json()
		content_group_configuration = GroupConfiguration.update_content_group_usage_info(
			store,
			course,
			content_group_configuration
		)
		return content_group_configuration