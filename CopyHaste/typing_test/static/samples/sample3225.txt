log = logging.getLogger(__name__)
def get_course_updates(location, provided_id, user_id):
	try:
		course_updates = modulestore().get_item(location)
	except ItemNotFoundError:
		course_updates = modulestore().create_item(user_id, location.course_key, location.block_type, location.block_id)
	course_update_items = get_course_update_items(course_updates, _get_index(provided_id))
	return _get_visible_update(course_update_items)
def update_course_updates(location, update, passed_id=None, user=None):
	try:
		course_updates = modulestore().get_item(location)
	except ItemNotFoundError:
		course_updates = modulestore().create_item(user.id, location.course_key, location.block_type, location.block_id)
	course_update_items = list(reversed(get_course_update_items(course_updates)))
	if passed_id is not None:
		passed_index = _get_index(passed_id)
		if 0 < passed_index <= len(course_update_items):
			course_update_dict = course_update_items[passed_index - 1]
			course_update_dict["date"] = update["date"]
			course_update_dict["content"] = update["content"]
			course_update_items[passed_index - 1] = course_update_dict
		else:
			return HttpResponseBadRequest(_("Invalid course update id."))
	else:
		course_update_dict = {
			"id": len(course_update_items) + 1,
			"date": update["date"],
			"content": update["content"],
			"status": CourseInfoModule.STATUS_VISIBLE
		}
		course_update_items.append(course_update_dict)
		enqueue_push_course_update(update, location.course_key)
	save_course_update_items(location, course_updates, course_update_items, user)
	if "status" in course_update_dict:
		del course_update_dict["status"]
	return course_update_dict
def _make_update_dict(update):
	return {
		"id": update["id"],
		"date": update["date"],
		"content": update["content"],
	}
def _get_visible_update(course_update_items):
	if isinstance(course_update_items, dict):
		if course_update_items.get("status") != CourseInfoModule.STATUS_DELETED:
			return _make_update_dict(course_update_items)
		else:
			return {"error": _("Course update not found."), "status": 404}
	return ([_make_update_dict(update) for update in course_update_items
			 if update.get("status") != CourseInfoModule.STATUS_DELETED])
def delete_course_update(location, update, passed_id, user):
	if not passed_id:
		return HttpResponseBadRequest()
	try:
		course_updates = modulestore().get_item(location)
	except ItemNotFoundError:
		return HttpResponseBadRequest()
	course_update_items = list(reversed(get_course_update_items(course_updates)))
	passed_index = _get_index(passed_id)
	if 0 < passed_index <= len(course_update_items):
		course_update_item = course_update_items[passed_index - 1]
		course_update_item["status"] = CourseInfoModule.STATUS_DELETED
		course_update_items[passed_index - 1] = course_update_item
		save_course_update_items(location, course_updates, course_update_items, user)
		return _get_visible_update(course_update_items)
	else:
		return HttpResponseBadRequest(_("Invalid course update id."))
def _get_index(passed_id=None):
	if passed_id:
		index_matcher = re.search(r'.*?/?(\d+)$', passed_id)
		if index_matcher:
			return int(index_matcher.group(1))
	return 0
def _get_html(course_updates_items):
	list_items = []
	for update in reversed(course_updates_items):
		if update.get("status") != CourseInfoModule.STATUS_DELETED:
			list_items.append(u"<article><h2>{date}</h2>{content}</article>".format(**update))
	return u"<section>{list_items}</section>".format(list_items="".join(list_items))
def save_course_update_items(location, course_updates, course_update_items, user=None):
	course_updates.items = course_update_items
	course_updates.data = _get_html(course_update_items)
	modulestore().update_item(course_updates, user.id)
	return course_updates