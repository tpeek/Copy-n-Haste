REINDEX_AGE = timedelta(0, 60)
log = logging.getLogger('edx.modulestore')
def strip_html_content_to_text(html_content):
	text_content = re.sub(r"(\s|&nbsp;|//)+", " ", html_to_text(html_content))
	text_content = re.sub(r"<!\[CDATA\[.*\]\]>", "", text_content)
	text_content = re.sub(r"<!--.*-->", "", text_content)
	return text_content
def indexing_is_enabled():
	return settings.FEATURES.get('ENABLE_COURSEWARE_INDEX', False)
class SearchIndexingError(Exception):
	def __init__(self, message, error_list):
		super(SearchIndexingError, self).__init__(message)
		self.error_list = error_list
@add_metaclass(ABCMeta)
class SearchIndexerBase(object):
	__metaclass__ = ABCMeta
	INDEX_NAME = None
	DOCUMENT_TYPE = None
	ENABLE_INDEXING_KEY = None
	INDEX_EVENT = {
		'name': None,
		'category': None
	}
	@classmethod
	def indexing_is_enabled(cls):
		return settings.FEATURES.get(cls.ENABLE_INDEXING_KEY, False)
	@classmethod
	@abstractmethod
	def normalize_structure_key(cls, structure_key):
	@classmethod
	@abstractmethod
	def _fetch_top_level(cls, modulestore, structure_key):
	@classmethod
	@abstractmethod
	def _get_location_info(cls, normalized_structure_key):
	@classmethod
	def _id_modifier(cls, usage_id):
		return usage_id
	@classmethod
	def remove_deleted_items(cls, searcher, structure_key, exclude_items):
		response = searcher.search(
			doc_type=cls.DOCUMENT_TYPE,
			field_dictionary=cls._get_location_info(structure_key),
			exclude_dictionary={"id": list(exclude_items)}
		)
		result_ids = [result["data"]["id"] for result in response["results"]]
		searcher.remove(cls.DOCUMENT_TYPE, result_ids)
	@classmethod
	def index(cls, modulestore, structure_key, triggered_at=None, reindex_age=REINDEX_AGE):
		error_list = []
		searcher = SearchEngine.get_search_engine(cls.INDEX_NAME)
		if not searcher:
			return
		structure_key = cls.normalize_structure_key(structure_key)
		location_info = cls._get_location_info(structure_key)
		indexed_count = {
			"count": 0
		}
		indexed_items = set()
		items_index = []
		def get_item_location(item):
			return item.location.version_agnostic().replace(branch=None)
		def prepare_item_index(item, skip_index=False, groups_usage_info=None):
			is_indexable = hasattr(item, "index_dictionary")
			item_index_dictionary = item.index_dictionary() if is_indexable else None
			if not item_index_dictionary and not item.has_children:
				return
			item_content_groups = None
			if item.category == "split_test":
				split_partition = item.get_selected_partition()
				for split_test_child in item.get_children():
					if split_partition:
						for group in split_partition.groups:
							group_id = unicode(group.id)
							child_location = item.group_id_to_child.get(group_id, None)
							if child_location == split_test_child.location:
								groups_usage_info.update({
									unicode(get_item_location(split_test_child)): [group_id],
								})
								for component in split_test_child.get_children():
									groups_usage_info.update({
										unicode(get_item_location(component)): [group_id]
									})
			if groups_usage_info:
				item_location = get_item_location(item)
				item_content_groups = groups_usage_info.get(unicode(item_location), None)
			item_id = unicode(cls._id_modifier(item.scope_ids.usage_id))
			indexed_items.add(item_id)
			if item.has_children:
				skip_child_index = skip_index or \
					(triggered_at is not None and (triggered_at - item.subtree_edited_on) > reindex_age)
				children_groups_usage = []
				for child_item in item.get_children():
					if modulestore.has_published_version(child_item):
						children_groups_usage.append(
							prepare_item_index(
								child_item,
								skip_index=skip_child_index,
								groups_usage_info=groups_usage_info
							)
						)
				if None in children_groups_usage:
					item_content_groups = None
			if skip_index or not item_index_dictionary:
				return
			item_index = {}
			try:
				item_index.update(location_info)
				item_index.update(item_index_dictionary)
				item_index['id'] = item_id
				if item.start:
					item_index['start_date'] = item.start
				item_index['content_groups'] = item_content_groups if item_content_groups else None
				item_index.update(cls.supplemental_fields(item))
				items_index.append(item_index)
				indexed_count["count"] += 1
				return item_content_groups
			except Exception as err:
				log.warning('Could not index item: %s - %r', item.location, err)
				error_list.append(_('Could not index item: {}').format(item.location))
		try:
			with modulestore.branch_setting(ModuleStoreEnum.RevisionOption.published_only):
				structure = cls._fetch_top_level(modulestore, structure_key)
				groups_usage_info = cls.fetch_group_usage(modulestore, structure)
				cls.supplemental_index_information(modulestore, structure)
				for item in structure.get_children():
					prepare_item_index(item, groups_usage_info=groups_usage_info)
				searcher.index(cls.DOCUMENT_TYPE, items_index)
				cls.remove_deleted_items(searcher, structure_key, indexed_items)
		except Exception as err:
			log.exception(
				"Indexing error encountered, courseware index may be out of date %s - %r",
				structure_key,
				err
			)
			error_list.append(_('General indexing error occurred'))
		if error_list:
			raise SearchIndexingError('Error(s) present during indexing', error_list)
		return indexed_count["count"]
	@classmethod
	def _do_reindex(cls, modulestore, structure_key):
		indexed_count = cls.index(modulestore, structure_key)
		if indexed_count:
			cls._track_index_request(cls.INDEX_EVENT['name'], cls.INDEX_EVENT['category'], indexed_count)
		return indexed_count
	@classmethod
	def _track_index_request(cls, event_name, category, indexed_count):
		data = {
			"indexed_count": indexed_count,
			'category': category,
		}
		tracker.emit(
			event_name,
			data
		)
	@classmethod
	def fetch_group_usage(cls, modulestore, structure):
		return None
	@classmethod
	def supplemental_index_information(cls, modulestore, structure):
		pass
	@classmethod
	def supplemental_fields(cls, item):
		return {}
class CoursewareSearchIndexer(SearchIndexerBase):
	INDEX_NAME = "courseware_index"
	DOCUMENT_TYPE = "courseware_content"
	ENABLE_INDEXING_KEY = 'ENABLE_COURSEWARE_INDEX'
	INDEX_EVENT = {
		'name': 'edx.course.index.reindexed',
		'category': 'courseware_index'
	}
	UNNAMED_MODULE_NAME = _("(Unnamed)")
	@classmethod
	def normalize_structure_key(cls, structure_key):
		return structure_key
	@classmethod
	def _fetch_top_level(cls, modulestore, structure_key):
		return modulestore.get_course(structure_key, depth=None)
	@classmethod
	def _get_location_info(cls, normalized_structure_key):
		return {"course": unicode(normalized_structure_key), "org": normalized_structure_key.org}
	@classmethod
	def do_course_reindex(cls, modulestore, course_key):
		return cls._do_reindex(modulestore, course_key)
	@classmethod
	def fetch_group_usage(cls, modulestore, structure):
		groups_usage_dict = {}
		groups_usage_info = GroupConfiguration.get_content_groups_usage_info(modulestore, structure).items()
		groups_usage_info.extend(
			GroupConfiguration.get_content_groups_items_usage_info(
				modulestore,
				structure
			).items()
		)
		if groups_usage_info:
			for name, group in groups_usage_info:
				for module in group:
					view, args, kwargs = resolve(module['url'])
					usage_key_string = unicode(kwargs['usage_key_string'])
					if groups_usage_dict.get(usage_key_string, None):
						groups_usage_dict[usage_key_string].append(name)
					else:
						groups_usage_dict[usage_key_string] = [name]
		return groups_usage_dict
	@classmethod
	def supplemental_index_information(cls, modulestore, structure):
		CourseAboutSearchIndexer.index_about_information(modulestore, structure)
	@classmethod
	def supplemental_fields(cls, item):
		location_path = []
		parent = item
		while parent is not None:
			path_component_name = parent.display_name
			if not path_component_name:
				path_component_name = cls.UNNAMED_MODULE_NAME
			location_path.append(path_component_name)
			parent = parent.get_parent()
		location_path.reverse()
		return {
			"course_name": location_path[0],
			"location": location_path[1:4]
		}
class LibrarySearchIndexer(SearchIndexerBase):
	INDEX_NAME = "library_index"
	DOCUMENT_TYPE = "library_content"
	ENABLE_INDEXING_KEY = 'ENABLE_LIBRARY_INDEX'
	INDEX_EVENT = {
		'name': 'edx.library.index.reindexed',
		'category': 'library_index'
	}
	@classmethod
	def normalize_structure_key(cls, structure_key):
		return normalize_key_for_search(structure_key)
	@classmethod
	def _fetch_top_level(cls, modulestore, structure_key):
		return modulestore.get_library(structure_key, depth=None)
	@classmethod
	def _get_location_info(cls, normalized_structure_key):
		return {"library": unicode(normalized_structure_key)}
	@classmethod
	def _id_modifier(cls, usage_id):
		return usage_id.replace(library_key=(usage_id.library_key.replace(version_guid=None, branch=None)))
	@classmethod
	def do_library_reindex(cls, modulestore, library_key):
		return cls._do_reindex(modulestore, library_key)
class AboutInfo(object):
	PROPERTY = 1 << 1
	def __init__(self, property_name, index_flags, source_
		self.property_name = property_name
		self.index_flags = index_flags
		self.source_
	def get_value(self, **kwargs):
		return self.source_
	def
		about_dictionary = kwargs.get('about_dictionary', None)
		if not about_dictionary:
			raise ValueError("Context dictionary does not contain expected argument 'about_dictionary'")
		return about_dictionary.get(self.property_name, None)
	def
		course = kwargs.get('course', None)
		if not course:
			raise ValueError("Context dictionary does not contain expected argument 'course'")
		return getattr(course, self.property_name, None)
	def
		course = kwargs.get('course', None)
		if not course:
			raise ValueError("Context dictionary does not contain expected argument 'course'")
		return [mode.slug for mode in CourseMode.modes_for_course(course.id)]
	FROM_ABOUT_INFO =
	FROM_COURSE_PROPERTY =
	FROM_COURSE_MODE =
class CourseAboutSearchIndexer(object):
	DISCOVERY_DOCUMENT_TYPE = "course_info"
	INDEX_NAME = CoursewareSearchIndexer.INDEX_NAME
	ABOUT_INFORMATION_TO_INCLUDE = [
		AboutInfo("advertised_start", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("announcement", AboutInfo.PROPERTY, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("start", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("end", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("effort", AboutInfo.PROPERTY, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("display_name", AboutInfo.ANALYSE, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("overview", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("title", AboutInfo.ANALYSE | AboutInfo.PROPERTY, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("university", AboutInfo.ANALYSE | AboutInfo.PROPERTY, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("number", AboutInfo.ANALYSE | AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("short_description", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("description", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("key_dates", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("video", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("course_staff_short", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("course_staff_extended", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("requirements", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("syllabus", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("textbook", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("faq", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("more_info", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("ocw_links", AboutInfo.ANALYSE, AboutInfo.FROM_ABOUT_INFO),
		AboutInfo("enrollment_start", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("enrollment_end", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("org", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
		AboutInfo("modes", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_MODE),
		AboutInfo("language", AboutInfo.PROPERTY, AboutInfo.FROM_COURSE_PROPERTY),
	]
	@classmethod
	def index_about_information(cls, modulestore, course):
		searcher = SearchEngine.get_search_engine(cls.INDEX_NAME)
		if not searcher:
			return
		course_id = unicode(course.id)
		course_info = {
			'id': course_id,
			'course': course_id,
			'content': {},
			'image_url': course_image_url(course),
		}
		about_dictionary = {
			item.location.name: item.data
			for item in modulestore.get_items(course.id, qualifiers={"category": "about"})
		}
		about_context = {
			"course": course,
			"about_dictionary": about_dictionary,
		}
		for about_information in cls.ABOUT_INFORMATION_TO_INCLUDE:
			try:
				section_content = about_information.get_value(**about_context)
			except:
				section_content = None
				log.warning(
					"Course discovery could not collect property %s for course %s",
					about_information.property_name,
					course_id,
					exc_info=True,
				)
			if section_content:
				if about_information.index_flags & AboutInfo.ANALYSE:
					analyse_content = section_content
					if isinstance(section_content, basestring):
						analyse_content = strip_html_content_to_text(section_content)
					course_info['content'][about_information.property_name] = analyse_content
				if about_information.index_flags & AboutInfo.PROPERTY:
					course_info[about_information.property_name] = section_content
		try:
			searcher.index(cls.DISCOVERY_DOCUMENT_TYPE, [course_info])
		except:
			log.exception(
				"Course discovery indexing error encountered, course discovery index may be out of date %s",
				course_id,
			)
			raise
		log.debug(
			"Successfully added %s course to the course discovery index",
			course_id
		)