try:
except ImportError:
__author__ = 'Brian Quinlan (brian@sweetapp.com)'
_thread_references = set()
_shutdown = False
def _python_exit():
	global _shutdown
	_shutdown = True
	for thread_reference in _thread_references:
		thread = thread_reference()
		if thread is not None:
			thread.join()
def _remove_dead_thread_references():
	for thread_reference in set(_thread_references):
		if thread_reference() is None:
			_thread_references.discard(thread_reference)
atexit.register(_python_exit)
class _WorkItem(object):
	def __init__(self, future, fn, args, kwargs):
		self.future = future
		self.fn = fn
		self.args = args
		self.kwargs = kwargs
	def run(self):
		if not self.future.set_running_or_notify_cancel():
			return
		try:
			result = self.fn(*self.args, **self.kwargs)
		except BaseException:
			e = sys.exc_info()[1]
			self.future.set_exception(e)
		else:
			self.future.set_result(result)
def _worker(executor_reference, work_queue):
	try:
		while True:
			try:
				work_item = work_queue.get(block=True, timeout=0.1)
			except queue.Empty:
				executor = executor_reference()
				if _shutdown or executor is None or executor._shutdown:
					return
				del executor
			else:
				work_item.run()
	except BaseException:
		_base.LOGGER.critical('Exception in worker', exc_info=True)
class ThreadPoolExecutor(_base.Executor):
	def __init__(self, max_workers):
		_remove_dead_thread_references()
		self._max_workers = max_workers
		self._work_queue = queue.Queue()
		self._threads = set()
		self._shutdown = False
		self._shutdown_lock = threading.Lock()
	def submit(self, fn, *args, **kwargs):
		with self._shutdown_lock:
			if self._shutdown:
				raise RuntimeError('cannot schedule new futures after shutdown')
			f = _base.Future()
			w = _WorkItem(f, fn, args, kwargs)
			self._work_queue.put(w)
			self._adjust_thread_count()
			return f
	submit.__doc__ = _base.Executor.submit.__doc__
	def _adjust_thread_count(self):
		if len(self._threads) < self._max_workers:
			t = threading.Thread(target=_worker,
								 args=(weakref.ref(self), self._work_queue))
			t.daemon = True
			t.start()
			self._threads.add(t)
			_thread_references.add(weakref.ref(t))
	def shutdown(self, wait=True):
		with self._shutdown_lock:
			self._shutdown = True
		if wait:
			for t in self._threads:
				t.join()
	shutdown.__doc__ = _base.Executor.shutdown.__doc__