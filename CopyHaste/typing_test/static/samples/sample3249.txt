_VERSION = '0.1'
def _GetDefaultDestDir():
  home = os.environ.get('HOME', '')
  homeman = os.path.join(home, 'man', 'man1')
  if home and os.path.exists(homeman):
	return homeman
  else:
	return os.environ.get('TMPDIR', '/tmp')
FLAGS = gflags.FLAGS
gflags.DEFINE_string('dest_dir', _GetDefaultDestDir(),
					'Directory to write resulting manpage to.'
					' Specify \'-\' for stdout')
gflags.DEFINE_string('help_flag', '--help',
					'Option to pass to target program in to get help')
gflags.DEFINE_integer('v', 0, 'verbosity level to use for output')
_MIN_VALID_USAGE_MSG = 9
class Logging:
  def error(self, msg): print >>sys.stderr, "ERROR: ", msg
  def warn(self, msg): print >>sys.stderr, "WARNING: ", msg
  def info(self, msg): print msg
  def debug(self, msg): self.vlog(1, msg)
  def vlog(self, level, msg):
	if FLAGS.v >= level: print msg
logging = Logging()
class App:
  def usage(self, shorthelp=0):
	print >>sys.stderr, __doc__
	print >>sys.stderr, "flags:"
	print >>sys.stderr, str(FLAGS)
  def run(self):
	main(sys.argv)
app = App()
def GetRealPath(filename):
  if os.path.isabs(filename):
	return filename
  if filename.startswith('./') or  filename.startswith('../'):
	return os.path.abspath(filename)
  path = os.getenv('PATH', '')
  for directory in path.split(':'):
	tryname = os.path.join(directory, filename)
	if os.path.exists(tryname):
	  if not os.path.isabs(directory):
		return os.path.abspath(tryname)
	  return tryname
  if os.path.exists(filename):
	return os.path.abspath(filename)
  return None
class Flag(object):
  def __init__(self, flag_desc, help):
	self.desc = flag_desc
	self.help = help
	self.default = ''
	self.tips = ''
class ProgramInfo(object):
  module_py_re = re.compile(r'(\S.+):$')
  flag_py_re		 = re.compile(r'\s+(-\S+):\s+(.*)$')
  flag_default_py_re = re.compile(r'\s+\(default:\s+\'(.*)\'\)$')
  flag_tips_py_re	= re.compile(r'\s+\((.*)\)$')
  module_c_re = re.compile(r'\s+Flags
  flag_c_re		 = re.compile(r'\s+(-\S+)\s+(.*)$')
  module_java_re = re.compile(r'\s+Flags for (\S.+):$')
  flag_java_re		 = re.compile(r'\s+(-\S+)\s+(.*)$')
  def __init__(self, executable):
	self.long_name = executable
	self.name = os.path.basename(executable)
	(self.short_name, self.ext) = os.path.splitext(self.name)
	self.executable = GetRealPath(executable)
	self.output = []
	self.desc = []
	self.modules = {}
	self.module_list = []
	self.date = time.localtime(time.time())
  def Run(self):
	if not self.executable:
	  logging.error('Could not locate "%s"' % self.long_name)
	  return 0
	finfo = os.stat(self.executable)
	self.date = time.localtime(finfo[stat.ST_MTIME])
	logging.info('Running: %s %s </dev/null 2>&1'
				 % (self.executable, FLAGS.help_flag))
	(child_stdin, child_stdout_and_stderr) = os.popen4(
	  [self.executable, FLAGS.help_flag])
	child_stdin.close()
	self.output = child_stdout_and_stderr.readlines()
	child_stdout_and_stderr.close()
	if len(self.output) < _MIN_VALID_USAGE_MSG:
	  logging.error('Error: "%s %s" returned only %d lines: %s'
					% (self.name, FLAGS.help_flag,
					   len(self.output), self.output))
	  return 0
	return 1
  def Parse(self):
	(start_line, lang) = self.ParseDesc()
	if start_line < 0:
	  return
	if 'python' == lang:
	  self.ParsePythonFlags(start_line)
	elif 'c' == lang:
	  self.ParseCFlags(start_line)
	elif 'java' == lang:
	  self.ParseJavaFlags(start_line)
  def ParseDesc(self, start_line=0):
	exec_mod_start = self.executable + ':'
	after_blank = 0
	start_line = 0
	for start_line in range(start_line, len(self.output)):
	  line = self.output[start_line].rstrip()
	  if ('flags:' == line
		  and len(self.output) > start_line+1
		  and '' == self.output[start_line+1].rstrip()):
		start_line += 2
		logging.debug('Flags start (python): %s' % line)
		return (start_line, 'python')
	  if exec_mod_start == line:
		logging.debug('Flags start (swig): %s' % line)
		return (start_line, 'python')
	  if after_blank and line.startswith('  Flags
		logging.debug('Flags start (c): %s' % line)
		return (start_line, 'c')
	  if line == 'where flags are':
		logging.debug('Flags start (java): %s' % line)
		start_line += 2
		return (start_line, 'java')
	  logging.debug('Desc: %s' % line)
	  self.desc.append(line)
	  after_blank = (line == '')
	else:
	  logging.warn('Never found the start of the flags section for "%s"!'
				   % self.long_name)
	  return (-1, '')
  def ParsePythonFlags(self, start_line=0):
	modname = None
	modlist = []
	flag = None
	for line_num in range(start_line, len(self.output)):
	  line = self.output[line_num].rstrip()
	  if not line:
		continue
	  mobj = self.module_py_re.match(line)
	  if mobj:
		modname = mobj.group(1)
		logging.debug('Module: %s' % line)
		if flag:
		  modlist.append(flag)
		self.module_list.append(modname)
		self.modules.setdefault(modname, [])
		modlist = self.modules[modname]
		flag = None
		continue
	  mobj = self.flag_py_re.match(line)
	  if mobj:
		if flag:
		  modlist.append(flag)
		logging.debug('Flag: %s' % line)
		flag = Flag(mobj.group(1),  mobj.group(2))
		continue
	  if not flag:
		logging.error('Flag info, but no current flag "%s"' % line)
	  mobj = self.flag_default_py_re.match(line)
	  if mobj:
		flag.default = mobj.group(1)
		logging.debug('Fdef: %s' % line)
		continue
	  mobj = self.flag_tips_py_re.match(line)
	  if mobj:
		flag.tips = mobj.group(1)
		logging.debug('Ftip: %s' % line)
		continue
	  if flag and flag.help:
		flag.help += line
	  else:
		logging.info('Extra: %s' % line)
	if flag:
	  modlist.append(flag)
  def ParseCFlags(self, start_line=0):
	modname = None
	modlist = []
	flag = None
	for line_num in range(start_line, len(self.output)):
	  line = self.output[line_num].rstrip()
	  if not line:
		if flag:
		  modlist.append(flag)
		  flag = None
		continue
	  mobj = self.module_c_re.match(line)
	  if mobj:
		modname = mobj.group(1)
		logging.debug('Module: %s' % line)
		if flag:
		  modlist.append(flag)
		self.module_list.append(modname)
		self.modules.setdefault(modname, [])
		modlist = self.modules[modname]
		flag = None
		continue
	  mobj = self.flag_c_re.match(line)
	  if mobj:
		if flag:
		  modlist.append(flag)
		logging.debug('Flag: %s' % line)
		flag = Flag(mobj.group(1),  mobj.group(2))
		continue
	  if flag:
		flag.help += ' ' + line.strip()
	  else:
		logging.info('Extra: %s' % line)
	if flag:
	  modlist.append(flag)
  def ParseJavaFlags(self, start_line=0):
	modname = 'Standard flags'
	self.module_list.append(modname)
	self.modules.setdefault(modname, [])
	modlist = self.modules[modname]
	flag = None
	for line_num in range(start_line, len(self.output)):
	  line = self.output[line_num].rstrip()
	  logging.vlog(2, 'Line: "%s"' % line)
	  if not line:
		if flag:
		  modlist.append(flag)
		  flag = None
		continue
	  mobj = self.module_java_re.match(line)
	  if mobj:
		modname = mobj.group(1)
		logging.debug('Module: %s' % line)
		if flag:
		  modlist.append(flag)
		self.module_list.append(modname)
		self.modules.setdefault(modname, [])
		modlist = self.modules[modname]
		flag = None
		continue
	  mobj = self.flag_java_re.match(line)
	  if mobj:
		if flag:
		  modlist.append(flag)
		logging.debug('Flag: %s' % line)
		flag = Flag(mobj.group(1),  mobj.group(2))
		continue
	  if flag:
		flag.help += ' ' + line.strip()
	  else:
		logging.info('Extra: %s' % line)
	if flag:
	  modlist.append(flag)
  def Filter(self):
	if not self.desc:
	  self.short_desc = ''
	  return
	for i in range(len(self.desc)):
	  if self.desc[i].find(self.executable) >= 0:
		self.desc[i] = self.desc[i].replace(self.executable, self.name)
	self.short_desc = self.desc[0]
	word_list = self.short_desc.split(' ')
	all_names = [ self.name, self.short_name, ]
	while word_list and (word_list[0] in all_names
						 or word_list[0].lower() in all_names):
	  del word_list[0]
	  self.short_desc = ''
	if not self.short_desc and word_list:
	  self.short_desc = ' '.join(word_list)
class GenerateDoc(object):
  def __init__(self, proginfo, directory='.'):
	self.info = proginfo
	self.dirname = directory
  def Output(self):
	self.Open()
	self.Header()
	self.Body()
	self.Footer()
  def Open(self): raise NotImplementedError
  def Header(self): raise NotImplementedError
  def Body(self): raise NotImplementedError
  def Footer(self): raise NotImplementedError
class GenerateMan(GenerateDoc):
  def __init__(self, proginfo, directory='.'):
	GenerateDoc.__init__(self, proginfo, directory)
  def Open(self):
	if self.dirname == '-':
	  logging.info('Writing to stdout')
	  self.fp = sys.stdout
	else:
	  self.file_path = '%s.1' % os.path.join(self.dirname, self.info.name)
	  logging.info('Writing: %s' % self.file_path)
	  self.fp = open(self.file_path, 'w')
  def Header(self):
	self.fp.write(
	  '.\\" DO NOT MODIFY THIS FILE!  It was generated by gflags2man %s\n'
	  % _VERSION)
	self.fp.write(
	  '.TH %s "1" "%s" "%s" "User Commands"\n'
	  % (self.info.name, time.strftime('%x', self.info.date), self.info.name))
	self.fp.write(
	  '.SH NAME\n%s \\- %s\n' % (self.info.name, self.info.short_desc))
	self.fp.write(
	  '.SH SYNOPSIS\n.B %s\n[\\fIFLAGS\\fR]...\n' % self.info.name)
  def Body(self):
	self.fp.write(
	  '.SH DESCRIPTION\n.\\" Add any additional description here\n.PP\n')
	for ln in self.info.desc:
	  self.fp.write('%s\n' % ln)
	self.fp.write(
	  '.SH OPTIONS\n')
	for modname in self.info.module_list:
	  if modname.find(self.info.executable) >= 0:
		mod = modname.replace(self.info.executable, self.info.name)
	  else:
		mod = modname
	  self.fp.write('\n.P\n.I %s\n' % mod)
	  for flag in self.info.modules[modname]:
		help_string = flag.help
		if flag.default or flag.tips:
		  help_string += '\n.br\n'
		if flag.default:
		  help_string += '  (default: \'%s\')' % flag.default
		if flag.tips:
		  help_string += '  (%s)' % flag.tips
		self.fp.write(
		  '.TP\n%s\n%s\n' % (flag.desc, help_string))
  def Footer(self):
	self.fp.write(
	  '.SH COPYRIGHT\nCopyright \(co %s Google.\n'
	  % time.strftime('%Y', self.info.date))
	self.fp.write('Gflags2man created this page
				  % (self.info.name, FLAGS.help_flag))
	self.fp.write('\nGflags2man was written by Dan Christian. '
				  ' Note that the date on this'
				  ' page is the modification date of %s.\n' % self.info.name)
def main(argv):
  argv = FLAGS(argv)
  if len(argv) <= 1:
	app.usage(shorthelp=1)
	return 1
  for arg in argv[1:]:
	prog = ProgramInfo(arg)
	if not prog.Run():
	  continue
	prog.Parse()
	prog.Filter()
	doc = GenerateMan(prog, FLAGS.dest_dir)
	doc.Output()
  return 0
if __name__ == '__main__':
  app.run()