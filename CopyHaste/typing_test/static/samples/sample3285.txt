_ = L10n.get_translation()
class Absolute(HandHistoryConverter):
	sitename = "Absolute"
	filetype = "text"
	codepage = "cp1252"
	siteid   = 8
	HORSEHand = False
	re_SplitHands  = re.compile(r"\n\n+")
	re_TailSplitHands  = re.compile(r"(\nn\n+)")
	re_GameInfo = re.compile( ur, re.MULTILINE|re.VERBOSE|re.DOTALL)
	re_HorseGameInfo = re.compile(
			ur"^Game Type: (?P<LIMIT>Limit) (?P<GAME>Holdem)",
			re.MULTILINE)
	re_HandInfo = re_GameInfo
	re_RingInfoFromFilename = re.compile(ur".*IHH([0-9]+) (?P<TABLE>.*) -")
	re_TrnyInfoFromFilename = re.compile(
			ur"IHH\s?([0-9]+) (?P<TRNY_NAME>.*) "\
			ur"ID (?P<TRNY_ID>\d+)\s?(\((?P<TABLE>\d+)\))? .* "\
			ur"(?:\$|\s€|)(?P<BUYIN>[0-9.]+)\s*\+\s*(?:\$|\s€|)(?P<FEE>[0-9.]+)"
			)
	re_Button = re.compile(ur"Seat
	re_PlayerInfo = re.compile(
			ur"^Seat (?P<SEAT>[0-9]) - (?P<PNAME>.*) "\
			ur"\((?:\$| €|)(?P<CASH>[0-9]*[.,0-9]+) in chips\)",
			re.MULTILINE)
	re_Board = re.compile(ur"\[(?P<CARDS>[^\]]*)\]? *$", re.MULTILINE)
	def compilePlayerRegexs(self, hand):
		players = set([player[1] for player in hand.players])
		if not players <= self.compiledPlayers:
			self.compiledPlayers = players
			player_re = "(?P<PNAME>" + "|".join(map(re.escape, players)) + ")"
			log.debug("player_re: "+ player_re)
			self.re_PostSB		  = re.compile(ur"^%s - Posts small blind (?:\$| €|)(?P<SB>[,.0-9]+)" % player_re, re.MULTILINE)
			self.re_PostBB		  = re.compile(ur"^%s - Posts big blind (?:\$| €|)(?P<BB>[.,0-9]+)" % player_re, re.MULTILINE)
			self.re_Post			= re.compile(ur"^%s - Posts (?:\$| €|)(?P<BB>[.,0-9]+)" % player_re, re.MULTILINE)
			self.re_PostBoth		= re.compile(ur"^%s - Posts dead (?:\$| €|)(?P<SBBB>[,.0-9]+)" % player_re, re.MULTILINE)
			self.re_Action		  = re.compile(ur"^%s - (?P<ATYPE>Bets |Raises |All-In |All-In\(Raise\) |Calls |Folds|Checks)?\$?(?P<BET>[,.0-9]+)?" % player_re, re.MULTILINE)
			self.re_ShowdownAction  = re.compile(ur"^%s - Shows \[(?P<CARDS>.*)\]" % player_re, re.MULTILINE)
			self.re_CollectPot	  = re.compile(ur"^Seat [0-9]: %s(?: \(dealer\)|)(?: \(big blind\)| \(small blind\)|) (?:won|collected) Total \((?:\$| €|)(?P<POT>[,.0-9]+)\)" % player_re, re.MULTILINE)
			self.re_Antes		   = re.compile(ur"^%s - Ante \[(?:\$| €|)(?P<ANTE>[,.0-9]+)" % player_re, re.MULTILINE)
			self.re_HeroCards	   = re.compile(ur"^Dealt to %s \[(?P<CARDS>.*)\]" % player_re, re.MULTILINE)
	def readSupportedGames(self):
		return [["ring", "hold", "nl"],
				["ring", "hold", "pl"],
				["ring", "hold", "fl"],
				["ring", "studhi", "fl"],
				["ring", "omahahi", "pl"],
				["tour", "hold", "nl"],
			   ]
	def determineGameType(self, handText):
		info = {'type':'ring'}
		m = self.re_GameInfo.search(handText)
		if not m:
			tmp = handText[0:200]
			log.error(_("AbsoluteToFpdb.determineGameType: '%s'") % tmp)
			raise FpdbParseError
		mg = m.groupdict()
		limits = { 'No Limit':'nl', 'Pot Limit':'pl', 'Normal':'fl', 'Limit':'fl'}
		games = {
				   "Holdem" : ('hold','holdem'),
					'Omaha' : ('hold','omahahi'),
					 'Razz' : ('stud','razz'),
		 'Seven Card Hi/Lo' : ('stud','studhilo'),
			  '7 Card Stud' : ('stud','studhi')
			   }
		currencies = { u' €':'EUR', '$':'USD', '':'T$' }
		if 'GAME' in mg and mg['GAME'] == "HORSE":
			self.HORSEHand = True
			m = self.re_HorseGameInfo.search(handText)
			if not m:
				return None
			temp = m.groupdict()
			if 'GAME' not in temp or 'LIMIT' not in temp:
				return None
			mg['GAME'] = temp['GAME']
			mg['LIMIT'] = temp['LIMIT']
		if 'GAME' in mg:
			(info['base'], info['category']) = games[mg['GAME']]
		if 'LIMIT' in mg:
			info['limitType'] = limits[mg['LIMIT']]
		if 'CURRENCY' in mg:
			info['currency'] = currencies[mg['CURRENCY']]
			if info['currency'] == 'T$':
				info['type'] = 'tour'
		if 'SB' in mg:
			mg['SB'] = mg['SB'].replace(',', '')
			info['sb'] = mg['SB']
		if 'BB' in mg:
			info['bb'] = mg['BB']
		if info['bb'] is None:
			mg['SB'] = mg['SB'].replace(',', '')
			info['bb'] = mg['SB']
			info['sb'] = str(float(mg['SB']) * 0.5)
		return info
	def readHandInfo(self, hand):
		is_trny = hand.gametype['type']=='tour'
		m = self.re_HandInfo.search(hand.handText)
		fname_re = self.re_TrnyInfoFromFilename if is_trny \
				   else self.re_RingInfoFromFilename
		fname_info = fname_re.search(self.in_path)
		if m is None or fname_info is None:
			if m is None:
				tmp = hand.handText[0:200]
				log.error(_("AbsoluteToFpdb.readHandInfo: '%s'") % tmp)
				raise FpdbParseError
			elif fname_info is None:
				log.error(_("AbsoluteToFpdb.readHandInfo: File name didn't match re_*InfoFromFilename"))
				raise FpdbParseError
		log.debug("HID %s, Table %s" % (m.group('HID'),  m.group('TABLE')))
		hand.handid =  m.group('HID')
		if m.group('TABLE'):
			hand.tablename = m.group('TABLE')
		else:
			hand.tablename = fname_info.group('TABLE')
		hand.startTime = datetime.datetime.strptime(m.group('DATETIME'), "%Y-%m-%d %H:%M:%S")
		if is_trny:
			hand.fee = fname_info.group('FEE')
			hand.buyin = fname_info.group('BUYIN')
			hand.tourNo = m.group('TRNY_ID')
			hand.tourneyComment = fname_info.group('TRNY_NAME')
		hand.maxseats = 6
		if self.HORSEHand:
			hand.maxseats = 8
		return
	def readPlayerStacks(self, hand):
		m = self.re_PlayerInfo.finditer(hand.handText)
		for a in m:
			seatnum = int(a.group('SEAT'))
			hand.addPlayer(seatnum, a.group('PNAME'), a.group('CASH'))
			if seatnum > 6:
				hand.maxseats = 9
	def markStreets(self, hand):
		if hand.gametype['base'] == 'hold':
			m = re.search(r"\*\*\* POCKET CARDS \*\*\*(?P<PREFLOP>.+(?=\*\*\* FLOP \*\*\*)|.+)"
					r"(\*\*\* FLOP \*\*\*(?P<FLOP>.+(?=\*\*\* TURN \*\*\*)|.+))?"
					r"(\*\*\* TURN \*\*\*(?P<TURN>.+(?=\*\*\* RIVER \*\*\*)|.+))?"
					r"(\*\*\* RIVER \*\*\*(?P<RIVER>.+))?", hand.handText, re.DOTALL)
		elif hand.gametype['base'] == 'stud':
			m =	 re.search(r"(?P<ANTES>.+(?=\*\* Dealing down cards \*\*)|.+)"
						   r"(\*\* Dealing down cards \*\*(?P<THIRD>.+(?=\*\*\*\* dealing 4th street \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing 4th street \*\*\*\*(?P<FOURTH>.+(?=\*\*\*\* dealing 5th street \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing 5th street \*\*\*\*(?P<FIFTH>.+(?=\*\*\*\* dealing 6th street \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing 6th street \*\*\*\*(?P<SIXTH>.+(?=\*\*\*\* dealing river \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing river \*\*\*\*(?P<SEVENTH>.+))?", hand.handText,re.DOTALL)
		hand.addStreets(m)
	def readCommunityCards(self, hand, street):
		log.debug("readCommunityCards (%s)" % street)
		m = self.re_Board.search(hand.streets[street])
		cards = m.group('CARDS')
		cards = [validCard(card) for card in cards.split(' ')]
		hand.setCommunityCards(street=street, cards=cards)
	def readAntes(self, hand):
		log.debug(_("reading antes"))
		m = self.re_Antes.finditer(hand.handText)
		for player in m:
			log.debug("hand.addAnte(%s,%s)" %(player.group('PNAME'), player.group('ANTE')))
			hand.addAnte(player.group('PNAME'), player.group('ANTE'))
	def readBringIn(self, hand):
		m = self.re_BringIn.search(hand.handText,re.DOTALL)
		if m:
			log.debug(_("Player bringing in: %s for %s") % (m.group('PNAME'),  m.group('BRINGIN')))
			hand.addBringIn(m.group('PNAME'),  m.group('BRINGIN'))
		else:
			log.warning(_("No bringin found."))
	def readBlinds(self, hand):
		m = self.re_PostSB.search(hand.handText)
		if m is not None:
			hand.addBlind(m.group('PNAME'), 'small blind', m.group('SB'))
		else:
			log.debug(_("No small blind"))
			hand.addBlind(None, None, None)
		for a in self.re_PostBB.finditer(hand.handText):
			hand.addBlind(a.group('PNAME'), 'big blind', a.group('BB'))
		for a in self.re_PostBoth.finditer(hand.handText):
			hand.addBlind(a.group('PNAME'), 'both', a.group('SBBB'))
		for a in self.re_Post.finditer(hand.handText):
			hand.addBlind(a.group('PNAME'), 'big blind', a.group('BB'))
	def readButton(self, hand):
		hand.buttonpos = int(self.re_Button.search(hand.handText).group('BUTTON'))
	def readHeroCards(self, hand):
		m = self.re_HeroCards.search(hand.handText)
		if m:
			hand.hero = m.group('PNAME')
			cards = m.group('CARDS')
			cards = [validCard(card) for card in cards.split(' ')]
			hand.addHoleCards('PREFLOP', hand.hero, closed=cards, shown=False, mucked=False, dealt=True)
		else:
			hand.involved = False
	def readStudPlayerCards(self, hand, street):
		log.warning(_("%s cannot read all stud/razz hands yet.") % hand.sitename)
	def readAction(self, hand, street):
		log.debug("readAction (%s)" % street)
		m = self.re_Action.finditer(hand.streets[street])
		for action in m:
			log.debug("%s %s" % (action.group('ATYPE'), action.groupdict()))
			if action.group('ATYPE') == 'Folds':
				hand.addFold( street, action.group('PNAME'))
			elif action.group('ATYPE') == 'Checks':
				hand.addCheck( street, action.group('PNAME'))
			elif action.group('ATYPE') == 'Calls ':
				bet = action.group('BET').replace(',', '')
				hand.addCall( street, action.group('PNAME'), bet)
			elif action.group('ATYPE') == 'Bets ' or action.group('ATYPE') == 'All-In ':
				bet = action.group('BET').replace(',', '')
				hand.addBet( street, action.group('PNAME'), bet)
			elif action.group('ATYPE') == 'Raises ' or action.group('ATYPE') == 'All-In(Raise) ':
				bet = action.group('BET').replace(',', '')
				hand.addCallandRaise( street, action.group('PNAME'), bet)
			elif action.group('ATYPE') == ' complete to':
				bet = action.group('BET').replace(',', '')
				hand.addComplete( street, action.group('PNAME'), bet)
			else:
				log.debug(_("Unimplemented %s: '%s' '%s'") % ("readAction", action.group('PNAME'), action.group('ATYPE')))
	def readShowdownActions(self, hand):
		log.debug("readShowdownActions")
		for shows in self.re_ShowdownAction.finditer(hand.handText):
			cards = shows.group('CARDS')
			cards = [validCard(card) for card in cards.split(' ')]
			log.debug("readShowdownActions %s %s" %(cards, shows.group('PNAME')))
			hand.addShownCards(cards, shows.group('PNAME'))
	def readCollectPot(self,hand):
		for m in self.re_CollectPot.finditer(hand.handText):
			pot = m.group('POT').replace(',','')
			hand.addCollectPot(player=m.group('PNAME'),pot=pot)
	def readShownCards(self,hand):
		for m in self.re_CollectPot.finditer(hand.handText):
			try:
				if m.group('CARDS') is not None:
					cards = m.group('CARDS')
					cards = [validCard(card) for card in cards.split(' ')]
					player = m.group('PNAME')
					log.debug("readShownCards %s cards=%s" % (player, cards))
					hand.addShownCards(cards=cards, player=m.group('PNAME'))
			except IndexError:
				pass
def validCard(card):
	card = card.strip()
	if card == '10s': card = 'Ts'
	if card == '10h': card = 'Th'
	if card == '10d': card = 'Td'
	if card == '10c': card = 'Tc'
	return card