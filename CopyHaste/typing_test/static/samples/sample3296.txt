_ = L10n.get_translation()
log = logging.getLogger("parser")
try:
	pokereval = PokerEval()
except:
	pokereval = None
class DerivedStats():
	def __init__(self, hand):
		self.hand = hand
		self.hands		= {}
		self.handsplayers = {}
		self.handsactions = {}
		self.handsstove   = []
		self._initStats = DerivedStats._buildStatsInitializer()
	@staticmethod
	def _buildStatsInitializer():
		init = {}
		init['winnings']	= 0
		init['rake']		= 0
		init['totalProfit'] = 0
		init['allInEV']	 = 0
		init['street4Aggr'] = False
		init['wonWhenSeenStreet1'] = 0.0
		init['sawShowdown'] = False
		init['showed']	  = False
		init['wonAtSD']	 = 0.0
		init['startCards']  = 0
		init['position']			= 2
		init['street0CalledRaiseChance'] = 0
		init['street0CalledRaiseDone'] = 0
		init['street0_3BChance']	= False
		init['street0_3BDone']	  = False
		init['street0_4BChance']	= False
		init['street0_4BDone']	  = False
		init['street0_C4BChance']   = False
		init['street0_C4BDone']	 = False
		init['street0_FoldTo3BChance']= False
		init['street0_FoldTo3BDone']= False
		init['street0_FoldTo4BChance']= False
		init['street0_FoldTo4BDone']= False
		init['street0_SqueezeChance']= False
		init['street0_SqueezeDone'] = False
		init['success_Steal']	   = False
		init['raiseToStealChance']  = False
		init['raiseToStealDone']  = False
		init['raiseFirstInChance']  = False
		init['raisedFirstIn']	   = False
		init['foldBbToStealChance'] = False
		init['foldSbToStealChance'] = False
		init['foldedSbToSteal']	 = False
		init['foldedBbToSteal']	 = False
		init['tourneyTypeId']	   = None
		init['street1Seen']		 = False
		init['street2Seen']		 = False
		init['street3Seen']		 = False
		init['street4Seen']		 = False
		for i in range(5):
			init['street%dCalls' % i] = 0
			init['street%dBets' % i] = 0
			init['street%dRaises' % i] = 0
		for i in range(1,5):
			init['street%dCBChance' %i] = False
			init['street%dCBDone' %i] = False
			init['street%dCheckCallRaiseChance' %i] = False
			init['street%dCheckCallRaiseDone' %i]   = False
			init['otherRaisedStreet%d' %i]		  = False
			init['foldToOtherRaisedStreet%d' %i]	= False
		init['other3BStreet0']			  = False
		init['other4BStreet0']			  = False
		init['otherRaisedStreet0']		  = False
		init['foldToOtherRaisedStreet0']	= False
		for i in range(1,5):
			init['foldToStreet%dCBChance' %i]	   = False
			init['foldToStreet%dCBDone' %i]		 = False
		init['wonWhenSeenStreet2'] = 0.0
		init['wonWhenSeenStreet3'] = 0.0
		init['wonWhenSeenStreet4'] = 0.0
		return init
	def getStats(self, hand):
		for player in hand.players:
			self.handsplayers[player[1]] = self._initStats.copy()
		
		self.assembleHands(self.hand)
		self.assembleHandsPlayers(self.hand)
		if self.hand.saveActions:
			self.assembleHandsActions(self.hand)
		
		if pokereval:
			if self.hand.gametype['category'] in Card.games:
				self.assembleHandsStove(self.hand)
	def getHands(self):
		return self.hands
	def getHandsPlayers(self):
		return self.handsplayers
	def getHandsActions(self):
		return self.handsactions
	
	def getHandsStove(self):
		return self.handsstove
	def assembleHands(self, hand):
		self.hands['tableName']	 = hand.tablename
		self.hands['siteHandNo']	= hand.handid
		self.hands['gametypeId']	= None
		self.hands['sessionId']	 = None
		self.hands['gameId']		= None
		self.hands['startTime']	 = hand.startTime
		self.hands['
		self.hands['seats']		 = self.countPlayers(hand)
		self.hands['texture']	   = None
		self.hands['tourneyId']	 = hand.tourneyId
		boardcards = []
		for street in hand.communityStreets:
			boardcards += hand.board[street]
		boardcards += [u'0x', u'0x', u'0x', u'0x', u'0x']
		cards = [Card.encodeCard(c) for c in boardcards[0:5]]
		self.hands['boardcard1'] = cards[0]
		self.hands['boardcard2'] = cards[1]
		self.hands['boardcard3'] = cards[2]
		self.hands['boardcard4'] = cards[3]
		self.hands['boardcard5'] = cards[4]
		
		self.hands['boards']	 = []
		self.hands['runItTwice']	  = False		   
		for i in range(hand.runItTimes):
			self.hands['runItTwice']  = True
			boardcards = []
			for street in hand.communityStreets:
				boardId = i+1
				street_i = street + str(boardId)
				if street_i in hand.board:
					boardcards += hand.board[street_i]
			boardcards = [u'0x', u'0x', u'0x', u'0x', u'0x'] + boardcards
			cards = [Card.encodeCard(c) for c in boardcards[-5:]]
			self.hands['boards'] += [[boardId] + cards]
		totals = hand.getStreetTotals()
		totals = [int(100*i) for i in totals]
		self.hands['street1Pot']  = totals[0]
		self.hands['street2Pot']  = totals[1]
		self.hands['street3Pot']  = totals[2]
		self.hands['street4Pot']  = totals[3]
		self.hands['showdownPot'] = totals[4]
		self.vpip(hand)
		self.playersAtStreetX(hand)
		self.streetXRaises(hand)
	def assembleHandsPlayers(self, hand):
		for player in hand.players:
			self.handsplayers[player[1]]['seatNo'] = player[0]
			self.handsplayers[player[1]]['startCash'] = int(100 * Decimal(player[2]))
			self.handsplayers[player[1]]['sitout'] = False
			if hand.gametype["type"]=="tour":
				self.handsplayers[player[1]]['tourneyTypeId']=hand.tourneyTypeId
				self.handsplayers[player[1]]['tourneysPlayersIds'] = hand.tourneysPlayersIds[player[1]]
			else:
				self.handsplayers[player[1]]['tourneysPlayersIds'] = None
			if player[1] in hand.shown:
				self.handsplayers[player[1]]['showed'] = True
		for i, street in enumerate(hand.actionStreets[1:]):
			self.aggr(self.hand, i)
			self.calls(self.hand, i)
			self.bets(self.hand, i)
			if i>0:
				self.folds(self.hand, i)
		for player in hand.collectees:
			self.handsplayers[player]['winnings'] = int(100 * hand.collectees[player])
			self.handsplayers[player]['rake'] = int(100* hand.rake)/len(hand.collectees)
			if self.handsplayers[player]['street1Seen'] == True:
				self.handsplayers[player]['wonWhenSeenStreet1'] = 1.0
			if self.handsplayers[player]['street2Seen'] == True:
				self.handsplayers[player]['wonWhenSeenStreet2'] = 1.0
			if self.handsplayers[player]['street3Seen'] == True:
				self.handsplayers[player]['wonWhenSeenStreet3'] = 1.0
			if self.handsplayers[player]['street4Seen'] == True:
				self.handsplayers[player]['wonWhenSeenStreet4'] = 1.0
			if self.handsplayers[player]['sawShowdown'] == True:
				self.handsplayers[player]['wonAtSD'] = 1.0
		for player in hand.pot.committed:
			self.handsplayers[player]['totalProfit'] = int(self.handsplayers[player]['winnings'] - (100*hand.pot.committed[player])- (100*hand.pot.common[player]))
			if hand.gametype['type'] == 'ring' and pokereval:
				self.handsplayers[player]['allInEV'] = self.handsplayers[player]['totalProfit']
		self.calcCBets(hand)
		for player in hand.players:
			hcs = hand.join_holecards(player[1], asList=True)
			hcs = hcs + [u'0x']*18
			for i, card in enumerate(hcs[:20]):
				self.handsplayers[player[1]]['card%s' % (i+1)] = Card.encodeCard(card)
			self.handsplayers[player[1]]['startCards'] = Card.calcStartCards(hand, player[1])
		self.setPositions(hand)
		self.calcCheckCallRaise(hand)
		self.calc34BetStreet0(hand)
		self.calcSteals(hand)
		self.calcCalledRaiseStreet0(hand)
	def assembleHandsActions(self, hand):
		k = 0
		for i, street in enumerate(hand.actionStreets):
			for j, act in enumerate(hand.actions[street]):
				k += 1
				self.handsactions[k] = {}
				self.handsactions[k]['amount'] = 0
				self.handsactions[k]['raiseTo'] = 0
				self.handsactions[k]['amountCalled'] = 0
				self.handsactions[k]['numDiscarded'] = 0
				self.handsactions[k]['cardsDiscarded'] = None
				self.handsactions[k]['allIn'] = False
				self.handsactions[k]['player'] = act[0]
				self.handsactions[k]['street'] = i-1
				self.handsactions[k]['actionNo'] = k
				self.handsactions[k]['streetActionNo'] = (j+1)
				self.handsactions[k]['actionId'] = hand.ACTION[act[1]]
				if act[1] not in ('discards') and len(act) > 2:
					self.handsactions[k]['amount'] = int(100 * act[2])
				if act[1] in ('raises', 'completes'):
					self.handsactions[k]['raiseTo'] = int(100 * act[3])
					self.handsactions[k]['amountCalled'] = int(100 * act[4])
				if act[1] in ('discards'):
					self.handsactions[k]['numDiscarded'] = int(act[2])
				if act[1] in ('discards') and len(act) > 3:
					self.handsactions[k]['cardsDiscarded'] = act[3]
				if len(act) > 3 and act[1] not in ('discards'):
					self.handsactions[k]['allIn'] = act[-1]
	
	def assembleHandsStove(self, hand):
		game = Card.games[hand.gametype['category']]
		holecards, holeplayers, streets, boards, boardcards, inserts_temp, allInStreets = {}, [], {}, {}, [], [], []
		defaultStreet = {'board': [[]], 'allin': False}
		showdown = False
		for player in hand.players:
			if (self.handsplayers[player[1]]['sawShowdown']):
				showdown = True
		if game[0] == 'hold':
			allInStreets = hand.communityStreets
			boards['FLOP']  = {'board': [hand.board['FLOP']], 'allin': False}
			boards['TURN']  = {'board': [hand.board['FLOP'] + hand.board['TURN']], 'allin': False}
			boards['RIVER'] = {'board': [hand.board['FLOP'] + hand.board['TURN'] + hand.board['RIVER']], 'allin': False}
			for street in hand.communityStreets:
				boardcards += hand.board[street]
				if not hand.actions[street] and showdown:
					if street=='FLOP':
						allInStreets = ['PREFLOP'] + allInStreets
						boards['PREFLOP'] = {'board': [[]], 'allin': True}
					else: 
						id = Card.streets[game[0]][street]
						boards[hand.actionStreets[id]]['allin'] = True
					boards[street]['allin'] = True
			flop, turn, river = [], [], []
			for i in range(hand.runItTimes):
				runitcards = []
				for street in hand.communityStreets:
					street_i = street + str((i+1))
					if street_i in hand.board:
						runitcards += hand.board[street_i]
						if len(boardcards + runitcards)==3: flop.append(boardcards + runitcards)
						if len(boardcards + runitcards)==4: turn.append(boardcards + runitcards)
						if len(boardcards + runitcards)==5: river.append(boardcards + runitcards)
			if flop: boards['FLOP']['board'] = flop
			if turn: boards['TURN']['board'] = turn
			if river: boards['RIVER']['board'] = river
		for player in hand.players:
			hole, cards, bcards = [], [], []
			best_lo, locards, lostring = None, None, None
			best_hi, hicards, histring = None, None, None
			if (self.handsplayers[player[1]]['sawShowdown']) or player[1]==hand.hero:
				if (hand.gametype['category'] != 'badugi' and
					hand.gametype['category'] != 'razz'):
					hcs = hand.join_holecards(player[1], asList=True)
					if game[0] == 'hold':
						if 'omaha' in game[1]:
							hole = hcs[:4]
						else:
							hole = hcs[:2]
						last = 'RIVER'
					elif game[0] == 'stud':
						hole = hcs[:7]
						boards['SEVENTH'] = defaultStreet
						last = 'SEVENTH'
					elif game[0] == 'draw':
						if u'0x' in hcs[-5:]:
							hole = hcs[5:10]
						else:
							hole = hcs[-5:]
						if hand.gametype['category']=='27_1draw' or hand.gametype['category']=='fivedraw':
							boards['DRAWONE'] = defaultStreet
							last = 'DRAWONE'
						else:
							boards['DRAWTHREE'] = defaultStreet
							last = 'DRAWTHREE'
							
					holecards[player[1]] = {}
					holecards[player[1]]['hole'] = [str(c) for c in hole]
					holecards[player[1]]['cards'] = []
					holecards[player[1]]['eq'] = 0
					holecards[player[1]]['committed'] = 0
					holeplayers.append(player[1])
					
					for street, board in boards.iteritems():
						streetId = Card.streets[game[0]][street]
						if (board['allin'] or player[1]==hand.hero or self.handsplayers[player[1]]['sawShowdown']):
							boardId = 0
							for n in range(len(board['board'])):
								if len(board['board']) > 1: 
									boardId = n + 1
								else: boardId = n
								cards = [str(c) for c in hole]
								if board['board'][n]: bcards = [str(b) for b in board['board'][n]]
								else				: bcards = []
								histring, lostring, histringold, lostringold, lostringvalue, histringvalue, winnings = None, None, None, None, 0, 0, 0
								if 'omaha' not in game[1]:
									if board['board'][n]:
										cards = hole + board['board'][n]
										cards  = [str(c) for c in cards]
										bcards = []
								holecards[player[1]]['cards'] += [cards]
								if (u'0x' not in cards and 'Nu' not in cards) and ((game[0] == 'hold' and len(board['board'][n])>=3) or 
								   (game[0] == 'stud' and len(cards)==7) or (game[0] == 'draw' and len(cards)==5)):
									 if game[2] == 'h':
										 best_hi = pokereval.best_hand("hi", cards, bcards)
										 hicards = [pokereval.card2string(i) for i in best_hi[1:]]
										 histring = Card.hands['hi'][best_hi[0]]
									 elif game[2] == 'l':
										 best_lo = pokereval.best_hand("low", cards, bcards)
										 best_lo_r = pokereval.best_hand("hi", cards, bcards)
										 locards = [pokereval.card2string(i) for i in best_lo[1:]]
										 locards_r = [pokereval.card2string(i) for i in best_lo_r[1:]]
										 lostring = Card.hands['lo'][best_lo[0]]
									 elif game[2] == 's':
										 best_hi = pokereval.best_hand("hi", cards, bcards)
										 hicards = [pokereval.card2string(i) for i in best_hi[1:]]
										 histring = Card.hands['hi'][best_hi[0]]
										 best_lo = pokereval.best_hand("low", cards, bcards)
										 locards = [pokereval.card2string(i) for i in best_lo[1:]]
										 lostring = Card.hands['lo'][best_lo[0]]
									 elif game[2] == 'r':
										 best_lo = pokereval.best_hand("hi", cards, bcards)
										 locards = [pokereval.card2string(i) for i in best_lo[1:]]
										 if locards[4] in ('As', 'Ad', 'Ah', 'Ac'):
											 locards = [locards[4]] + locards[1:]
										 lostring = Card.hands['hi'][best_lo[0]]
										
									 if lostring:
										 lostring = self.getHandString('lo', lostring, locards, best_lo)
										 lostringvalue = pokereval.best_hand_value("lo", cards, bcards)
										 winnings = self.handsplayers[player[1]]['winnings']
										 lostringold = lostring
										 if street == last:
											 for j in range(len(inserts_temp)):
												 if ((boardId == inserts_temp[j][3]) and (lostring == inserts_temp[j][7]) and 
													(lostringvalue != inserts_temp[j][9]) and (lostring is not None) and (winnings>0) and
													 (streetId == inserts_temp[j][2]) and (hand.dbid_pids[player[1]] != inserts_temp[j][1])):
													 loappend = ' - lower kicker'
													 if lostringvalue < inserts_temp[j][9]:
														 lostring += loappend
													 else:
														 if loappend not in inserts_temp[j][5] and inserts_temp[k][10]>0:
															 inserts_temp[j][5] += loappend
									 if histring:
										 histring = self.getHandString('hi', histring, hicards, best_hi)
										 histringvalue = pokereval.best_hand_value("hi", cards, bcards)
										 winnings = self.handsplayers[player[1]]['winnings']
										 histringold = histring
										 if street == last:
											 for k in range(len(inserts_temp)):
												 if ((boardId == inserts_temp[k][3]) and (histring == inserts_temp[k][6]) and
													(histringvalue != inserts_temp[k][8]) and (histring is not None) and (winnings>0) and
													(streetId == inserts_temp[k][2]) and (hand.dbid_pids[player[1]] != inserts_temp[k][1])
													and ('flush' not in histring) and ('straight' not in histring) and ('full house' not in histring)):
													 hiappend = ' - higher kicker'
													 if histringvalue > inserts_temp[k][8]:
														 histring += hiappend
													 else:
														 if hiappend not in inserts_temp[k][4] and inserts_temp[k][10]>0: 
															 inserts_temp[k][4] += hiappend
								inserts_temp.append( [hand.dbid_hands,
													  hand.dbid_pids[player[1]],
													  streetId,
													  boardId,
													  histring,
													  lostring,
													  histringold,
													  lostringold,
													  histringvalue,
													  lostringvalue,
													  winnings
													  ] )
				elif (self.handsplayers[player[1]]['sawShowdown']):
					if game[0]=='stud': streetId = 4
					if game[0]=='draw': streetId = 3
					if player[1] in hand.showdownStrings:
						lostring = hand.showdownStrings[player[1]]
					else:
						lostring = ''
					self.handsstove.append( [  
									   hand.dbid_hands,
									   hand.dbid_pids[player[1]],
									   streetId,
									   0,
									   histring,
									   lostring,
									   0
									] )
		self.handsstove += [t[:6] + [0] for t in inserts_temp]
		startstreet = None
		for pot, players in hand.pot.pots:
			players = [p for p in players]
			for street in allInStreets:
				board = boards[street]
				tid = Card.streets[game[0]][street]
				for n in range(len(board['board'])):
					if len(board['board']) > 1: 
						bid = n + 1
						portion = 2
					else: 
						bid = n
						portion = 1
					if board['allin']:
						if len([p for p in players
								if p in holecards 
								and u'0x' not in holecards[p]['cards'][n] 
								and 'Nu' not in holecards[p]['cards'][n]]) > 0:
							if not startstreet: startstreet = street
							bcards = [str(b) for b in board['board'][n]]
							b = bcards + (5 - len(board['board'][n])) * ['__']
							holeshow = [holecards[p]['hole'] for p in players 
										if self.handsplayers[p]['sawShowdown'] 
										and u'0x' not in holecards[p]['cards'][n]
										and 'Nu' not in holecards[p]['cards'][n]]
							if len(holeshow)> 1:
								evs = pokereval.poker_eval(game = game[1]
														  ,iterations = Card.iter[tid]
														  ,pockets = holeshow
														  ,dead = []
														  ,board = b)
								equities = [e['ev'] for e in evs['eval']]
							else:
								equities = [1000]
							for i in range(len(equities)):
								for j in self.handsstove:
									p = players[i]
									pid = hand.dbid_pids[p]
									if ((j[1] == pid) and (j[2] == tid) and (j[3] == bid)):
										if len(players) == len(hand.pot.contenders): j[6] = equities[i]
										if street == startstreet and hand.gametype['type'] == 'ring':
											rake = (hand.rake * (pot/hand.totalpot))
											holecards[p]['eq'] += int(((100*pot - 100*rake) * Decimal(equities[i])/1000)/portion)
											holecards[p]['committed'] = int(((100*hand.pot.committed[p]) + (100*hand.pot.common[p]))/portion)
											
		for p in holeplayers:
			if holecards[p]['committed'] != 0: 
				self.handsplayers[p]['allInEV'] = holecards[p]['eq'] - holecards[p]['committed']
			  
	def getHandString(self, type, string, cards, best):
		if best[0] == 'Nothing':
			string, cards = None, None
		elif best[0] == 'NoPair':
			if type == 'lo':
				string = cards[0]+','+cards[1]+','+cards[2]+','+cards[3]+','+cards[4]
			else:
				highcard = Card.names[cards[0][0]][0]
				string = string % highcard
		elif best[0] == 'OnePair':
			pair = Card.names[cards[0][0]][1]
			string = string % pair
		elif best[0] == 'TwoPair':
			hipair = Card.names[cards[0][0]][1]
			pair = Card.names[cards[2][0]][1]
			pairs = _("%s and %s") % (hipair, pair)
			string = string % pairs
		elif best[0] == 'Trips':
			threeoak = Card.names[cards[0][0]][1]
			string = string % threeoak
		elif best[0] == 'Straight':
			straight = Card.names[cards[0][0]][0] + " " + _("high")
			string = string % straight
		elif best[0] == 'Flush':
			flush = Card.names[cards[0][0]][0] + " " + _("high")
			string = string % flush
		elif best[0] == 'FlHouse':
			threeoak = Card.names[cards[0][0]][1]
			pair	 = Card.names[cards[3][0]][1]
			full	 = _("%s full of %s") % (threeoak, pair)
			string = string % full
		elif best[0] == 'Quads':
			four = Card.names[cards[0][0]][1]
			string = string % four
		elif best[0] == 'StFlush':
			flush = Card.names[cards[0][0]][0] + " " + _("high")
			string = string % flush
			if string[0] in ('As', 'Ad', 'Ah', 'Ac'):
				string = _('a Royal Flush')
		return string
	def setPositions(self, hand):
		actions = hand.actions[hand.holeStreets[0]]
		players = self.pfbao(actions)
		sb, bb, bi = False, False, False
		if hand.gametype['base'] == 'stud':
			bi = [x[0] for x in hand.actions[hand.actionStreets[1]] if x[1] == 'bringin']
		else:
			bb = [x[0] for x in hand.actions[hand.actionStreets[0]] if x[1] == 'big blind']
			sb = [x[0] for x in hand.actions[hand.actionStreets[0]] if x[1] == 'small blind']
		if bb:
			self.handsplayers[bb[0]]['position'] = 'B'
			if bb[0] in players:  players.remove(bb[0])
		if sb:
			self.handsplayers[sb[0]]['position'] = 'S'
			if sb[0] in players:  players.remove(sb[0])
		if bi:
			self.handsplayers[bi[0]]['position'] = 'S'
			if bi[0] in players:  players.remove(bi[0])
		for i,player in enumerate(reversed(players)):
			self.handsplayers[player]['position'] = i
	def assembleHudCache(self, hand):
		pass
	def vpip(self, hand):
		vpipers = set()
		for act in hand.actions[hand.actionStreets[1]]:
			if act[1] in ('calls','bets', 'raises', 'completes'):
				vpipers.add(act[0])
		self.hands['playersVpi'] = len(vpipers)
		for player in hand.players:
			if player[1] in vpipers:
				self.handsplayers[player[1]]['street0VPI'] = True
			else:
				self.handsplayers[player[1]]['street0VPI'] = False
	def playersAtStreetX(self, hand):
		self.hands['playersAtStreet1']  = 0
		self.hands['playersAtStreet2']  = 0
		self.hands['playersAtStreet3']  = 0
		self.hands['playersAtStreet4']  = 0
		self.hands['playersAtShowdown'] = 0
		p_in = set([x[0] for x in hand.actions[hand.actionStreets[1]]])
		for (i, street) in enumerate(hand.actionStreets):
			if (i-1) in (1,2,3,4):
				self.hands['playersAtStreet%d' % (i-1)] = len(p_in)
				for player_with_cards in p_in:
					self.handsplayers[player_with_cards]['street%sSeen' % (i-1)] = True
			p_in = p_in - self.pfba(actions, l=('folds',))
		for showdown_player in p_in:
			self.handsplayers[showdown_player]['sawShowdown'] = True
	def streetXRaises(self, hand):
		for i in range(5): self.hands['street%dRaises' % i] = 0
		for (i, street) in enumerate(hand.actionStreets[1:]):
			self.hands['street%dRaises' % i] = len(filter( lambda action: action[1] in ('raises','bets'), hand.actions[street]))
	def calcSteals(self, hand):
		steal_attempt = False
		raised = False
		steal_positions = (1, 0, 'S')
		if hand.gametype['base'] == 'stud':
			steal_positions = (2, 1, 0)
		for action in hand.actions[hand.actionStreets[1]]:
			pname, act = action[0], action[1]
			posn = self.handsplayers[pname]['position']
			if posn == 'B':
				if steal_attempt:
					self.handsplayers[pname]['foldBbToStealChance'] = True
					self.handsplayers[pname]['raiseToStealChance'] = True
					self.handsplayers[pname]['foldedBbToSteal'] = act == 'folds'
					self.handsplayers[pname]['raiseToStealDone'] = act == 'raises'
					self.handsplayers[stealer]['success_Steal'] = act == 'folds'
				break
			elif posn == 'S':
				self.handsplayers[pname]['raiseToStealChance'] = steal_attempt
				self.handsplayers[pname]['foldSbToStealChance'] = steal_attempt
				self.handsplayers[pname]['foldedSbToSteal'] = steal_attempt and act == 'folds'
				self.handsplayers[pname]['raiseToStealDone'] = steal_attempt and act == 'raises'
			if steal_attempt and act != 'folds':
				break
			if not steal_attempt and not raised and not act in ('bringin'):
				self.handsplayers[pname]['raiseFirstInChance'] = True
				if act in ('bets', 'raises', 'completes'):
					self.handsplayers[pname]['raisedFirstIn'] = True
					raised = True
					if posn in steal_positions:
						steal_attempt = True
						stealer = pname
				if act == 'calls':
					break
			
			if posn not in steal_positions and act not in ('folds', 'bringin'):
				break
	def calc34BetStreet0(self, hand):
		bet_level = 1
		squeeze_chance = False
		for action in hand.actions[hand.actionStreets[1]]:
			pname, act, aggr = action[0], action[1], action[1] in ('raises', 'bets')
			if bet_level == 1:
				if aggr:
					first_agressor = pname
					bet_level += 1
				continue
			elif bet_level == 2:
				self.handsplayers[pname]['street0_3BChance'] = True
				self.handsplayers[pname]['street0_SqueezeChance'] = squeeze_chance
				if not squeeze_chance and act == 'calls':
					squeeze_chance = True
					continue
				if aggr:
					self.handsplayers[pname]['street0_3BDone'] = True
					self.handsplayers[pname]['street0_SqueezeDone'] = squeeze_chance
					second_agressor = pname
					bet_level += 1
				continue
			elif bet_level == 3:
				if pname == first_agressor:
					self.handsplayers[pname]['street0_4BChance'] = True
					self.handsplayers[pname]['street0_FoldTo3BChance'] = True
					if aggr:
						self.handsplayers[pname]['street0_4BDone'] = True
						bet_level += 1
					elif act == 'folds':
						self.handsplayers[pname]['street0_FoldTo3BDone'] = True
						break
				else:
					self.handsplayers[pname]['street0_C4BChance'] = True
					if aggr:
						self.handsplayers[pname]['street0_C4BDone'] = True
						bet_level += 1
				continue
			elif bet_level == 4:
				if pname != first_agressor: 
					self.handsplayers[pname]['street0_FoldTo4BChance'] = True
					if act == 'folds':
						self.handsplayers[pname]['street0_FoldTo4BDone'] = True
	def calcCBets(self, hand):
		for i, street in enumerate(hand.actionStreets[2:]):
			name = self.lastBetOrRaiser(hand.actionStreets[i+1])
			if name:
				chance = self.noBetsBefore(hand.actionStreets[i+2], name)
				if chance == True:
					self.handsplayers[name]['street%dCBChance' % (i+1)] = True
					self.handsplayers[name]['street%dCBDone' % (i+1)] = self.betStreet(hand.actionStreets[i+2], name)
					if self.handsplayers[name]['street%dCBDone' % (i+1)]:
						for pname, folds in self.foldTofirstsBetOrRaiser(street, name).iteritems():
							self.handsplayers[pname]['foldToStreet%sCBChance' % (i+1)] = True
							self.handsplayers[pname]['foldToStreet%sCBDone' % (i+1)] = folds
	def calcCalledRaiseStreet0(self, hand):
		if hand.gametype['base'] <> 'hold':
			return
 
		fast_forward = True
		for tupleread in hand.actions[hand.actionStreets[1]]:
			action = tupleread[1]
			if fast_forward:
				if action == 'raises':
					fast_forward = False
			else:
				player = tupleread[0]
				self.handsplayers[player]['street0CalledRaiseChance'] += 1
				if action == 'calls':
					self.handsplayers[player]['street0CalledRaiseDone'] += 1
					fast_forward = True
	def calcCheckCallRaise(self, hand):
		for i, street in enumerate(hand.actionStreets[2:]):
			actions = hand.actions[hand.actionStreets[i+1]]
			checkers = set()
			initial_raiser = None
			for action in actions:
				pname, act = action[0], action[1]
				if act in ('bets', 'raises') and initial_raiser is None:
					initial_raiser = pname
				elif act == 'checks' and initial_raiser is None:
					checkers.add(pname)
				elif initial_raiser is not None and pname in checkers:
					self.handsplayers[pname]['street%dCheckCallRaiseChance' % (i+1)] = True
					self.handsplayers[pname]['street%dCheckCallRaiseDone' % (i+1)] = act!='folds'
	def aggr(self, hand, i):
		aggrers = set()
		others = set()
		firstAggrMade=False
		for act in hand.actions[hand.actionStreets[i+1]]:
			if firstAggrMade:
				others.add(act[0])
			if act[1] in ('completes', 'bets', 'raises'):
				aggrers.add(act[0])
				firstAggrMade=True
		for player in hand.players:
			if player[1] in aggrers:
				self.handsplayers[player[1]]['street%sAggr' % i] = True
			else:
				self.handsplayers[player[1]]['street%sAggr' % i] = False
				
		if len(aggrers)>0 and i>0:
			for playername in others:
				self.handsplayers[playername]['otherRaisedStreet%s' % i] = True
		if i > 0 and len(aggrers) > 0:
			for playername in others:
				self.handsplayers[playername]['otherRaisedStreet%s' % i] = True
	def calls(self, hand, i):
		callers = []
		for act in hand.actions[hand.actionStreets[i+1]]:
			if act[1] in ('calls'):
				self.handsplayers[act[0]]['street%sCalls' % i] = 1 + self.handsplayers[act[0]]['street%sCalls' % i]
	def bets(self, hand, i):
		for act in hand.actions[hand.actionStreets[i+1]]:
			if act[1] in ('bets'):
				self.handsplayers[act[0]]['street%sBets' % i] = 1 + self.handsplayers[act[0]]['street%sBets' % i]
		
	def folds(self, hand, i):
		for act in hand.actions[hand.actionStreets[i+1]]:
			if act[1] in ('folds'):
				if self.handsplayers[act[0]]['otherRaisedStreet%s' % i] == True:
					self.handsplayers[act[0]]['foldToOtherRaisedStreet%s' % i] = True
	def countPlayers(self, hand):
		pass
	def pfba(self, actions, f=None, l=None):
		players = set()
		for action in actions:
			if l is not None and action[1] not in l: continue
			if f is not None and action[1] in f: continue
			players.add(action[0])
		return players
	def pfbao(self, actions, f=None, l=None, unique=True):
		seen = {}
		players = []
		for action in actions:
			if l is not None and action[1] not in l: continue
			if f is not None and action[1] in f: continue
			if action[0] in seen and unique: continue
			seen[action[0]] = 1
			players.append(action[0])
		return players
	def firstsBetOrRaiser(self, actions):
		for act in actions:
			if act[1] in ('bets', 'raises'):
				return act[0]
		return None
	
	def foldTofirstsBetOrRaiser(self, street, aggressor):
		i, players = 0, {}
		for act in self.hand.actions[street]:
			if i>1: break
			if act[0] != aggressor:
				if act[1] == 'folds':
					players[act[0]] = True
				else:
					players[act[0]] = False
				if act[1] == 'raises': break
			else:
				i+=1
		return players
	def lastBetOrRaiser(self, street):
		lastbet = None
		for act in self.hand.actions[street]:
			if act[1] in ('bets', 'raises'):
				lastbet = act[0]
		return lastbet
	def noBetsBefore(self, street, player):
		betOrRaise = False
		for act in self.hand.actions[street]:
			if act[0] == player:
				betOrRaise = True
				break
			if act[1] in ('bets', 'raises'):
				break
		return betOrRaise
	def betStreet(self, street, player):
		betOrRaise = False
		for act in self.hand.actions[street]:
			if act[0] == player:
				if act[1] in ('bets', 'raises'):
					betOrRaise = True
				else:
					pass
				break
		return betOrRaise