_ = L10n.get_translation()
class Entraction(HandHistoryConverter):
	sitename = "Entraction"
	filetype = "text"
	codepage = ("utf8", "cp1252")
	siteId   = 18
	
	sym = {'USD': "\$", 'CAD': "\$", 'T$': "", "EUR": "\xe2\x82\xac", "GBP": "\xa3", "play": ""}
	substitutions = {
					 'LEGAL_ISO' : "EUR|",
						   'PLYR': r'(?P<PNAME>.+?)',
							'CUR': u"(\$|\xe2\x82\xac|\u20ac|)",
							'NUM': u".,\d",
					}
	limits = { 'No Limit':'nl', 'Pot Limit':'pl', 'Limit':'fl', 'LIMIT':'fl' }
	games = {
							  "Hold'em" : ('hold','holdem'), 
						   'Omaha High' : ('hold','omahahi'),
			   }
	re_GameInfo	 = re.compile(u % substitutions, re.MULTILINE|re.VERBOSE)
	re_PlayerInfo   = re.compile(u
			% substitutions, re.MULTILINE|re.VERBOSE)
	re_HandInfo	 = re.compile( % substitutions, re.MULTILINE|re.VERBOSE)
	re_SplitHands   = re.compile(r"\n\n(?=Game
	re_Button	   = re.compile('^Dealer:\s+(?P<PNAME>.*)$', re.MULTILINE)
	re_Board		= re.compile(r"(?P<CARDS>.+)$")
	re_GameEnds	 = re.compile(r"Game\sended\s(?P<Y>[0-9]{4})-(?P<M>[0-9]{2})-(?P<D>[0-9]{2})\s(?P<H>[0-9]+):(?P<MIN>[0-9]+):(?P<S>[0-9]+)", re.MULTILINE)
	re_DateTime	 = re.compile(, re.MULTILINE)
	re_PostSB	   = re.compile(r"^Small Blind: {16}(?P<PNAME>.*)\s+\((?P<SB>[%(NUM)s]+)\)" % substitutions, re.MULTILINE)
	re_PostBB	   = re.compile(r"^Big Blind: {18}(?P<PNAME>.*)\s+\((?P<BB>[%(NUM)s]+)\)" % substitutions, re.MULTILINE)
	re_PostBoth	 = re.compile(r"^Small \+ Big Blind: {10}(?P<PNAME>.*)\s+\((?P<SBBB>[%(NUM)s]+)\)" % substitutions, re.MULTILINE)
	re_PostSecondSB = re.compile(r"^Blind out of turn: {10}(?P<PNAME>.*)\s+\((?P<SB>[%(NUM)s]+)\)" % substitutions, re.MULTILINE)
	re_Antes		= re.compile(r"^%(PLYR)s: posts the ante %(CUR)s(?P<ANTE>[%(NUM)s]+)" % substitutions, re.MULTILINE)
	re_BringIn	  = re.compile(r"^%(PLYR)s: brings[- ]in( low|) for %(CUR)s(?P<BRINGIN>[%(NUM)s]+)" % substitutions, re.MULTILINE)
	re_HeroCards	= re.compile(r"^Dealt to %(PLYR)s(?: \[(?P<OLDCARDS>.+?)\])?( \[(?P<NEWCARDS>.+?)\])" % substitutions, re.MULTILINE)
	re_Action		   = re.compile(r
						 %  substitutions, re.MULTILINE|re.VERBOSE)
	re_ShowdownAction   = re.compile(r"^%s: shows \[(?P<CARDS>.*)\]" % substitutions['PLYR'], re.MULTILINE)
	re_ShownCards	   = re.compile("^Seat (?P<SEAT>[0-9]+): %(PLYR)s (\(.*\) )?(?P<SHOWED>showed|mucked) \[(?P<CARDS>.*)\]( and won \([%(NUM)s]+\) with (?P<STRING>.*))?" % substitutions, re.MULTILINE)
	re_CollectPot	   = re.compile(r"%(PLYR)s\swins:\s+(%(LEGAL_ISO)s)\s(?P<POT>[%(NUM)s]+)" %  substitutions, re.MULTILINE)
	re_WinningRankOne   = re.compile(u"^%(PLYR)s wins the tournament and receives %(CUR)s(?P<AMT>[%(NUM)s]+) - congratulations!$" %  substitutions, re.MULTILINE)
	re_WinningRankOther = re.compile(u"^%(PLYR)s finished the tournament in (?P<RANK>[0-9]+)(st|nd|rd|th) place and received %(CUR)s(?P<AMT>[%(NUM)s]+)\.$" %  substitutions, re.MULTILINE)
	re_RankOther		= re.compile(u"^%(PLYR)s finished the tournament in (?P<RANK>[0-9]+)(st|nd|rd|th) place$" %  substitutions, re.MULTILINE)
	def compilePlayerRegexs(self,  hand):
		pass
	def readSupportedGames(self):
		return [["ring", "hold", "nl"],
				["ring", "hold", "pl"],
				["ring", "hold", "fl"],
				]
	def determineGameType(self, handText):
		info = {}
		m = self.re_GameInfo.search(handText)
		if not m:
			tmp = handText[0:200]
			log.error(_("EntractionToFpdb.determineGameType: '%s'") % tmp)
			raise FpdbParseError
		mg = m.groupdict()
		if 'LIMIT' in mg:
			info['limitType'] = self.limits[mg['LIMIT']]
		if 'GAME' in mg:
			(info['base'], info['category']) = self.games[mg['GAME']]
		if 'SB' in mg:
			info['sb'] = mg['SB']
		if 'BB' in mg:
			info['bb'] = mg['BB']
		if 'CURRENCY' in mg:
			info['currency'] = mg['CURRENCY']
		info['type'] = 'ring'
	def readHandInfo(self, hand):
		info = {}
		m2 = self.re_GameInfo.search(hand.handText)
		m3 = self.re_GameEnds.search(hand.handText)
		m  = self.re_HandInfo.search(hand.handText)
		if m is None or m2 is None or m3 is None:
			tmp = hand.handText[0:200]
			log.error(_("EntractionToFpdb.readHandInfo: '%s'") % tmp)
			raise FpdbParseError
		info.update(m.groupdict())
		info.update(m2.groupdict())
		info.update(m3.groupdict())
		for key in info:
			if key == 'Y':
				datetimestr = "%s/%s/%s %s:%s:%s" % (info['Y'], info['M'],info['D'],info['H'],info['MIN'],info['S'])
				hand.startTime = datetime.datetime.strptime(datetimestr, "%Y/%m/%d %H:%M:%S")
			if key == 'HID':
				hand.handid = info[key]
			if key == 'TABLE':
				hand.tablename = info[key]
			if key == 'BUTTON':
				hand.buttonpos = info[key]
			if key == 'MAX' and info[key] != None:
				hand.maxseats = int(info[key])
	
	def readButton(self, hand):
		m = self.re_Button.search(hand.handText)
		if m:
			pass
		else:
			log.info('readButton: ' + _('not found'))
	def readPlayerStacks(self, hand):
		log.debug("readPlayerStacks")
		m = self.re_PlayerInfo.finditer(hand.handText)
		for a in m:
			name = a.group('PNAME').strip()
			hand.addPlayer(int(a.group('SEAT')), name, a.group('CASH'))
	def markStreets(self, hand):
		if hand.gametype['base'] in ("hold"):
			m =  re.search(r"Dealer:(?P<PREFLOP>.+(?=Flop {24})|.+)"
					   r"(Flop {24}(?P<FLOP>\S\S - \S\S - \S\S.+(?=Turn {24})|.+))?"
					   r"(Turn {24}\S\S - \S\S - \S\S - (?P<TURN>\S\S.+(?=River {23})|.+))?"
					   r"(River {23}\S\S - \S\S - \S\S - \S\S - (?P<RIVER>\S\S.+))?", hand.handText,re.DOTALL)
		hand.addStreets(m)
	def readCommunityCards(self, hand, street):
		pass
	def readAntes(self, hand):
		pass
	
	def readBringIn(self, hand):
		pass
		
	def readBlinds(self, hand):
		for a in self.re_PostSB.finditer(hand.handText):
			name = a.group('PNAME').strip()
			blind = self.clearMoneyString(a.group('SB'))
			hand.addBlind(name, 'small blind', blind)
		for a in self.re_PostBB.finditer(hand.handText):
			name = a.group('PNAME').strip()
			blind = self.clearMoneyString(a.group('BB'))
			hand.addBlind(name, 'big blind', blind)
		for a in self.re_PostBoth.finditer(hand.handText):
			name = a.group('PNAME').strip()
			hand.addBlind(name, 'both', a.group('SBBB'))
		for a in self.re_PostSecondSB.finditer(hand.handText):
			name = a.group('PNAME').strip()
			blind = self.clearMoneyString(a.group('SB'))
			hand.addBlind(name, 'big blind', blind)
	def readHeroCards(self, hand):
		pass
	def readAction(self, hand, street):
		m = self.re_Action.finditer(hand.streets[street])
		for action in m:
			acts = action.groupdict()
			if action.group('ATYPE') == 'Folds':
				hand.addFold( street, action.group('PNAME'))
			elif action.group('ATYPE') == 'Check':
				hand.addCheck( street, action.group('PNAME'))
			elif action.group('ATYPE') == 'Call':
				hand.addCall( street, action.group('PNAME'), self.clearMoneyString(action.group('BET')) )
			elif action.group('ATYPE') == 'Raise':
				hand.addCallandRaise( street, action.group('PNAME'), self.clearMoneyString(action.group('BET')) )
			elif action.group('ATYPE') == 'Bet':
				hand.addBet( street, action.group('PNAME'), self.clearMoneyString(action.group('BET')) )
			elif action.group('ATYPE') == 'All-In':
				hand.addAllIn(street, action.group('PNAME'), self.clearMoneyString(action.group('BET')))
			else:
				print (_("DEBUG:") + " " + _("Unimplemented %s: '%s' '%s'") % ("readAction", action.group('PNAME'), action.group('ATYPE')))
	def readShowdownActions(self, hand):
		pass
	def readCollectPot(self,hand):
		for m in self.re_CollectPot.finditer(hand.handText):
			hand.addCollectPot(player=m.group('PNAME'),pot=self.clearMoneyString(m.group('POT')))
	def readShownCards(self,hand):
		pass