_ = L10n.get_translation()
class Everest(HandHistoryConverter):
	sitename = "Everest"
	filetype = "text"
	codepage = "utf8"
	siteId   = 16
	copyGameHeader = True
	substitutions = {
						'LS' : u"\$|\xe2\x82\xac|\u20ac|",
					   'TAB' : u"-\u2013'\s\da-zA-Z",
					   'NUM' : u"\d,\.",
					}
	re_SplitHands = re.compile(r'</HAND>\n+(?=<HAND)')
	re_TailSplitHands = re.compile(r'(</game>)')
	re_GameInfo = re.compile(u % substitutions, re.VERBOSE|re.MULTILINE)
	re_HandInfo = re.compile(r'<HAND time="(?P<DATETIME>[0-9]+)" id="(?P<HID>[0-9]+)" index="\d+" blinds="((?P<SB>[%(NUM)s]+) (?P<CURRENCY>[%(LS)s])/(?P<BB>[%(NUM)s]+))' % substitutions, re.MULTILINE)
	re_Button = re.compile(r'<DEALER position="(?P<BUTTON>[0-9]+)"\/>')
	re_PlayerInfo = re.compile(r'<SEAT position="(?P<SEAT>[0-9]+)" name="(?P<PNAME>.+)" balance="(?P<CASH>[.0-9]+)"/>', re.MULTILINE)
	re_Board = re.compile(r'(?P<CARDS>.+)<\/COMMUNITY>', re.MULTILINE)
	re_PostXB = re.compile(r'<BLIND position="(?P<PSEAT>[0-9]+)" amount="(?P<XB>[0-9]+)" penalty="(?P<PENALTY>[0-9]+)"\/>', re.MULTILINE)
	re_HeroCards = re.compile(r'<cards type="HOLE" cards="(?P<CARDS>.+)" player="(?P<PSEAT>[0-9])"', re.MULTILINE)
	re_Action = re.compile(r'<(?P<ATYPE>FOLD|BET) position="(?P<PSEAT>[0-9])"( amount="(?P<BET>[.0-9]+)")?\/>', re.MULTILINE)
	re_ShowdownAction = re.compile(r'<cards type="SHOWN" cards="(?P<CARDS>..,..)" player="(?P<PSEAT>[0-9])"/>', re.MULTILINE)
	re_CollectPot = re.compile(r'<WIN position="(?P<PSEAT>[0-9])" amount="(?P<POT>[.0-9]+)" pot="[0-9]+"', re.MULTILINE)
	re_SitsOut = re.compile(r'<event sequence="[0-9]+" type="SIT_OUT" player="(?P<PSEAT>[0-9])"/>', re.MULTILINE)
	re_ShownCards = re.compile(r'<cards type="(SHOWN|MUCKED)" cards="(?P<CARDS>..,..)" player="(?P<PSEAT>[0-9])"/>', re.MULTILINE)
	def compilePlayerRegexs(self, hand):
		pass
	def playerNameFromSeatNo(self, seatNo, hand):
		for p in hand.players:
			if p[0] == seatNo:
				return p[1]
	def readSupportedGames(self):
		return [
				["ring", "hold", "nl"],
				["ring", "hold", "pl"],
			   ]
	def determineGameType(self, handText):
		m = self.re_GameInfo.search(handText)
		m2 = self.re_HandInfo.search(handText)
		if not m:
			try:
				self.info
				return self.info
			except AttributeError:
				tmp = handText[0:200]
				log.error(_("EverestToFpdb.determineGameType: Unable to recognise gametype
				raise FpdbParseError
		if not m2:
			tmp = handText[0:200]
			log.error(_("EverestToFpdb.determineGameType: Unable to recognise hand info
			raise FpdbParseError
		self.info = {}
		mg = m.groupdict()
		mg.update(m2.groupdict())
		limits = { 'no-limit':'nl', 'limit':'fl', 'pot-limit':'pl' }
		games = {
					'hold-em' : ('hold','holdem'),
		 'Holdem Tournament' : ('hold','holdem'),
				  'omaha-hi' : ('hold','omahahi'),
				}
		if 'LIMIT' in mg:
			self.info['limitType'] = limits[mg['LIMIT']]
		if 'GAME' in mg:
			(self.info['base'], self.info['category']) = games[mg['GAME']]
		if 'SB' in mg:
			sb = mg['SB'].replace(',','.')
			self.info['sb'] = sb
		if 'BB' in mg:
			bb = mg['BB'].replace(',','.')
			self.info['bb'] = bb
		self.info['type'] = 'ring'
		if mg['CURRENCY'] == u'\u20ac':
			self.info['currency'] = 'EUR'
		self.info['TABLENAME'] = mg['TABLE']
		return self.info
	def readHandInfo(self, hand):
		m = self.re_HandInfo.search(hand.handText)
		if m is None:
			tmp = hand.handText[0:200]
			log.error(_("EverestToFpdb.readHandInfo: '%s'") % tmp)
			raise FpdbParseError
		hand.handid = m.group('HID')
		hand.tablename = self.info['TABLENAME']
		hand.maxseats = None
		hand.startTime = datetime.datetime.strptime('201102091158', '%Y%m%d%H%M')
	def readPlayerStacks(self, hand):
		m = self.re_PlayerInfo.finditer(hand.handText)
		for a in m:
			hand.addPlayer(a.group('SEAT'), a.group('PNAME'), a.group('CASH'))
	def markStreets(self, hand):
		
		m =  re.search(r"<DEALER (?P<PREFLOP>.+?(?=<COMMUNITY>)|.+)"
					   r"(<COMMUNITY>(?P<FLOP>\S\S, \S\S, \S\S<\/COMMUNITY>.+?(?=<COMMUNITY>)|.+))?"
					   r"(<COMMUNITY>(?P<TURN>\S\S<\/COMMUNITY>.+?(?=<COMMUNITY>)|.+))?"
					   r"(<COMMUNITY>(?P<RIVER>\S\S<\/COMMUNITY>.+))?", hand.handText,re.DOTALL)
		hand.addStreets(m)
	def readCommunityCards(self, hand, street):
		m = self.re_Board.search(hand.streets[street])
		if street == 'FLOP':
			hand.setCommunityCards(street, m.group('CARDS').split(','))
		elif street in ('TURN','RIVER'):
			hand.setCommunityCards(street, [m.group('CARDS').split(',')[-1]])
	def readAntes(self, hand):
		pass
	def readBringIn(self, hand):
		pass
	def readBlinds(self, hand):
		for a in self.re_PostXB.finditer(hand.handText):
			amount = "%.2f" % float(float(a.group('XB'))/100)
			if Decimal(a.group('XB'))/100 == Decimal(self.info['sb']):
				hand.addBlind(self.playerNameFromSeatNo(a.group('PSEAT'), hand),'small blind', amount)
			elif Decimal(a.group('XB'))/100 == Decimal(self.info['bb']):
				hand.addBlind(self.playerNameFromSeatNo(a.group('PSEAT'), hand),'big blind', amount)
	def readButton(self, hand):
		hand.buttonpos = int(self.re_Button.search(hand.handText).group('BUTTON'))
	def readHeroCards(self, hand):
		m = self.re_HeroCards.search(hand.handText)
		if m:
			hand.hero = self.playerNameFromSeatNo(m.group('PSEAT'), hand)
			cards = m.group('CARDS').split(',')
			hand.addHoleCards('PREFLOP', hand.hero, closed=cards, shown=False,
							  mucked=False, dealt=True)
	def readAction(self, hand, street):
		m = self.re_Action.finditer(hand.streets[street])
		curr_pot = Decimal('0')
		for action in m:
			player = self.playerNameFromSeatNo(action.group('PSEAT'), hand)
			if action.group('ATYPE') == 'BET':
				amount = Decimal(action.group('BET'))
				amountstr = "%.2f" % float(amount/100)
				if action.group('BET') == '0':
					hand.addCheck(street, player)
				elif amount > 0 and curr_pot == 0:
					curr_pot = amount
					hand.addBet(street, player, amountstr)
				elif Decimal(action.group('BET')) > 0 and curr_pot > 0:
					if amount > curr_pot:
						curr_pot = amount
						hand.addCallandRaise(street, player, amountstr)
					elif amount <= curr_pot:
						hand.addCall(street, player, amountstr)
			elif action.group('ATYPE') in ('FOLD', 'SIT_OUT'):
				hand.addFold(street, player)
			else:
				print (_("Unimplemented %s: '%s' '%s'") % ("readAction", action.group('PSEAT'), action.group('ATYPE')))
				log.debug(_("Unimplemented %s: '%s' '%s'") % ("readAction", action.group('PSEAT'), action.group('ATYPE')))
	def readShowdownActions(self, hand):
		for shows in self.re_ShowdownAction.finditer(hand.handText):
			cards = shows.group('CARDS').split(',')
			hand.addShownCards(cards,
							   self.playerNameFromSeatNo(shows.group('PSEAT'),
														 hand))
	def readCollectPot(self, hand):
		for m in self.re_CollectPot.finditer(hand.handText):
			player = self.playerNameFromSeatNo(m.group('PSEAT'), hand)
			amount = Decimal(m.group('POT'))
			amountstr = "%.2f" % float(amount/100)
			hand.addCollectPot(player, amountstr)
	def readShownCards(self, hand):
		for m in self.re_ShownCards.finditer(hand.handText):
			cards = m.group('CARDS').split(',')
			hand.addShownCards(cards=cards, player=self.playerNameFromSeatNo(m.group('PSEAT'), hand))