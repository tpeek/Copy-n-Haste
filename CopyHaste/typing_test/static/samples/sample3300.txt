_ = L10n.get_translation()
class Everleaf(HandHistoryConverter):
	sitename = 'Everleaf'
	filetype = "text"
	codepage = "cp1252"
	siteId   = 3
	
	substitutions = {
					 'LEGAL_ISO' : "USD|EUR|GBP|CAD|FPP",
							'LS' : u"\$|\u20AC|\xe2\x82\xac|\x80|",
						   'TAB' : u"-\u2013'\s\da-zA-Z
						   'NUM' : u".,\d",
					}
	re_SplitHands  = re.compile(r"\n\n\n+")
	re_TailSplitHands  = re.compile(r"(\n\n\n+)")
	re_GameInfo	= re.compile(ur"^(Blinds )? ?(?P<CURRENCY>[%(LS)s]?)(?P<SB>[%(NUM)s]+) ?/ ? ?[%(LS)s]?(?P<BB>[%(NUM)s]+) (?P<LIMIT>NL|PL|) ?(?P<GAME>(Hold\'em|Omaha|7\sCard\sStud))" % substitutions, re.MULTILINE)
	re_HandInfo	= re.compile(ur".*\n(.*
	re_Button	  = re.compile(ur"^Seat (?P<BUTTON>\d+) is the button$", re.MULTILINE)
	re_PlayerInfo  = re.compile(ur % substitutions, re.MULTILINE|re.VERBOSE)
	re_Board	   = re.compile(ur"\[ (?P<CARDS>.+) \]")
	re_TourneyInfoFromFilename = re.compile(ur".*TID_(?P<TOURNO>[0-9]+)-(?P<TABLE>[0-9]+).*\.txt")
	def compilePlayerRegexs(self, hand):
		players = set([player[1] for player in hand.players])
		if not players <= self.compiledPlayers:
			self.compiledPlayers = players
			player_re = "(?P<PNAME>" + "|".join(map(re.escape, players)) + ")"
			log.debug("player_re: "+ player_re)
			self.substitutions['PLAYERS'] = player_re
			
			self.re_PostSB		  = re.compile(ur"^%(PLAYERS)s: posts small blind \[ ?[%(LS)s]? (?P<SB>[%(NUM)s]+)\s.*\]$" % self.substitutions, re.MULTILINE)
			self.re_PostBB		  = re.compile(ur"^%(PLAYERS)s: posts big blind \[ ?[%(LS)s]? (?P<BB>[%(NUM)s]+)\s.*\]$" % self.substitutions, re.MULTILINE)
			self.re_PostBoth		= re.compile(ur"^%(PLAYERS)s: posts both blinds \[ ?[%(LS)s]? (?P<SBBB>[%(NUM)s]+)\s.*\]$" % self.substitutions, re.MULTILINE)
			self.re_Antes		   = re.compile(ur"^%(PLAYERS)s: posts ante \[ ?[%(LS)s]? (?P<ANTE>[%(NUM)s]+)\s.*\]$" % self.substitutions, re.MULTILINE)
			self.re_BringIn		 = re.compile(ur"^%(PLAYERS)s posts bring-in  ?[%(LS)s]? (?P<BRINGIN>[%(NUM)s]+)\." % self.substitutions, re.MULTILINE)
			self.re_HeroCards	   = re.compile(ur"^Dealt to %s \[ (?P<CARDS>.*) \]$" % player_re, re.MULTILINE)
			self.re_Action		  = re.compile(ur"^%(PLAYERS)s(?P<ATYPE>: bets| checks| raises| calls| folds)(\s\[(?: ?[%(LS)s]?) (?P<BET>[%(NUM)s]+)\s?(USD|EURO|EUR|Chips|)\])?" % self.substitutions, re.MULTILINE)
			self.re_ShowdownAction  = re.compile(ur"^%s (?P<SHOWED>shows|mucks) \[ (?P<CARDS>.*) \] (?P<STRING>.*)" % player_re, re.MULTILINE)
			self.re_CollectPot	  = re.compile(ur"^%(PLAYERS)s wins  ?(?: ?[%(LS)s]?)\s?(?P<POT>[%(NUM)s]+) (USD|EURO|EUR|chips)(.*?\[ (?P<CARDS>.*?) \])?" % self.substitutions, re.MULTILINE)
			self.re_SitsOut		 = re.compile(ur"^%s sits out" % player_re, re.MULTILINE)
	def readSupportedGames(self):
		return [
				["ring", "hold", "nl"],
				["ring", "hold", "pl"],
				["ring", "hold", "fl"],
				["ring", "stud", "fl"],
				["tour", "hold", "nl"],
				["tour", "hold", "fl"],
				["tour", "hold", "pl"]
			   ]
	def determineGameType(self, handText):
		info = {'type':'ring'}
		
		
		m = self.re_GameInfo.search(handText)
		if not m:
			tmp = handText[0:200]
			log.error(_("EverleafToFpdb.determineGameType: '%s'") % tmp)
			raise FpdbParseError
		mg = m.groupdict()
		limits = { 'NL':'nl', 'PL':'pl', '':'fl' }
		games = {
				  "Hold'em" : ('hold','holdem'),
					'Omaha' : ('hold','omahahi'),
					 'Razz' : ('stud','razz'),
			  '7 Card Stud' : ('stud','studhi')
			   }
		currencies = { u'€':'EUR', '$':'USD', '':'T$'}
		if 'LIMIT' in mg:
			info['limitType'] = limits[mg['LIMIT']]
		if 'GAME' in mg:
			(info['base'], info['category']) = games[mg['GAME']]
		if 'SB' in mg:
			info['sb'] = self.clearMoneyString(mg['SB'])
		if 'BB' in mg:
			info['bb'] = self.clearMoneyString(mg['BB'])
		if 'CURRENCY' in mg:
			info['currency'] = currencies[mg['CURRENCY']]
			if info['currency'] == 'T$':
				info['type'] = 'tour'
		return info
	def readHandInfo(self, hand):
		m = self.re_HandInfo.search(hand.handText)
		if(m == None):
			tmp = hand.handText[0:200]
			log.error(_("EverleafToFpdb.readHandInfo: '%s'") % tmp)
			raise FpdbParseError
		hand.handid =  m.group('HID')
		hand.tablename = m.group('TABLE')
		hand.maxseats = 4
		
		currencies = { u'€':'EUR', '$':'USD', '':'T$', None:'T$' }
		mg = m.groupdict()
		hand.gametype['currency'] = currencies[mg['CURRENCY']]
		t = self.re_TourneyInfoFromFilename.search(self.in_path)
		if t:
			tourno = t.group('TOURNO')
			hand.tourNo = tourno
			hand.tablename = t.group('TABLE')
			hand.buyin = 0
			hand.fee = 0
			hand.buyinCurrency = 'NA'
		hand.startTime = datetime.datetime.strptime(m.group('DATETIME'), "%Y/%m/%d - %H:%M:%S")
		return
	def readPlayerStacks(self, hand):
		m = self.re_PlayerInfo.finditer(hand.handText)
		for a in m:
			seatnum = int(a.group('SEAT'))
			hand.addPlayer(seatnum, a.group('PNAME'), a.group('CASH'))
			if seatnum > 8:
				hand.maxseats = 10
			elif seatnum > 6:
				hand.maxseats = 8
			elif seatnum > 4:
				hand.maxseats = 6
	def markStreets(self, hand):
		if hand.gametype['base'] == 'hold':
			m =  re.search(r"\*\* Dealing down cards \*\*(?P<PREFLOP>.+(?=\*\* Dealing Flop \*\*)|.+)"
					   r"(\*\* Dealing Flop \*\*(?P<FLOP> \[ \S\S, \S\S, \S\S \].+(?=\*\* Dealing Turn \*\*)|.+))?"
					   r"(\*\* Dealing Turn \*\*(?P<TURN> \[ \S\S \].+(?=\*\* Dealing River \*\*)|.+))?"
					   r"(\*\* Dealing River \*\*(?P<RIVER> \[ \S\S \].+))?", hand.handText,re.DOTALL)
		elif hand.gametype['base'] == 'stud':
			m =	 re.search(r"(?P<ANTES>.+(?=\*\* Dealing down cards \*\*)|.+)"
						   r"(\*\* Dealing down cards \*\*(?P<THIRD>.+(?=\*\*\*\* dealing 4th street \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing 4th street \*\*\*\*(?P<FOURTH>.+(?=\*\*\*\* dealing 5th street \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing 5th street \*\*\*\*(?P<FIFTH>.+(?=\*\*\*\* dealing 6th street \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing 6th street \*\*\*\*(?P<SIXTH>.+(?=\*\*\*\* dealing river \*\*\*\*)|.+))?"
						   r"(\*\*\*\* dealing river \*\*\*\*(?P<SEVENTH>.+))?", hand.handText,re.DOTALL)
		hand.addStreets(m)
	def readCommunityCards(self, hand, street):
		log.debug("readCommunityCards (%s)" % street)
		m = self.re_Board.search(hand.streets[street])
		cards = m.group('CARDS')
		cards = [card.strip() for card in cards.split(',')]
		hand.setCommunityCards(street=street, cards=cards)
	def readAntes(self, hand):
		log.debug(_("reading antes"))
		m = self.re_Antes.finditer(hand.handText)
		for player in m:
			log.debug("hand.addAnte(%s,%s)" %(player.group('PNAME'), player.group('ANTE')))
			hand.addAnte(player.group('PNAME'), self.clearMoneyString(player.group('ANTE')))
	def readBringIn(self, hand):
		m = self.re_BringIn.search(hand.handText,re.DOTALL)
		if m:
			log.debug("Player bringing in: %s for %s" %(m.group('PNAME'),  m.group('BRINGIN')))
			hand.addBringIn(m.group('PNAME'),  self.clearMoneyString(m.group('BRINGIN')))
		else:
			log.warning(_("No bringin found."))
	def readBlinds(self, hand):
		m = self.re_PostSB.search(hand.handText)
		if m is not None:
			hand.addBlind(m.group('PNAME'), 'small blind', self.clearMoneyString(m.group('SB')))
		else:
			log.debug(_("No small blind"))
			hand.addBlind(None, None, None)
		for a in self.re_PostBB.finditer(hand.handText):
			hand.addBlind(a.group('PNAME'), 'big blind', self.clearMoneyString(a.group('BB')))
		for a in self.re_PostBoth.finditer(hand.handText):
			hand.addBlind(a.group('PNAME'), 'both', self.clearMoneyString(a.group('SBBB')))
	def readButton(self, hand):
		hand.buttonpos = int(self.re_Button.search(hand.handText).group('BUTTON'))
	def readHeroCards(self, hand):
		m = self.re_HeroCards.search(hand.handText)
		if m:
			hand.hero = m.group('PNAME')
			cards = m.group('CARDS')
			cards = [card.strip() for card in cards.split(',')]
			hand.addHoleCards('PREFLOP', hand.hero, closed=cards, shown=False, mucked=False, dealt=True)
		else:
			hand.involved = False
	def readStudPlayerCards(self, hand, street):
		log.warning(_("%s cannot read all stud/razz hands yet.") % hand.sitename)
	def readAction(self, hand, street):
		log.debug("readAction (%s)" % street)
		m = self.re_Action.finditer(hand.streets[street])
		for action in m:
			log.debug("%s %s" % (action.group('ATYPE'), action.groupdict()))
			if action.group('ATYPE') == ' folds':
				hand.addFold( street, action.group('PNAME'))
			elif action.group('ATYPE') == ' checks':
				hand.addCheck( street, action.group('PNAME'))
			elif action.group('ATYPE') == ' calls':
				hand.addCall( street, action.group('PNAME'), action.group('BET') )
			elif action.group('ATYPE') == ' raises':
				hand.addCallandRaise( street, action.group('PNAME'), action.group('BET') )
			elif action.group('ATYPE') == ': bets':
				hand.addBet( street, action.group('PNAME'), action.group('BET') )
			elif action.group('ATYPE') == ' complete to':
				hand.addComplete( street, action.group('PNAME'), action.group('BET'))
			else:
				log.debug(_("Unimplemented %s: '%s' '%s'") % ("readAction", action.group('PNAME'), action.group('ATYPE')))
	def readShowdownActions(self, hand):
		log.debug("readShowdownActions")
		for shows in self.re_ShowdownAction.finditer(hand.handText):
			cards = shows.group('CARDS')
			cards = cards.split(', ')
			log.debug("readShowdownActions %s %s" % (cards, shows.group('PNAME')))
			hand.addShownCards(cards, shows.group('PNAME'))
	def readCollectPot(self,hand):
		for m in self.re_CollectPot.finditer(hand.handText):
			hand.addCollectPot(player=m.group('PNAME'),pot=m.group('POT'))
	def readShownCards(self,hand):
		for m in self.re_ShowdownAction.finditer(hand.handText):
			if m.group('CARDS') is not None:
				cards = m.group('CARDS')
				cards = cards.split(', ')
				string = m.group('STRING')
				player = m.group('PNAME')
				(shown, mucked) = (False, False)
				if m.group('SHOWED') == "showed": shown = True
				elif m.group('SHOWED') == "mucked": mucked = True
				
				log.debug("readShownCards %s cards=%s" % (player, cards))
				hand.addShownCards(cards=cards, player=player, shown=shown, mucked=mucked, string=string)
	@staticmethod
	def getTableTitleRe(type, table_name=None, tournament = None, table_number=None):
		if tournament:
			return re.escape("%s - Tournament ID: %s - " % (table_number, tournament))
		return re.escape("%s -" % (table_name))