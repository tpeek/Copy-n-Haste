debug = False
found_dependency_string = 'Found dependency'
no_dependency_string = 'No dependencies'
all_changed_string = 'Found dependency (all)'
MATCH_STATUS_MATCHES = 1
MATCH_STATUS_MATCHES_BY_DEPENDENCY = 2
MATCH_STATUS_DOESNT_MATCH = 3
MATCH_STATUS_TBD = 4
generator_supports_multiple_toolsets = gyp.common.CrossCompileRequested()
generator_wants_static_library_dependencies_adjusted = False
generator_default_variables = {
}
for dirname in ['INTERMEDIATE_DIR', 'SHARED_INTERMEDIATE_DIR', 'PRODUCT_DIR',
				'LIB_DIR', 'SHARED_LIB_DIR']:
  generator_default_variables[dirname] = '!!!'
for unused in ['RULE_INPUT_PATH', 'RULE_INPUT_ROOT', 'RULE_INPUT_NAME',
			   'RULE_INPUT_DIRNAME', 'RULE_INPUT_EXT',
			   'EXECUTABLE_PREFIX', 'EXECUTABLE_SUFFIX',
			   'STATIC_LIB_PREFIX', 'STATIC_LIB_SUFFIX',
			   'SHARED_LIB_PREFIX', 'SHARED_LIB_SUFFIX',
			   'CONFIGURATION_NAME']:
  generator_default_variables[unused] = ''
def _ToGypPath(path):
  if os.sep == '\\' and os.altsep == '/':
	return path.replace('\\', '/')
  return path
def _ResolveParent(path, base_path_components):
  depth = 0
  while path.startswith('../'):
	depth += 1
	path = path[3:]
  if depth > len(base_path_components):
	return ''
  if depth == len(base_path_components):
	return path
  return '/'.join(base_path_components[0:len(base_path_components) - depth]) + \
	  '/' + path
def _AddSources(sources, base_path, base_path_components, result):
  for source in sources:
	if not len(source) or source.startswith('!!!') or source.startswith('$'):
	  continue
	org_source = source
	source = source[0] + source[1:].replace('//', '/')
	if source.startswith('../'):
	  source = _ResolveParent(source, base_path_components)
	  if len(source):
		result.append(source)
	  continue
	result.append(base_path + source)
	if debug:
	  print 'AddSource', org_source, result[len(result) - 1]
def _ExtractSourcesFromAction(action, base_path, base_path_components,
							  results):
  if 'inputs' in action:
	_AddSources(action['inputs'], base_path, base_path_components, results)
def _ToLocalPath(toplevel_dir, path):
  if path == toplevel_dir:
	return ''
  if path.startswith(toplevel_dir + '/'):
	return path[len(toplevel_dir) + len('/'):]
  return path
def _ExtractSources(target, target_dict, toplevel_dir):
  base_path = posixpath.dirname(_ToLocalPath(toplevel_dir, _ToGypPath(target)))
  base_path_components = base_path.split('/')
  if len(base_path):
	base_path += '/'
  if debug:
	print 'ExtractSources', target, base_path
  results = []
  if 'sources' in target_dict:
	_AddSources(target_dict['sources'], base_path, base_path_components,
				results)
  if 'actions' in target_dict:
	for action in target_dict['actions']:
	  _ExtractSourcesFromAction(action, base_path, base_path_components,
								results)
  if 'rules' in target_dict:
	for rule in target_dict['rules']:
	  _ExtractSourcesFromAction(rule, base_path, base_path_components, results)
  return results
class Target(object):
  def __init__(self, name):
	self.deps = set()
	self.match_status = MATCH_STATUS_TBD
	self.back_deps = set()
	self.name = name
	self.visited = False
	self.requires_build = False
	self.added_to_compile_targets = False
	self.in_roots = False
	self.is_executable = False
class Config(object):
  def __init__(self):
	self.files = []
	self.targets = set()
  def Init(self, params):
	generator_flags = params.get('generator_flags', {})
	config_path = generator_flags.get('config_path', None)
	if not config_path:
	  return
	try:
	  f = open(config_path, 'r')
	  config = json.load(f)
	  f.close()
	except IOError:
	  raise Exception('Unable to open file ' + config_path)
	except ValueError as e:
	  raise Exception('Unable to parse config file ' + config_path + str(e))
	if not isinstance(config, dict):
	  raise Exception('config_path must be a JSON file containing a dictionary')
	self.files = config.get('files', [])
	self.targets = set(config.get('targets', []))
def _WasBuildFileModified(build_file, data, files, toplevel_dir):
  if _ToLocalPath(toplevel_dir, _ToGypPath(build_file)) in files:
	if debug:
	  print 'gyp file modified', build_file
	return True
  if len(data[build_file]['included_files']) <= 1:
	return False
  for include_file in data[build_file]['included_files'][1:]:
	rel_include_file = \
		_ToGypPath(gyp.common.UnrelativePath(include_file, build_file))
	if _ToLocalPath(toplevel_dir, rel_include_file) in files:
	  if debug:
		print 'included gyp file modified, gyp_file=', build_file, \
			'included file=', rel_include_file
	  return True
  return False
def _GetOrCreateTargetByName(targets, target_name):
  if target_name in targets:
	return False, targets[target_name]
  target = Target(target_name)
  targets[target_name] = target
  return True, target
def _DoesTargetTypeRequireBuild(target_dict):
  return target_dict['type'] != 'none' or \
	  target_dict.get('actions') or target_dict.get('rules')
def _GenerateTargets(data, target_list, target_dicts, toplevel_dir, files,
					 build_files):
  targets = {}
  matching_targets = []
  targets_to_visit = target_list[:]
  build_file_in_files = {}
  roots = set()
  build_file_targets = set()
  while len(targets_to_visit) > 0:
	target_name = targets_to_visit.pop()
	created_target, target = _GetOrCreateTargetByName(targets, target_name)
	if created_target:
	  roots.add(target)
	elif target.visited:
	  continue
	target.visited = True
	target.requires_build = _DoesTargetTypeRequireBuild(
		target_dicts[target_name])
	target.is_executable = target_dicts[target_name]['type'] == 'executable'
	build_file = gyp.common.ParseQualifiedTarget(target_name)[0]
	if not build_file in build_file_in_files:
	  build_file_in_files[build_file] = \
		  _WasBuildFileModified(build_file, data, files, toplevel_dir)
	if build_file in build_files:
	  build_file_targets.add(target)
	if build_file_in_files[build_file]:
	  print 'matching target
	  target.match_status = MATCH_STATUS_MATCHES
	  matching_targets.append(target)
	else:
	  sources = _ExtractSources(target_name, target_dicts[target_name],
								toplevel_dir)
	  for source in sources:
		if source in files:
		  print 'target', target_name, 'matches', source
		  target.match_status = MATCH_STATUS_MATCHES
		  matching_targets.append(target)
		  break
	for dep in target_dicts[target_name].get('dependencies', []):
	  targets_to_visit.append(dep)
	  created_dep_target, dep_target = _GetOrCreateTargetByName(targets, dep)
	  if not created_dep_target:
		roots.discard(dep_target)
	  target.deps.add(dep_target)
	  dep_target.back_deps.add(target)
  return targets, matching_targets, roots & build_file_targets
def _GetUnqualifiedToTargetMapping(all_targets, to_find):
  result = {}
  if not to_find:
	return result
  to_find = set(to_find)
  for target_name in all_targets.keys():
	extracted = gyp.common.ParseQualifiedTarget(target_name)
	if len(extracted) > 1 and extracted[1] in to_find:
	  to_find.remove(extracted[1])
	  result[extracted[1]] = all_targets[target_name]
	  if not to_find:
		return result
  return result
def _DoesTargetDependOn(target):
  if target.match_status == MATCH_STATUS_DOESNT_MATCH:
	return False
  if target.match_status == MATCH_STATUS_MATCHES or \
	  target.match_status == MATCH_STATUS_MATCHES_BY_DEPENDENCY:
	return True
  for dep in target.deps:
	if _DoesTargetDependOn(dep):
	  target.match_status = MATCH_STATUS_MATCHES_BY_DEPENDENCY
	  return True
  target.match_status = MATCH_STATUS_DOESNT_MATCH
  return False
def _GetTargetsDependingOn(possible_targets):
  found = []
  for target in possible_targets:
	if _DoesTargetDependOn(target):
	  found.append(target)
  return found
def _AddBuildTargets(target, roots, add_if_no_ancestor, result):
  if target.visited:
	return
  target.visited = True
  target.in_roots = not target.back_deps and target in roots
  for back_dep_target in target.back_deps:
	_AddBuildTargets(back_dep_target, roots, False, result)
	target.added_to_compile_targets |= back_dep_target.added_to_compile_targets
	target.in_roots |= back_dep_target.in_roots
  if target.in_roots and \
		(target.is_executable or
		 (not target.added_to_compile_targets and
		  (add_if_no_ancestor or target.requires_build))):
	result.add(target)
	target.added_to_compile_targets = True
def _GetBuildTargets(matching_targets, roots):
  result = set()
  for target in matching_targets:
	_AddBuildTargets(target, roots, True, result)
  return result
def _WriteOutput(params, **values):
  if 'error' in values:
	print 'Error:', values['error']
  if 'status' in values:
	print values['status']
  if 'targets' in values:
	values['targets'].sort()
	print 'Supplied targets that depend on changed files:'
	for target in values['targets']:
	  print '\t', target
  if 'invalid_targets' in values:
	values['invalid_targets'].sort()
	print 'The following targets were not found:'
	for target in values['invalid_targets']:
	  print '\t', target
  if 'build_targets' in values:
	values['build_targets'].sort()
	print 'Targets that require a build:'
	for target in values['build_targets']:
	  print '\t', target
  output_path = params.get('generator_flags', {}).get(
	  'analyzer_output_path', None)
  if not output_path:
	print json.dumps(values)
	return
  try:
	f = open(output_path, 'w')
	f.write(json.dumps(values) + '\n')
	f.close()
  except IOError as e:
	print 'Error writing to output file', output_path, str(e)
def _WasGypIncludeFileModified(params, files):
  if params['options'].includes:
	for include in params['options'].includes:
	  if _ToGypPath(include) in files:
		print 'Include file modified, assuming all changed', include
		return True
  return False
def _NamesNotIn(names, mapping):
  return [name for name in names if name not in mapping]
def _LookupTargets(names, mapping):
  return [mapping[name] for name in names if name in mapping]
def CalculateVariables(default_variables, params):
  flavor = gyp.common.GetFlavor(params)
  if flavor == 'mac':
	default_variables.setdefault('OS', 'mac')
  elif flavor == 'win':
	default_variables.setdefault('OS', 'win')
	generator_additional_non_configuration_keys = getattr(msvs_generator,
		'generator_additional_non_configuration_keys', [])
	generator_additional_path_sections = getattr(msvs_generator,
		'generator_additional_path_sections', [])
	gyp.msvs_emulation.CalculateCommonVariables(default_variables, params)
  else:
	operating_system = flavor
	if flavor == 'android':
	  operating_system = 'linux'
	default_variables.setdefault('OS', operating_system)
def GenerateOutput(target_list, target_dicts, data, params):
  config = Config()
  try:
	config.Init(params)
	if not config.files:
	  raise Exception('Must specify files to analyze via config_path generator '
					  'flag')
	toplevel_dir = _ToGypPath(os.path.abspath(params['options'].toplevel_dir))
	if debug:
	  print 'toplevel_dir', toplevel_dir
	if _WasGypIncludeFileModified(params, config.files):
	  result_dict = { 'status': all_changed_string,
					  'targets': list(config.targets) }
	  _WriteOutput(params, **result_dict)
	  return
	all_targets, matching_targets, roots = _GenerateTargets(
	  data, target_list, target_dicts, toplevel_dir, frozenset(config.files),
	  params['build_files'])
	unqualified_mapping = _GetUnqualifiedToTargetMapping(all_targets,
														 config.targets)
	invalid_targets = None
	if len(unqualified_mapping) != len(config.targets):
	  invalid_targets = _NamesNotIn(config.targets, unqualified_mapping)
	if matching_targets:
	  search_targets = _LookupTargets(config.targets, unqualified_mapping)
	  matched_search_targets = _GetTargetsDependingOn(search_targets)
	  for target in all_targets.itervalues():
		target.visited = False
	  build_targets = _GetBuildTargets(matching_targets, roots)
	  matched_search_targets = [gyp.common.ParseQualifiedTarget(target.name)[1]
								for target in matched_search_targets]
	  build_targets = [gyp.common.ParseQualifiedTarget(target.name)[1]
					   for target in build_targets]
	else:
	  matched_search_targets = []
	  build_targets = []
	result_dict = { 'targets': matched_search_targets,
					'status': found_dependency_string if matching_targets else
							  no_dependency_string,
					'build_targets': build_targets}
	if invalid_targets:
	  result_dict['invalid_targets'] = invalid_targets
	_WriteOutput(params, **result_dict)
  except Exception as e:
	_WriteOutput(params, error=str(e))