generator_default_variables = {
  'OS': 'android',
  'EXECUTABLE_PREFIX': '',
  'EXECUTABLE_SUFFIX': '',
  'STATIC_LIB_PREFIX': 'lib',
  'SHARED_LIB_PREFIX': 'lib',
  'STATIC_LIB_SUFFIX': '.a',
  'SHARED_LIB_SUFFIX': '.so',
  'INTERMEDIATE_DIR': '$(gyp_intermediate_dir)',
  'SHARED_INTERMEDIATE_DIR': '$(gyp_shared_intermediate_dir)',
  'PRODUCT_DIR': '$(gyp_shared_intermediate_dir)',
  'SHARED_LIB_DIR': '$(builddir)/lib.$(TOOLSET)',
  'LIB_DIR': '$(obj).$(TOOLSET)',
  'RULE_INPUT_ROOT': '%(INPUT_ROOT)s',
  'RULE_INPUT_DIRNAME': '%(INPUT_DIRNAME)s',
  'RULE_INPUT_PATH': '$(RULE_SOURCES)',
  'RULE_INPUT_EXT': '$(suffix $<)',
  'RULE_INPUT_NAME': '$(notdir $<)',
  'CONFIGURATION_NAME': '$(GYP_CONFIGURATION)',
}
generator_supports_multiple_toolsets = True
generator_additional_non_configuration_keys = [
	'android_unmangled_name',
	'aosp_build_settings',
]
generator_additional_path_sections = []
generator_extra_sources_for_rules = []
ALL_MODULES_FOOTER =
header =
MODULE_CLASSES = {
	'static_library': 'STATIC_LIBRARIES',
	'shared_library': 'SHARED_LIBRARIES',
	'executable': 'EXECUTABLES',
}
def IsCPPExtension(ext):
  return make.COMPILABLE_EXTENSIONS.get(ext) == 'cxx'
def Sourceify(path):
  return path
target_outputs = {}
target_link_deps = {}
class AndroidMkWriter(object):
  def __init__(self, android_top_dir):
	self.android_top_dir = android_top_dir
  def Write(self, qualified_target, relative_target, base_path, output_filename,
			spec, configs, part_of_all, write_alias_target, sdk_version):
	gyp.common.EnsureDirExists(output_filename)
	self.fp = open(output_filename, 'w')
	self.fp.write(header)
	self.qualified_target = qualified_target
	self.relative_target = relative_target
	self.path = base_path
	self.target = spec['target_name']
	self.type = spec['type']
	self.toolset = spec['toolset']
	deps, link_deps = self.ComputeDeps(spec)
	extra_outputs = []
	extra_sources = []
	self.android_class = MODULE_CLASSES.get(self.type, 'GYP')
	self.android_module = self.ComputeAndroidModule(spec)
	(self.android_stem, self.android_suffix) = self.ComputeOutputParts(spec)
	self.output = self.output_binary = self.ComputeOutput(spec)
	self.WriteLn('include $(CLEAR_VARS)\n')
	self.WriteLn('LOCAL_MODULE_CLASS := ' + self.android_class)
	self.WriteLn('LOCAL_MODULE := ' + self.android_module)
	if self.android_stem != self.android_module:
	  self.WriteLn('LOCAL_MODULE_STEM := ' + self.android_stem)
	self.WriteLn('LOCAL_MODULE_SUFFIX := ' + self.android_suffix)
	if self.toolset == 'host':
	  self.WriteLn('LOCAL_IS_HOST_MODULE := true')
	  self.WriteLn('LOCAL_MULTILIB := $(GYP_HOST_MULTILIB)')
	else:
	  self.WriteLn('LOCAL_MODULE_TARGET_ARCH := '
				   '$(TARGET_$(GYP_VAR_PREFIX)ARCH)')
	  self.WriteLn('LOCAL_SDK_VERSION := %s' % sdk_version)
	if self.toolset == 'host':
	  self.WriteLn('gyp_intermediate_dir := '
				   '$(call local-intermediates-dir,,$(GYP_HOST_VAR_PREFIX))')
	else:
	  self.WriteLn('gyp_intermediate_dir := '
				   '$(call local-intermediates-dir,,$(GYP_VAR_PREFIX))')
	self.WriteLn('gyp_shared_intermediate_dir := '
				 '$(call intermediates-dir-for,GYP,shared,,,$(GYP_VAR_PREFIX))')
	self.WriteLn()
	target_dependencies = [x[1] for x in deps if x[0] == 'path']
	self.WriteLn('
	self.WriteList(target_dependencies, 'GYP_TARGET_DEPENDENCIES',
				   local_pathify=True)
	if 'actions' in spec:
	  self.WriteActions(spec['actions'], extra_sources, extra_outputs)
	if 'rules' in spec:
	  self.WriteRules(spec['rules'], extra_sources, extra_outputs)
	if 'copies' in spec:
	  self.WriteCopies(spec['copies'], extra_outputs)
	self.WriteList(extra_outputs, 'GYP_GENERATED_OUTPUTS', local_pathify=True)
	self.WriteLn('
	self.WriteLn('LOCAL_ADDITIONAL_DEPENDENCIES := $(GYP_TARGET_DEPENDENCIES) '
				 '$(GYP_GENERATED_OUTPUTS)')
	self.WriteLn()
	if spec.get('sources', []) or extra_sources:
	  self.WriteSources(spec, configs, extra_sources)
	self.WriteTarget(spec, configs, deps, link_deps, part_of_all,
					 write_alias_target)
	target_outputs[qualified_target] = ('path', self.output_binary)
	if self.type == 'static_library':
	  target_link_deps[qualified_target] = ('static', self.android_module)
	elif self.type == 'shared_library':
	  target_link_deps[qualified_target] = ('shared', self.android_module)
	self.fp.close()
	return self.android_module
  def WriteActions(self, actions, extra_sources, extra_outputs):
	for action in actions:
	  name = make.StringToMakefileVariable('%s_%s' % (self.relative_target,
													  action['action_name']))
	  self.WriteLn('
	  inputs = action['inputs']
	  outputs = action['outputs']
	  dirs = set()
	  for out in outputs:
		if not out.startswith('$'):
		  print ('WARNING: Action for target "%s" writes output to local path '
				 '"%s".' % (self.target, out))
		dir = os.path.split(out)[0]
		if dir:
		  dirs.add(dir)
	  if int(action.get('process_outputs_as_sources', False)):
		extra_sources += outputs
	  command = gyp.common.EncodePOSIXShellList(action['action'])
	  if 'message' in action:
		quiet_cmd = 'Gyp action: %s ($@)' % action['message']
	  else:
		quiet_cmd = 'Gyp action: %s ($@)' % name
	  if len(dirs) > 0:
		command = 'mkdir -p %s' % ' '.join(dirs) + '; ' + command
	  cd_action = 'cd $(gyp_local_path)/%s; ' % self.path
	  command = cd_action + command
	  main_output = make.QuoteSpaces(self.LocalPathify(outputs[0]))
	  self.WriteLn('%s: gyp_local_path := $(LOCAL_PATH)' % main_output)
	  self.WriteLn('%s: gyp_var_prefix := $(GYP_VAR_PREFIX)' % main_output)
	  self.WriteLn('%s: gyp_intermediate_dir := '
				   '$(abspath $(gyp_intermediate_dir))' % main_output)
	  self.WriteLn('%s: gyp_shared_intermediate_dir := '
				   '$(abspath $(gyp_shared_intermediate_dir))' % main_output)
	  self.WriteLn('%s: export PATH := $(subst $(ANDROID_BUILD_PATHS),,$(PATH))'
				   % main_output)
	  for input in inputs:
		if not input.startswith('$(') and ' ' in input:
		  raise gyp.common.GypError(
			  'Action input filename "%s" in target %s contains a space' %
			  (input, self.target))
	  for output in outputs:
		if not output.startswith('$(') and ' ' in output:
		  raise gyp.common.GypError(
			  'Action output filename "%s" in target %s contains a space' %
			  (output, self.target))
	  self.WriteLn('%s: %s $(GYP_TARGET_DEPENDENCIES)' %
				   (main_output, ' '.join(map(self.LocalPathify, inputs))))
	  self.WriteLn('\t@echo "%s"' % quiet_cmd)
	  self.WriteLn('\t$(hide)%s\n' % command)
	  for output in outputs[1:]:
		self.WriteLn('%s: %s ;' % (self.LocalPathify(output), main_output))
	  extra_outputs += outputs
	  self.WriteLn()
	self.WriteLn()
  def WriteRules(self, rules, extra_sources, extra_outputs):
	if len(rules) == 0:
	  return
	for rule in rules:
	  if len(rule.get('rule_sources', [])) == 0:
		continue
	  name = make.StringToMakefileVariable('%s_%s' % (self.relative_target,
													  rule['rule_name']))
	  self.WriteLn('\n
	  self.WriteLn('
	  inputs = rule.get('inputs')
	  for rule_source in rule.get('rule_sources', []):
		(rule_source_dirname, rule_source_basename) = os.path.split(rule_source)
		(rule_source_root, rule_source_ext) = \
			os.path.splitext(rule_source_basename)
		outputs = [self.ExpandInputRoot(out, rule_source_root,
										rule_source_dirname)
				   for out in rule['outputs']]
		dirs = set()
		for out in outputs:
		  if not out.startswith('$'):
			print ('WARNING: Rule for target %s writes output to local path %s'
				   % (self.target, out))
		  dir = os.path.dirname(out)
		  if dir:
			dirs.add(dir)
		extra_outputs += outputs
		if int(rule.get('process_outputs_as_sources', False)):
		  extra_sources.extend(outputs)
		components = []
		for component in rule['action']:
		  component = self.ExpandInputRoot(component, rule_source_root,
										   rule_source_dirname)
		  if '$(RULE_SOURCES)' in component:
			component = component.replace('$(RULE_SOURCES)',
										  rule_source)
		  components.append(component)
		command = gyp.common.EncodePOSIXShellList(components)
		cd_action = 'cd $(gyp_local_path)/%s; ' % self.path
		command = cd_action + command
		if dirs:
		  command = 'mkdir -p %s' % ' '.join(dirs) + '; ' + command
		outputs = map(self.LocalPathify, outputs)
		main_output = outputs[0]
		self.WriteLn('%s: gyp_local_path := $(LOCAL_PATH)' % main_output)
		self.WriteLn('%s: gyp_var_prefix := $(GYP_VAR_PREFIX)' % main_output)
		self.WriteLn('%s: gyp_intermediate_dir := '
					 '$(abspath $(gyp_intermediate_dir))' % main_output)
		self.WriteLn('%s: gyp_shared_intermediate_dir := '
					 '$(abspath $(gyp_shared_intermediate_dir))' % main_output)
		self.WriteLn('%s: export PATH := '
					 '$(subst $(ANDROID_BUILD_PATHS),,$(PATH))' % main_output)
		main_output_deps = self.LocalPathify(rule_source)
		if inputs:
		  main_output_deps += ' '
		  main_output_deps += ' '.join([self.LocalPathify(f) for f in inputs])
		self.WriteLn('%s: %s $(GYP_TARGET_DEPENDENCIES)' %
					 (main_output, main_output_deps))
		self.WriteLn('\t%s\n' % command)
		for output in outputs[1:]:
		  self.WriteLn('%s: %s ;' % (output, main_output))
		self.WriteLn()
	self.WriteLn()
  def WriteCopies(self, copies, extra_outputs):
	self.WriteLn('
	variable = make.StringToMakefileVariable(self.relative_target + '_copies')
	outputs = []
	for copy in copies:
	  for path in copy['files']:
		if not copy['destination'].startswith('$'):
		  print ('WARNING: Copy rule for target %s writes output to '
				 'local path %s' % (self.target, copy['destination']))
		path = Sourceify(self.LocalPathify(path))
		filename = os.path.split(path)[1]
		output = Sourceify(self.LocalPathify(os.path.join(copy['destination'],
														  filename)))
		self.WriteLn('%s: %s $(GYP_TARGET_DEPENDENCIES) | $(ACP)' %
					 (output, path))
		self.WriteLn('\t@echo Copying: $@')
		self.WriteLn('\t$(hide) mkdir -p $(dir $@)')
		self.WriteLn('\t$(hide) $(ACP) -rpf $< $@')
		self.WriteLn()
		outputs.append(output)
	self.WriteLn('%s = %s' % (variable,
							  ' '.join(map(make.QuoteSpaces, outputs))))
	extra_outputs.append('$(%s)' % variable)
	self.WriteLn()
  def WriteSourceFlags(self, spec, configs):
	for configname, config in sorted(configs.iteritems()):
	  extracted_includes = []
	  self.WriteLn('\n
	  cflags, includes_
		  config.get('cflags', []) + config.get('cflags_c', []))
	  extracted_includes.extend(includes_
	  self.WriteList(cflags, 'MY_CFLAGS_%s' % configname)
	  self.WriteList(config.get('defines'), 'MY_DEFS_%s' % configname,
					 prefix='-D', quoter=make.EscapeCppDefine)
	  self.WriteLn('\n
	  includes = list(config.get('include_dirs', []))
	  includes.extend(extracted_includes)
	  includes = map(Sourceify, map(self.LocalPathify, includes))
	  includes = self.NormalizeIncludePaths(includes)
	  self.WriteList(includes, 'LOCAL_C_INCLUDES_%s' % configname)
	  self.WriteLn('\n
	  self.WriteList(config.get('cflags_cc'), 'LOCAL_CPPFLAGS_%s' % configname)
	self.WriteLn('\nLOCAL_CFLAGS := $(MY_CFLAGS_$(GYP_CONFIGURATION)) '
				 '$(MY_DEFS_$(GYP_CONFIGURATION))')
	if self.toolset == 'host':
	  self.WriteLn('
	  self.WriteLn('LOCAL_CFLAGS += -UANDROID')
	self.WriteLn('LOCAL_C_INCLUDES := $(GYP_COPIED_SOURCE_ORIGIN_DIRS) '
									 '$(LOCAL_C_INCLUDES_$(GYP_CONFIGURATION))')
	self.WriteLn('LOCAL_CPPFLAGS := $(LOCAL_CPPFLAGS_$(GYP_CONFIGURATION))')
	self.WriteLn('LOCAL_ASFLAGS := $(LOCAL_CFLAGS)')
  def WriteSources(self, spec, configs, extra_sources):
	sources = filter(make.Compilable, spec.get('sources', []))
	generated_not_sources = [x for x in extra_sources if not make.Compilable(x)]
	extra_sources = filter(make.Compilable, extra_sources)
	all_sources = sources + extra_sources
	local_cpp_extension = '.cpp'
	for source in all_sources:
	  (root, ext) = os.path.splitext(source)
	  if IsCPPExtension(ext):
		local_cpp_extension = ext
		break
	if local_cpp_extension != '.cpp':
	  self.WriteLn('LOCAL_CPP_EXTENSION := %s' % local_cpp_extension)
	local_files = []
	for source in sources:
	  (root, ext) = os.path.splitext(source)
	  if '$(gyp_shared_intermediate_dir)' in source:
		extra_sources.append(source)
	  elif '$(gyp_intermediate_dir)' in source:
		extra_sources.append(source)
	  elif IsCPPExtension(ext) and ext != local_cpp_extension:
		extra_sources.append(source)
	  else:
		local_files.append(os.path.normpath(os.path.join(self.path, source)))
	final_generated_sources = []
	origin_src_dirs = []
	for source in extra_sources:
	  local_file = source
	  if not '$(gyp_intermediate_dir)/' in local_file:
		basename = os.path.basename(local_file)
		local_file = '$(gyp_intermediate_dir)/' + basename
	  (root, ext) = os.path.splitext(local_file)
	  if IsCPPExtension(ext) and ext != local_cpp_extension:
		local_file = root + local_cpp_extension
	  if local_file != source:
		self.WriteLn('%s: %s' % (local_file, self.LocalPathify(source)))
		self.WriteLn('\tmkdir -p $(@D); cp $< $@')
		origin_src_dirs.append(os.path.dirname(source))
	  final_generated_sources.append(local_file)
	final_generated_sources.extend(generated_not_sources)
	self.WriteList(final_generated_sources, 'LOCAL_GENERATED_SOURCES')
	origin_src_dirs = gyp.common.uniquer(origin_src_dirs)
	origin_src_dirs = map(Sourceify, map(self.LocalPathify, origin_src_dirs))
	self.WriteList(origin_src_dirs, 'GYP_COPIED_SOURCE_ORIGIN_DIRS')
	self.WriteList(local_files, 'LOCAL_SRC_FILES')
	self.WriteSourceFlags(spec, configs)
  def ComputeAndroidModule(self, spec):
	if int(spec.get('android_unmangled_name', 0)):
	  assert self.type != 'shared_library' or self.target.startswith('lib')
	  return self.target
	if self.type == 'shared_library':
	  prefix = 'lib_'
	else:
	  prefix = ''
	if spec['toolset'] == 'host':
	  suffix = '_$(TARGET_$(GYP_VAR_PREFIX)ARCH)_host_gyp'
	else:
	  suffix = '_gyp'
	if self.path:
	  middle = make.StringToMakefileVariable('%s_%s' % (self.path, self.target))
	else:
	  middle = make.StringToMakefileVariable(self.target)
	return ''.join([prefix, middle, suffix])
  def ComputeOutputParts(self, spec):
	assert self.type != 'loadable_module'
	target = spec['target_name']
	target_prefix = ''
	target_ext = ''
	if self.type == 'static_library':
	  target = self.ComputeAndroidModule(spec)
	  target_ext = '.a'
	elif self.type == 'shared_library':
	  target = self.ComputeAndroidModule(spec)
	  target_ext = '.so'
	elif self.type == 'none':
	  target_ext = '.stamp'
	elif self.type != 'executable':
	  print ("ERROR: What output file should be generated?",
			 "type", self.type, "target", target)
	if self.type != 'static_library' and self.type != 'shared_library':
	  target_prefix = spec.get('product_prefix', target_prefix)
	  target = spec.get('product_name', target)
	  product_ext = spec.get('product_extension')
	  if product_ext:
		target_ext = '.' + product_ext
	target_stem = target_prefix + target
	return (target_stem, target_ext)
  def ComputeOutputBasename(self, spec):
	return ''.join(self.ComputeOutputParts(spec))
  def ComputeOutput(self, spec):
	if self.type == 'executable':
	  path = '$(gyp_shared_intermediate_dir)'
	elif self.type == 'shared_library':
	  if self.toolset == 'host':
		path = '$($(GYP_HOST_VAR_PREFIX)HOST_OUT_INTERMEDIATE_LIBRARIES)'
	  else:
		path = '$($(GYP_VAR_PREFIX)TARGET_OUT_INTERMEDIATE_LIBRARIES)'
	else:
	  if self.toolset == 'host':
		path = ('$(call intermediates-dir-for,%s,%s,true,,'
				'$(GYP_HOST_VAR_PREFIX))' % (self.android_class,
											 self.android_module))
	  else:
		path = ('$(call intermediates-dir-for,%s,%s,,,$(GYP_VAR_PREFIX))'
				% (self.android_class, self.android_module))
	assert spec.get('product_dir') is None
	return os.path.join(path, self.ComputeOutputBasename(spec))
  def NormalizeIncludePaths(self, include_paths):
	normalized = []
	for path in include_paths:
	  if path[0] == '/':
		path = gyp.common.RelativePath(path, self.android_top_dir)
	  normalized.append(path)
	return normalized
  def ExtractIncludesFromCFlags(self, cflags):
	clean_cflags = []
	include_paths = []
	for flag in cflags:
	  if flag.startswith('-I'):
		include_paths.append(flag[2:])
	  else:
		clean_cflags.append(flag)
	return (clean_cflags, include_paths)
  def FilterLibraries(self, libraries):
	static_lib_modules = []
	dynamic_lib_modules = []
	ldflags = []
	for libs in libraries:
	  for lib in libs.split():
		if (lib == '-lc' or lib == '-lstdc++' or lib == '-lm' or
			lib.endswith('libgcc.a')):
		  continue
		match = re.search(r'([^/]+)\.a$', lib)
		if match:
		  static_lib_modules.append(match.group(1))
		  continue
		match = re.search(r'([^/]+)\.so$', lib)
		if match:
		  dynamic_lib_modules.append(match.group(1))
		  continue
		if lib.startswith('-l'):
		  ldflags.append(lib)
	return (static_lib_modules, dynamic_lib_modules, ldflags)
  def ComputeDeps(self, spec):
	deps = []
	link_deps = []
	if 'dependencies' in spec:
	  deps.extend([target_outputs[dep] for dep in spec['dependencies']
				   if target_outputs[dep]])
	  for dep in spec['dependencies']:
		if dep in target_link_deps:
		  link_deps.append(target_link_deps[dep])
	  deps.extend(link_deps)
	return (gyp.common.uniquer(deps), gyp.common.uniquer(link_deps))
  def WriteTargetFlags(self, spec, configs, link_deps):
	libraries = gyp.common.uniquer(spec.get('libraries', []))
	static_libs, dynamic_libs, ldflags_libs = self.FilterLibraries(libraries)
	if self.type != 'static_library':
	  for configname, config in sorted(configs.iteritems()):
		ldflags = list(config.get('ldflags', []))
		self.WriteLn('')
		self.WriteList(ldflags, 'LOCAL_LDFLAGS_%s' % configname)
	  self.WriteList(ldflags_libs, 'LOCAL_GYP_LIBS')
	  self.WriteLn('LOCAL_LDFLAGS := $(LOCAL_LDFLAGS_$(GYP_CONFIGURATION)) '
				   '$(LOCAL_GYP_LIBS)')
	if self.type != 'static_library':
	  static_link_deps = [x[1] for x in link_deps if x[0] == 'static']
	  shared_link_deps = [x[1] for x in link_deps if x[0] == 'shared']
	else:
	  static_link_deps = []
	  shared_link_deps = []
	if static_libs or static_link_deps:
	  self.WriteLn('')
	  self.WriteList(static_libs + static_link_deps,
					 'LOCAL_STATIC_LIBRARIES')
	  self.WriteLn('
	  self.WriteLn('LOCAL_GROUP_STATIC_LIBRARIES := true')
	if dynamic_libs or shared_link_deps:
	  self.WriteLn('')
	  self.WriteList(dynamic_libs + shared_link_deps,
					 'LOCAL_SHARED_LIBRARIES')
  def WriteTarget(self, spec, configs, deps, link_deps, part_of_all,
				  write_alias_target):
	self.WriteLn('
	if self.type != 'none':
	  self.WriteTargetFlags(spec, configs, link_deps)
	settings = spec.get('aosp_build_settings', {})
	if settings:
	  self.WriteLn('
	  for k, v in settings.iteritems():
		if isinstance(v, list):
		  self.WriteList(v, k)
		else:
		  self.WriteLn('%s := %s' % (k, make.QuoteIfNecessary(v)))
	  self.WriteLn('')
	if part_of_all and write_alias_target:
	  self.WriteLn('
	  self.WriteLn('.PHONY: gyp_all_modules')
	  self.WriteLn('gyp_all_modules: %s' % self.android_module)
	  self.WriteLn('')
	if self.target != self.android_module and write_alias_target:
	  self.WriteLn('
	  self.WriteLn('.PHONY: %s' % self.target)
	  self.WriteLn('%s: %s' % (self.target, self.android_module))
	  self.WriteLn('')
	modifier = ''
	if self.toolset == 'host':
	  modifier = 'HOST_'
	if self.type == 'static_library':
	  self.WriteLn('include $(BUILD_%sSTATIC_LIBRARY)' % modifier)
	elif self.type == 'shared_library':
	  self.WriteLn('LOCAL_PRELINK_MODULE := false')
	  self.WriteLn('include $(BUILD_%sSHARED_LIBRARY)' % modifier)
	elif self.type == 'executable':
	  self.WriteLn('LOCAL_MODULE_PATH := $(gyp_shared_intermediate_dir)')
	  self.WriteLn('include $(BUILD_%sEXECUTABLE)' % modifier)
	else:
	  self.WriteLn('LOCAL_MODULE_PATH := $(PRODUCT_OUT)/gyp_stamp')
	  self.WriteLn('LOCAL_UNINSTALLABLE_MODULE := true')
	  if self.toolset == 'target':
		self.WriteLn('LOCAL_2ND_ARCH_VAR_PREFIX := $(GYP_VAR_PREFIX)')
	  else:
		self.WriteLn('LOCAL_2ND_ARCH_VAR_PREFIX := $(GYP_HOST_VAR_PREFIX)')
	  self.WriteLn()
	  self.WriteLn('include $(BUILD_SYSTEM)/base_rules.mk')
	  self.WriteLn()
	  self.WriteLn('$(LOCAL_BUILT_MODULE): $(LOCAL_ADDITIONAL_DEPENDENCIES)')
	  self.WriteLn('\t$(hide) echo "Gyp timestamp: $@"')
	  self.WriteLn('\t$(hide) mkdir -p $(dir $@)')
	  self.WriteLn('\t$(hide) touch $@')
	  self.WriteLn()
	  self.WriteLn('LOCAL_2ND_ARCH_VAR_PREFIX :=')
  def WriteList(self, value_list, variable=None, prefix='',
				quoter=make.QuoteIfNecessary, local_pathify=False):
	values = ''
	if value_list:
	  value_list = [quoter(prefix + l) for l in value_list]
	  if local_pathify:
		value_list = [self.LocalPathify(l) for l in value_list]
	  values = ' \\\n\t' + ' \\\n\t'.join(value_list)
	self.fp.write('%s :=%s\n\n' % (variable, values))
  def WriteLn(self, text=''):
	self.fp.write(text + '\n')
  def LocalPathify(self, path):
	if '$(' in path or os.path.isabs(path):
	  return os.path.normpath(path)
	local_path = os.path.join('$(LOCAL_PATH)', self.path, path)
	local_path = os.path.normpath(local_path)
	assert local_path.startswith('$(LOCAL_PATH)'), (
		   'Path %s attempts to escape
	return local_path
  def ExpandInputRoot(self, template, expansion, dirname):
	if '%(INPUT_ROOT)s' not in template and '%(INPUT_DIRNAME)s' not in template:
	  return template
	path = template % {
		'INPUT_ROOT': expansion,
		'INPUT_DIRNAME': dirname,
		}
	return os.path.normpath(path)
def PerformBuild(data, configurations, params):
  options = params['options']
  makefile = os.path.abspath(os.path.join(options.toplevel_dir,
										  'GypAndroid.mk'))
  env = dict(os.environ)
  env['ONE_SHOT_MAKEFILE'] = makefile
  arguments = ['make', '-C', os.environ['ANDROID_BUILD_TOP'], 'gyp_all_modules']
  print 'Building: %s' % arguments
  subprocess.check_call(arguments, env=env)
def GenerateOutput(target_list, target_dicts, data, params):
  options = params['options']
  generator_flags = params.get('generator_flags', {})
  builddir_name = generator_flags.get('output_dir', 'out')
  limit_to_target_all = generator_flags.get('limit_to_target_all', False)
  write_alias_targets = generator_flags.get('write_alias_targets', True)
  sdk_version = generator_flags.get('aosp_sdk_version', 19)
  android_top_dir = os.environ.get('ANDROID_BUILD_TOP')
  assert android_top_dir, '$ANDROID_BUILD_TOP not set; you need to run lunch.'
  def CalculateMakefilePath(build_file, base_name):
	base_path = gyp.common.RelativePath(os.path.dirname(build_file),
										options.depth)
	output_file = os.path.join(options.depth, base_path, base_name)
	assert not options.generator_output, (
		'The Android backend does not support options.generator_output.')
	base_path = gyp.common.RelativePath(os.path.dirname(build_file),
										options.toplevel_dir)
	return base_path, output_file
  default_configuration = None
  toolsets = set([target_dicts[target]['toolset'] for target in target_list])
  for target in target_list:
	spec = target_dicts[target]
	if spec['default_configuration'] != 'Default':
	  default_configuration = spec['default_configuration']
	  break
  if not default_configuration:
	default_configuration = 'Default'
  srcdir = '.'
  makefile_name = 'GypAndroid' + options.suffix + '.mk'
  makefile_path = os.path.join(options.toplevel_dir, makefile_name)
  assert not options.generator_output, (
	  'The Android backend does not support options.generator_output.')
  gyp.common.EnsureDirExists(makefile_path)
  root_makefile = open(makefile_path, 'w')
  root_makefile.write(header)
  root_makefile.write('\nLOCAL_PATH := $(call my-dir)\n')
  needed_targets = set()
  for build_file in params['build_files']:
	for target in gyp.common.AllTargets(target_list, target_dicts, build_file):
	  needed_targets.add(target)
  build_files = set()
  include_list = set()
  android_modules = {}
  for qualified_target in target_list:
	build_file, target, toolset = gyp.common.ParseQualifiedTarget(
		qualified_target)
	relative_build_file = gyp.common.RelativePath(build_file,
												  options.toplevel_dir)
	build_files.add(relative_build_file)
	included_files = data[build_file]['included_files']
	for included_file in included_files:
	  relative_include_file = gyp.common.RelativePath(
		  gyp.common.UnrelativePath(included_file, build_file),
		  options.toplevel_dir)
	  abs_include_file = os.path.abspath(relative_include_file)
	  if (params['home_dot_gyp'] and
		  abs_include_file.startswith(params['home_dot_gyp'])):
		build_files.add(abs_include_file)
	  else:
		build_files.add(relative_include_file)
	base_path, output_file = CalculateMakefilePath(build_file,
		target + '.' + toolset + options.suffix + '.mk')
	spec = target_dicts[qualified_target]
	configs = spec['configurations']
	part_of_all = qualified_target in needed_targets
	if limit_to_target_all and not part_of_all:
	  continue
	relative_target = gyp.common.QualifiedTarget(relative_build_file, target,
												 toolset)
	writer = AndroidMkWriter(android_top_dir)
	android_module = writer.Write(qualified_target, relative_target, base_path,
								  output_file, spec, configs,
								  part_of_all=part_of_all,
								  write_alias_target=write_alias_targets,
								  sdk_version=sdk_version)
	if android_module in android_modules:
	  print ('ERROR: Android module names must be unique. The following '
			 'targets both generate Android module name %s.\n  %s\n  %s' %
			 (android_module, android_modules[android_module],
			  qualified_target))
	  return
	android_modules[android_module] = qualified_target
	mkfile_rel_path = gyp.common.RelativePath(output_file,
											  os.path.dirname(makefile_path))
	include_list.add(mkfile_rel_path)
  root_makefile.write('GYP_CONFIGURATION ?= %s\n' % default_configuration)
  root_makefile.write('GYP_VAR_PREFIX ?=\n')
  root_makefile.write('GYP_HOST_VAR_PREFIX ?=\n')
  root_makefile.write('GYP_HOST_MULTILIB ?=\n')
  root_makefile.write('\n')
  for include_file in sorted(include_list):
	root_makefile.write('include $(LOCAL_PATH)/' + include_file + '\n')
  root_makefile.write('\n')
  if write_alias_targets:
	root_makefile.write(ALL_MODULES_FOOTER)
  root_makefile.close()