generator_default_variables = {
  'EXECUTABLE_PREFIX': '',
  'EXECUTABLE_SUFFIX': '',
  'STATIC_LIB_PREFIX': 'lib',
  'STATIC_LIB_SUFFIX': '.a',
  'SHARED_LIB_PREFIX': 'lib',
  'SHARED_LIB_SUFFIX': '.so',
  'SHARED_LIB_DIR': '${builddir}/lib.${TOOLSET}',
  'LIB_DIR': '${obj}.${TOOLSET}',
  'INTERMEDIATE_DIR': '${obj}.${TOOLSET}/${TARGET}/geni',
  'SHARED_INTERMEDIATE_DIR': '${obj}/gen',
  'PRODUCT_DIR': '${builddir}',
  'RULE_INPUT_PATH': '${RULE_INPUT_PATH}',
  'RULE_INPUT_DIRNAME': '${RULE_INPUT_DIRNAME}',
  'RULE_INPUT_NAME': '${RULE_INPUT_NAME}',
  'RULE_INPUT_ROOT': '${RULE_INPUT_ROOT}',
  'RULE_INPUT_EXT': '${RULE_INPUT_EXT}',
  'CONFIGURATION_NAME': '${configuration}',
}
FULL_PATH_VARS = ('${CMAKE_SOURCE_DIR}', '${builddir}', '${obj}')
generator_supports_multiple_toolsets = True
generator_wants_static_library_dependencies_adjusted = True
COMPILABLE_EXTENSIONS = {
  '.c': 'cc',
  '.cc': 'cxx',
  '.cpp': 'cxx',
  '.cxx': 'cxx',
  '.s': 's',
  '.S': 's',
}
def RemovePrefix(a, prefix):
  return a[len(prefix):] if a.startswith(prefix) else a
def CalculateVariables(default_variables, params):
  default_variables.setdefault('OS', gyp.common.GetFlavor(params))
def Compilable(filename):
  return any(filename.endswith(e) for e in COMPILABLE_EXTENSIONS)
def Linkable(filename):
  return filename.endswith('.o')
def NormjoinPathForceCMakeSource(base_path, rel_path):
  if os.path.isabs(rel_path):
	return rel_path
  if any([rel_path.startswith(var) for var in FULL_PATH_VARS]):
	return rel_path
  return os.path.join('${CMAKE_SOURCE_DIR}',
					  os.path.normpath(os.path.join(base_path, rel_path)))
def NormjoinPath(base_path, rel_path):
  if rel_path.startswith('$') and not rel_path.startswith('${configuration}'):
	return rel_path
  return os.path.normpath(os.path.join(base_path, rel_path))
def CMakeStringEscape(a):
  return a.replace('\\', '\\\\').replace(';', '\\;').replace('"', '\\"')
def SetFileProperty(output, source_name, property_name, values, sep):
  output.write('set_source_files_properties(')
  output.write(source_name)
  output.write(' PROPERTIES ')
  output.write(property_name)
  output.write(' "')
  for value in values:
	output.write(CMakeStringEscape(value))
	output.write(sep)
  output.write('")\n')
def SetFilesProperty(output, source_names, property_name, values, sep):
  output.write('set_source_files_properties(\n')
  for source_name in source_names:
	output.write('  ')
	output.write(source_name)
	output.write('\n')
  output.write(' PROPERTIES\n  ')
  output.write(property_name)
  output.write(' "')
  for value in values:
	output.write(CMakeStringEscape(value))
	output.write(sep)
  output.write('"\n)\n')
def SetTargetProperty(output, target_name, property_name, values, sep=''):
  output.write('set_target_properties(')
  output.write(target_name)
  output.write(' PROPERTIES ')
  output.write(property_name)
  output.write(' "')
  for value in values:
	output.write(CMakeStringEscape(value))
	output.write(sep)
  output.write('")\n')
def SetVariable(output, variable_name, value):
  output.write('set(')
  output.write(variable_name)
  output.write(' "')
  output.write(CMakeStringEscape(value))
  output.write('")\n')
def SetVariableList(output, variable_name, values):
  if not values:
	return SetVariable(output, variable_name, "")
  if len(values) == 1:
	return SetVariable(output, variable_name, values[0])
  output.write('list(APPEND ')
  output.write(variable_name)
  output.write('\n  "')
  output.write('"\n  "'.join([CMakeStringEscape(value) for value in values]))
  output.write('")\n')
def UnsetVariable(output, variable_name):
  output.write('unset(')
  output.write(variable_name)
  output.write(')\n')
def WriteVariable(output, variable_name, prepend=None):
  if prepend:
	output.write(prepend)
  output.write('${')
  output.write(variable_name)
  output.write('}')
class CMakeTargetType(object):
  def __init__(self, command, modifier, property_modifier):
	self.command = command
	self.modifier = modifier
	self.property_modifier = property_modifier
cmake_target_type_
  'executable': CMakeTargetType('add_executable', None, 'RUNTIME'),
  'static_library': CMakeTargetType('add_library', 'STATIC', 'ARCHIVE'),
  'shared_library': CMakeTargetType('add_library', 'SHARED', 'LIBRARY'),
  'loadable_module': CMakeTargetType('add_library', 'MODULE', 'LIBRARY'),
  'none': CMakeTargetType('add_custom_target', 'SOURCES', None),
}
def StringToCMakeTargetName(a):
  return a.translate(string.maketrans(' /():.', '______'))
def WriteActions(target_name, actions, extra_sources, extra_deps,
				 path_to_gyp, output):
  for action in actions:
	action_name = StringToCMakeTargetName(action['action_name'])
	action_target_name = '%s__%s' % (target_name, action_name)
	inputs = action['inputs']
	inputs_name = action_target_name + '__input'
	SetVariableList(output, inputs_name,
		[NormjoinPathForceCMakeSource(path_to_gyp, dep) for dep in inputs])
	outputs = action['outputs']
	cmake_outputs = [NormjoinPathForceCMakeSource(path_to_gyp, out)
					 for out in outputs]
	outputs_name = action_target_name + '__output'
	SetVariableList(output, outputs_name, cmake_outputs)
	dirs = set(dir for dir in (os.path.dirname(o) for o in outputs) if dir)
	if int(action.get('process_outputs_as_sources', False)):
	  extra_sources.extend(zip(cmake_outputs, outputs))
	output.write('add_custom_command(OUTPUT ')
	WriteVariable(output, outputs_name)
	output.write('\n')
	if len(dirs) > 0:
	  for directory in dirs:
		output.write('  COMMAND ${CMAKE_COMMAND} -E make_directory ')
		output.write(directory)
		output.write('\n')
	output.write('  COMMAND ')
	output.write(gyp.common.EncodePOSIXShellList(action['action']))
	output.write('\n')
	output.write('  DEPENDS ')
	WriteVariable(output, inputs_name)
	output.write('\n')
	output.write('  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/')
	output.write(path_to_gyp)
	output.write('\n')
	output.write('  COMMENT ')
	if 'message' in action:
	  output.write(action['message'])
	else:
	  output.write(action_target_name)
	output.write('\n')
	output.write('  VERBATIM\n')
	output.write(')\n')
	output.write('add_custom_target(')
	output.write(action_target_name)
	output.write('\n  DEPENDS ')
	WriteVariable(output, outputs_name)
	output.write('\n  SOURCES ')
	WriteVariable(output, inputs_name)
	output.write('\n)\n')
	extra_deps.append(action_target_name)
def NormjoinRulePathForceCMakeSource(base_path, rel_path, rule_source):
  if rel_path.startswith(("${RULE_INPUT_PATH}","${RULE_INPUT_DIRNAME}")):
	if any([rule_source.startswith(var) for var in FULL_PATH_VARS]):
	  return rel_path
  return NormjoinPathForceCMakeSource(base_path, rel_path)
def WriteRules(target_name, rules, extra_sources, extra_deps,
			   path_to_gyp, output):
  for rule in rules:
	rule_name = StringToCMakeTargetName(target_name + '__' + rule['rule_name'])
	inputs = rule.get('inputs', [])
	inputs_name = rule_name + '__input'
	SetVariableList(output, inputs_name,
		[NormjoinPathForceCMakeSource(path_to_gyp, dep) for dep in inputs])
	outputs = rule['outputs']
	var_outputs = []
	for count, rule_source in enumerate(rule.get('rule_sources', [])):
	  action_name = rule_name + '_' + str(count)
	  rule_source_dirname, rule_source_basename = os.path.split(rule_source)
	  rule_source_root, rule_source_ext = os.path.splitext(rule_source_basename)
	  SetVariable(output, 'RULE_INPUT_PATH', rule_source)
	  SetVariable(output, 'RULE_INPUT_DIRNAME', rule_source_dirname)
	  SetVariable(output, 'RULE_INPUT_NAME', rule_source_basename)
	  SetVariable(output, 'RULE_INPUT_ROOT', rule_source_root)
	  SetVariable(output, 'RULE_INPUT_EXT', rule_source_ext)
	  dirs = set(dir for dir in (os.path.dirname(o) for o in outputs) if dir)
	  these_outputs = []
	  for output_index, out in enumerate(outputs):
		output_name = action_name + '_' + str(output_index)
		SetVariable(output, output_name,
					 NormjoinRulePathForceCMakeSource(path_to_gyp, out,
													  rule_source))
		if int(rule.get('process_outputs_as_sources', False)):
		  extra_sources.append(('${' + output_name + '}', out))
		these_outputs.append('${' + output_name + '}')
		var_outputs.append('${' + output_name + '}')
	  output.write('add_custom_command(OUTPUT\n')
	  for out in these_outputs:
		output.write('  ')
		output.write(out)
		output.write('\n')
	  for directory in dirs:
		output.write('  COMMAND ${CMAKE_COMMAND} -E make_directory ')
		output.write(directory)
		output.write('\n')
	  output.write('  COMMAND ')
	  output.write(gyp.common.EncodePOSIXShellList(rule['action']))
	  output.write('\n')
	  output.write('  DEPENDS ')
	  WriteVariable(output, inputs_name)
	  output.write(' ')
	  output.write(NormjoinPath(path_to_gyp, rule_source))
	  output.write('\n')
	  output.write('  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/')
	  output.write(path_to_gyp)
	  output.write('\n')
	  output.write('  COMMENT ')
	  if 'message' in rule:
		output.write(rule['message'])
	  else:
		output.write(action_name)
	  output.write('\n')
	  output.write('  VERBATIM\n')
	  output.write(')\n')
	  UnsetVariable(output, 'RULE_INPUT_PATH')
	  UnsetVariable(output, 'RULE_INPUT_DIRNAME')
	  UnsetVariable(output, 'RULE_INPUT_NAME')
	  UnsetVariable(output, 'RULE_INPUT_ROOT')
	  UnsetVariable(output, 'RULE_INPUT_EXT')
	output.write('add_custom_target(')
	output.write(rule_name)
	output.write(' DEPENDS\n')
	for out in var_outputs:
	  output.write('  ')
	  output.write(out)
	  output.write('\n')
	output.write('SOURCES ')
	WriteVariable(output, inputs_name)
	output.write('\n')
	for rule_source in rule.get('rule_sources', []):
	  output.write('  ')
	  output.write(NormjoinPath(path_to_gyp, rule_source))
	  output.write('\n')
	output.write(')\n')
	extra_deps.append(rule_name)
def WriteCopies(target_name, copies, extra_deps, path_to_gyp, output):
  copy_name = target_name + '__copies'
  have_copies = any(copy['files'] for copy in copies)
  if not have_copies:
	output.write('add_custom_target(')
	output.write(copy_name)
	output.write(')\n')
	extra_deps.append(copy_name)
	return
  class Copy(object):
	def __init__(self, ext, command):
	  self.cmake_inputs = []
	  self.cmake_outputs = []
	  self.gyp_inputs = []
	  self.gyp_outputs = []
	  self.ext = ext
	  self.inputs_name = None
	  self.outputs_name = None
	  self.command = command
  file_copy = Copy('', 'copy')
  dir_copy = Copy('_dirs', 'copy_directory')
  for copy in copies:
	files = copy['files']
	destination = copy['destination']
	for src in files:
	  path = os.path.normpath(src)
	  basename = os.path.split(path)[1]
	  dst = os.path.join(destination, basename)
	  copy = file_copy if os.path.basename(src) else dir_copy
	  copy.cmake_inputs.append(NormjoinPath(path_to_gyp, src))
	  copy.cmake_outputs.append(NormjoinPathForceCMakeSource(path_to_gyp, dst))
	  copy.gyp_inputs.append(src)
	  copy.gyp_outputs.append(dst)
  for copy in (file_copy, dir_copy):
	if copy.cmake_inputs:
	  copy.inputs_name = copy_name + '__input' + copy.ext
	  SetVariableList(output, copy.inputs_name, copy.cmake_inputs)
	  copy.outputs_name = copy_name + '__output' + copy.ext
	  SetVariableList(output, copy.outputs_name, copy.cmake_outputs)
  output.write('add_custom_command(\n')
  output.write('OUTPUT')
  for copy in (file_copy, dir_copy):
	if copy.outputs_name:
	  WriteVariable(output, copy.outputs_name, ' ')
  output.write('\n')
  for copy in (file_copy, dir_copy):
	for src, dst in zip(copy.gyp_inputs, copy.gyp_outputs):
	  output.write('COMMAND ${CMAKE_COMMAND} -E %s ' % copy.command)
	  output.write(src)
	  output.write(' ')
	  output.write(dst)
	  output.write("\n")
  output.write('DEPENDS')
  for copy in (file_copy, dir_copy):
	if copy.inputs_name:
	  WriteVariable(output, copy.inputs_name, ' ')
  output.write('\n')
  output.write('WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/')
  output.write(path_to_gyp)
  output.write('\n')
  output.write('COMMENT Copying for ')
  output.write(target_name)
  output.write('\n')
  output.write('VERBATIM\n')
  output.write(')\n')
  output.write('add_custom_target(')
  output.write(copy_name)
  output.write('\n  DEPENDS')
  for copy in (file_copy, dir_copy):
	if copy.outputs_name:
	  WriteVariable(output, copy.outputs_name, ' ')
  output.write('\n  SOURCES')
  if file_copy.inputs_name:
	WriteVariable(output, file_copy.inputs_name, ' ')
  output.write('\n)\n')
  extra_deps.append(copy_name)
def CreateCMakeTargetBaseName(qualified_target):
  _, gyp_target_name, gyp_target_toolset = (
	  gyp.common.ParseQualifiedTarget(qualified_target))
  cmake_target_base_name = gyp_target_name
  if gyp_target_toolset and gyp_target_toolset != 'target':
	cmake_target_base_name += '_' + gyp_target_toolset
  return StringToCMakeTargetName(cmake_target_base_name)
def CreateCMakeTargetFullName(qualified_target):
  gyp_file, gyp_target_name, gyp_target_toolset = (
	  gyp.common.ParseQualifiedTarget(qualified_target))
  cmake_target_full_name = gyp_file + ':' + gyp_target_name
  if gyp_target_toolset and gyp_target_toolset != 'target':
	cmake_target_full_name += '_' + gyp_target_toolset
  return StringToCMakeTargetName(cmake_target_full_name)
class CMakeNamer(object):
  def __init__(self, target_list):
	self.cmake_target_base_names_conficting = set()
	cmake_target_base_names_seen = set()
	for qualified_target in target_list:
	  cmake_target_base_name = CreateCMakeTargetBaseName(qualified_target)
	  if cmake_target_base_name not in cmake_target_base_names_seen:
		cmake_target_base_names_seen.add(cmake_target_base_name)
	  else:
		self.cmake_target_base_names_conficting.add(cmake_target_base_name)
  def CreateCMakeTargetName(self, qualified_target):
	base_name = CreateCMakeTargetBaseName(qualified_target)
	if base_name in self.cmake_target_base_names_conficting:
	  return CreateCMakeTargetFullName(qualified_target)
	return base_name
def WriteTarget(namer, qualified_target, target_dicts, build_dir, config_to_use,
				options, generator_flags, all_qualified_targets, output):
  circular_libs = generator_flags.get('circular', True)
  if not generator_flags.get('standalone', False):
	output.write('\n
	output.write(qualified_target)
	output.write('\n')
  gyp_file, _, _ = gyp.common.ParseQualifiedTarget(qualified_target)
  rel_gyp_file = gyp.common.RelativePath(gyp_file, options.toplevel_dir)
  rel_gyp_dir = os.path.dirname(rel_gyp_file)
  build_to_top = gyp.common.InvertRelativePath(build_dir, options.toplevel_dir)
  build_to_gyp = os.path.join(build_to_top, rel_gyp_dir)
  path_
  spec = target_dicts.get(qualified_target, {})
  config = spec.get('configurations', {}).get(config_to_use, {})
  target_name = spec.get('target_name', '<missing target name>')
  target_type = spec.get('type', '<missing target type>')
  target_toolset = spec.get('toolset')
  SetVariable(output, 'TARGET', target_name)
  SetVariable(output, 'TOOLSET', target_toolset)
  cmake_target_name = namer.CreateCMakeTargetName(qualified_target)
  extra_sources = []
  extra_deps = []
  if 'actions' in spec:
	WriteActions(cmake_target_name, spec['actions'], extra_sources, extra_deps,
				 path_
  if 'rules' in spec:
	WriteRules(cmake_target_name, spec['rules'], extra_sources, extra_deps,
			   path_
  if 'copies' in spec:
	WriteCopies(cmake_target_name, spec['copies'], extra_deps,
				path_
  srcs = spec.get('sources', [])
  def partition(l, p):
	return reduce(lambda x, e: x[not p(e)].append(e) or x, l, ([], []))
  compilable_srcs, other_srcs = partition(srcs, Compilable)
  if target_type == 'executable' and not compilable_srcs and not extra_sources:
	print ('Executable %s has no complilable sources, treating as "none".' %
					   target_name										 )
	target_type = 'none'
  cmake_target_type = cmake_target_type_
  if cmake_target_type is None:
	print ('Target %s has unknown target type %s, skipping.' %
		  (		target_name,			   target_type  ) )
	return
  other_srcs_name = None
  if other_srcs:
	other_srcs_name = cmake_target_name + '__other_srcs'
	SetVariableList(output, other_srcs_name,
		[NormjoinPath(path_
  library_dirs = config.get('library_dirs')
  if library_dirs is not None:
	output.write('link_directories(')
	for library_dir in library_dirs:
	  output.write(' ')
	  output.write(NormjoinPath(path_
	  output.write('\n')
	output.write(')\n')
  output.write(cmake_target_type.command)
  output.write('(')
  output.write(cmake_target_name)
  if cmake_target_type.modifier is not None:
	output.write(' ')
	output.write(cmake_target_type.modifier)
  if other_srcs_name:
	WriteVariable(output, other_srcs_name, ' ')
  output.write('\n')
  for src in compilable_srcs:
	output.write('  ')
	output.write(NormjoinPath(path_
	output.write('\n')
  for extra_source in extra_sources:
	output.write('  ')
	src, _ = extra_source
	output.write(NormjoinPath(path_
	output.write('\n')
  output.write(')\n')
  if target_type != 'none':
	if other_srcs_name:
	  output.write('set_source_files_properties(')
	  WriteVariable(output, other_srcs_name, '')
	  output.write(' PROPERTIES HEADER_FILE_ONLY "TRUE")\n')
	target_output_directory = spec.get('product_dir')
	if target_output_directory is None:
	  if target_type in ('executable', 'loadable_module'):
		target_output_directory = generator_default_variables['PRODUCT_DIR']
	  elif target_type == 'shared_library':
		target_output_directory = '${builddir}/lib.${TOOLSET}'
	  elif spec.get('standalone_static_library', False):
		target_output_directory = generator_default_variables['PRODUCT_DIR']
	  else:
		base_path = gyp.common.RelativePath(os.path.dirname(gyp_file),
											options.toplevel_dir)
		target_output_directory = '${obj}.${TOOLSET}'
		target_output_directory = (
			os.path.join(target_output_directory, base_path))
	cmake_target_output_directory = NormjoinPathForceCMakeSource(
										path_
										target_output_directory)
	SetTargetProperty(output,
		cmake_target_name,
		cmake_target_type.property_modifier + '_OUTPUT_DIRECTORY',
		cmake_target_output_directory)
	default_product_prefix = ''
	default_product_name = target_name
	default_product_ext = ''
	if target_type == 'static_library':
	  static_library_prefix = generator_default_variables['STATIC_LIB_PREFIX']
	  default_product_name = RemovePrefix(default_product_name,
										  static_library_prefix)
	  default_product_prefix = static_library_prefix
	  default_product_ext = generator_default_variables['STATIC_LIB_SUFFIX']
	elif target_type in ('loadable_module', 'shared_library'):
	  shared_library_prefix = generator_default_variables['SHARED_LIB_PREFIX']
	  default_product_name = RemovePrefix(default_product_name,
										  shared_library_prefix)
	  default_product_prefix = shared_library_prefix
	  default_product_ext = generator_default_variables['SHARED_LIB_SUFFIX']
	elif target_type != 'executable':
	  print ('ERROR: What output file should be generated?',
			  'type', target_type, 'target', target_name)
	product_prefix = spec.get('product_prefix', default_product_prefix)
	product_name = spec.get('product_name', default_product_name)
	product_ext = spec.get('product_extension')
	if product_ext:
	  product_ext = '.' + product_ext
	else:
	  product_ext = default_product_ext
	SetTargetProperty(output, cmake_target_name, 'PREFIX', product_prefix)
	SetTargetProperty(output, cmake_target_name,
						cmake_target_type.property_modifier + '_OUTPUT_NAME',
						product_name)
	SetTargetProperty(output, cmake_target_name, 'SUFFIX', product_ext)
	cmake_target_output_basename = product_prefix + product_name + product_ext
	cmake_target_output = os.path.join(cmake_target_output_directory,
									   cmake_target_output_basename)
	SetFileProperty(output, cmake_target_output, 'GENERATED', ['TRUE'], '')
  exclude_
							 else 'FALSE')
  SetTargetProperty(output, cmake_target_name,
					  'EXCLUDE_FROM_ALL', exclude_
  for extra_target_name in extra_deps:
	SetTargetProperty(output, extra_target_name,
						'EXCLUDE_FROM_ALL', exclude_
  includes = config.get('include_dirs')
  if includes:
	includes_name = cmake_target_name + '__include_dirs'
	SetVariableList(output, includes_name,
		[NormjoinPathForceCMakeSource(path_
		 for include in includes])
	output.write('set_property(TARGET ')
	output.write(cmake_target_name)
	output.write(' APPEND PROPERTY INCLUDE_DIRECTORIES ')
	WriteVariable(output, includes_name, '')
	output.write(')\n')
  defines = config.get('defines')
  if defines is not None:
	SetTargetProperty(output,
						cmake_target_name,
						'COMPILE_DEFINITIONS',
						defines,
						';')
  s_sources = []
  c_sources = []
  cxx_sources = []
  for src in srcs:
	_, ext = os.path.splitext(src)
	src_type = COMPILABLE_EXTENSIONS.get(ext, None)
	if src_type == 's':
	  s_sources.append(NormjoinPath(path_
	if src_type == 'cc':
	  c_sources.append(NormjoinPath(path_
	if src_type == 'cxx':
	  cxx_sources.append(NormjoinPath(path_
  for extra_source in extra_sources:
	src, real_source = extra_source
	_, ext = os.path.splitext(real_source)
	src_type = COMPILABLE_EXTENSIONS.get(ext, None)
	if src_type == 's':
	  s_sources.append(NormjoinPath(path_
	if src_type == 'cc':
	  c_sources.append(NormjoinPath(path_
	if src_type == 'cxx':
	  cxx_sources.append(NormjoinPath(path_
  cflags = config.get('cflags', [])
  cflags_c = config.get('cflags_c', [])
  cflags_cxx = config.get('cflags_cc', [])
  if c_sources and not (s_sources or cxx_sources):
	flags = []
	flags.extend(cflags)
	flags.extend(cflags_c)
	SetTargetProperty(output, cmake_target_name, 'COMPILE_FLAGS', flags, ' ')
  elif cxx_sources and not (s_sources or c_sources):
	flags = []
	flags.extend(cflags)
	flags.extend(cflags_cxx)
	SetTargetProperty(output, cmake_target_name, 'COMPILE_FLAGS', flags, ' ')
  else:
	if s_sources and cflags:
	  SetFilesProperty(output, s_sources, 'COMPILE_FLAGS', cflags, ' ')
	if c_sources and (cflags or cflags_c):
	  flags = []
	  flags.extend(cflags)
	  flags.extend(cflags_c)
	  SetFilesProperty(output, c_sources, 'COMPILE_FLAGS', flags, ' ')
	if cxx_sources and (cflags or cflags_cxx):
	  flags = []
	  flags.extend(cflags)
	  flags.extend(cflags_cxx)
	  SetFilesProperty(output, cxx_sources, 'COMPILE_FLAGS', flags, ' ')
  if not c_sources and not cxx_sources and s_sources:
	SetTargetProperty(output, cmake_target_name, 'LINKER_LANGUAGE', ['C'])
  ldflags = config.get('ldflags')
  if ldflags is not None:
	SetTargetProperty(output, cmake_target_name, 'LINK_FLAGS', ldflags, ' ')
  rawDeps = spec.get('dependencies', [])
  static_deps = []
  shared_deps = []
  other_deps = []
  for rawDep in rawDeps:
	dep_cmake_name = namer.CreateCMakeTargetName(rawDep)
	dep_spec = target_dicts.get(rawDep, {})
	dep_target_type = dep_spec.get('type', None)
	if dep_target_type == 'static_library':
	  static_deps.append(dep_cmake_name)
	elif dep_target_type ==  'shared_library':
	  shared_deps.append(dep_cmake_name)
	else:
	  other_deps.append(dep_cmake_name)
  if static_deps or shared_deps or other_deps:
	for extra_dep in extra_deps:
	  output.write('add_dependencies(')
	  output.write(extra_dep)
	  output.write('\n')
	  for deps in (static_deps, shared_deps, other_deps):
		for dep in gyp.common.uniquer(deps):
		  output.write('  ')
		  output.write(dep)
		  output.write('\n')
	  output.write(')\n')
  linkable = target_type in ('executable', 'loadable_module', 'shared_library')
  other_deps.extend(extra_deps)
  if other_deps or (not linkable and (static_deps or shared_deps)):
	output.write('add_dependencies(')
	output.write(cmake_target_name)
	output.write('\n')
	for dep in gyp.common.uniquer(other_deps):
	  output.write('  ')
	  output.write(dep)
	  output.write('\n')
	if not linkable:
	  for deps in (static_deps, shared_deps):
		for lib_dep in gyp.common.uniquer(deps):
		  output.write('  ')
		  output.write(lib_dep)
		  output.write('\n')
	output.write(')\n')
  if linkable:
	external_libs = [lib for lib in spec.get('libraries', []) if len(lib) > 0]
	if external_libs or static_deps or shared_deps:
	  output.write('target_link_libraries(')
	  output.write(cmake_target_name)
	  output.write('\n')
	  if static_deps:
		write_group = circular_libs and len(static_deps) > 1
		if write_group:
		  output.write('-Wl,--start-group\n')
		for dep in gyp.common.uniquer(static_deps):
		  output.write('  ')
		  output.write(dep)
		  output.write('\n')
		if write_group:
		  output.write('-Wl,--end-group\n')
	  if shared_deps:
		for dep in gyp.common.uniquer(shared_deps):
		  output.write('  ')
		  output.write(dep)
		  output.write('\n')
	  if external_libs:
		for lib in gyp.common.uniquer(external_libs):
		  output.write('  ')
		  output.write(lib)
		  output.write('\n')
	  output.write(')\n')
  UnsetVariable(output, 'TOOLSET')
  UnsetVariable(output, 'TARGET')
def GenerateOutputForConfig(target_list, target_dicts, data,
							params, config_to_use):
  options = params['options']
  generator_flags = params['generator_flags']
  generator_dir = os.path.relpath(options.generator_output or '.')
  output_dir = generator_flags.get('output_dir', 'out')
  build_dir = os.path.normpath(os.path.join(generator_dir,
											output_dir,
											config_to_use))
  toplevel_build = os.path.join(options.toplevel_dir, build_dir)
  output_file = os.path.join(toplevel_build, 'CMakeLists.txt')
  gyp.common.EnsureDirExists(output_file)
  output = open(output_file, 'w')
  output.write('cmake_minimum_required(VERSION 2.8.8 FATAL_ERROR)\n')
  output.write('cmake_policy(VERSION 2.8.8)\n')
  _, project_target, _ = gyp.common.ParseQualifiedTarget(target_list[-1])
  output.write('project(')
  output.write(project_target)
  output.write(')\n')
  SetVariable(output, 'configuration', config_to_use)
  output.write('enable_language(ASM)\n')
  SetVariable(output, 'builddir', '${CMAKE_BINARY_DIR}')
  SetVariable(output, 'obj', '${builddir}/obj')
  output.write('\n')
  output.write('set(CMAKE_C_OUTPUT_EXTENSION_REPLACE 1)\n')
  output.write('set(CMAKE_CXX_OUTPUT_EXTENSION_REPLACE 1)\n')
  output.write('\n')
  namer = CMakeNamer(target_list)
  all_qualified_targets = set()
  for build_file in params['build_files']:
	for qualified_target in gyp.common.AllTargets(target_list,
												  target_dicts,
												  os.path.normpath(build_file)):
	  all_qualified_targets.add(qualified_target)
  for qualified_target in target_list:
	WriteTarget(namer, qualified_target, target_dicts, build_dir, config_to_use,
				options, generator_flags, all_qualified_targets, output)
  output.close()
def PerformBuild(data, configurations, params):
  options = params['options']
  generator_flags = params['generator_flags']
  generator_dir = os.path.relpath(options.generator_output or '.')
  output_dir = generator_flags.get('output_dir', 'out')
  for config_name in configurations:
	build_dir = os.path.normpath(os.path.join(generator_dir,
											  output_dir,
											  config_name))
	arguments = ['cmake', '-G', 'Ninja']
	print 'Generating [%s]: %s' % (config_name, arguments)
	subprocess.check_call(arguments, cwd=build_dir)
	arguments = ['ninja', '-C', build_dir]
	print 'Building [%s]: %s' % (config_name, arguments)
	subprocess.check_call(arguments)
def CallGenerateOutputForConfig(arglist):
  signal.signal(signal.SIGINT, signal.SIG_IGN)
  target_list, target_dicts, data, params, config_name = arglist
  GenerateOutputForConfig(target_list, target_dicts, data, params, config_name)
def GenerateOutput(target_list, target_dicts, data, params):
  user_config = params.get('generator_flags', {}).get('config', None)
  if user_config:
	GenerateOutputForConfig(target_list, target_dicts, data,
							params, user_config)
  else:
	config_names = target_dicts[target_list[0]]['configurations'].keys()
	if params['parallel']:
	  try:
		pool = multiprocessing.Pool(len(config_names))
		arglists = []
		for config_name in config_names:
		  arglists.append((target_list, target_dicts, data,
						   params, config_name))
		  pool.map(CallGenerateOutputForConfig, arglists)
	  except KeyboardInterrupt, e:
		pool.terminate()
		raise e
	else:
	  for config_name in config_names:
		GenerateOutputForConfig(target_list, target_dicts, data,
								params, config_name)