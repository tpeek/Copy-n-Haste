generator_wants_static_library_dependencies_adjusted = False
generator_default_variables = {
}
for dirname in ['INTERMEDIATE_DIR', 'PRODUCT_DIR', 'LIB_DIR', 'SHARED_LIB_DIR']:
  generator_default_variables[dirname] = '$' + dirname
for unused in ['RULE_INPUT_PATH', 'RULE_INPUT_ROOT', 'RULE_INPUT_NAME',
			   'RULE_INPUT_DIRNAME', 'RULE_INPUT_EXT',
			   'EXECUTABLE_PREFIX', 'EXECUTABLE_SUFFIX',
			   'STATIC_LIB_PREFIX', 'STATIC_LIB_SUFFIX',
			   'SHARED_LIB_PREFIX', 'SHARED_LIB_SUFFIX',
			   'CONFIGURATION_NAME']:
  generator_default_variables[unused] = ''
generator_default_variables['SHARED_INTERMEDIATE_DIR'] = \
	'$SHARED_INTERMEDIATE_DIR'
def CalculateVariables(default_variables, params):
  generator_flags = params.get('generator_flags', {})
  for key, val in generator_flags.items():
	default_variables.setdefault(key, val)
  flavor = gyp.common.GetFlavor(params)
  default_variables.setdefault('OS', flavor)
  if flavor == 'win':
	generator_additional_non_configuration_keys = getattr(msvs_generator,
		'generator_additional_non_configuration_keys', [])
	generator_additional_path_sections = getattr(msvs_generator,
		'generator_additional_path_sections', [])
	gyp.msvs_emulation.CalculateCommonVariables(default_variables, params)
def CalculateGeneratorInputInfo(params):
  generator_flags = params.get('generator_flags', {})
  if generator_flags.get('adjust_static_libraries', False):
	global generator_wants_static_library_dependencies_adjusted
	generator_wants_static_library_dependencies_adjusted = True
def GetAllIncludeDirectories(target_list, target_dicts,
							 shared_intermediate_dirs, config_name, params,
							 compiler_path):
  gyp_includes_set = set()
  compiler_includes_list = []
  if compiler_path:
	command = shlex.split(compiler_path)
	command.extend(['-E', '-xc++', '-v', '-'])
	proc = subprocess.Popen(args=command, stdin=subprocess.PIPE,
							stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	output = proc.communicate()[1]
	in_include_list = False
	for line in output.splitlines():
	  if line.startswith('
		in_include_list = True
		continue
	  if line.startswith('End of search list.'):
		break
	  if in_include_list:
		include_dir = line.strip()
		if include_dir not in compiler_includes_list:
		  compiler_includes_list.append(include_dir)
  flavor = gyp.common.GetFlavor(params)
  if flavor == 'win':
	generator_flags = params.get('generator_flags', {})
  for target_name in target_list:
	target = target_dicts[target_name]
	if config_name in target['configurations']:
	  config = target['configurations'][config_name]
	  if flavor == 'win':
		msvs_settings = gyp.msvs_emulation.MsvsSettings(target, generator_flags)
		cflags = msvs_settings.GetCflags(config_name)
	  else:
		cflags = config['cflags']
	  for cflag in cflags:
		if cflag.startswith('-I'):
		  include_dir = cflag[2:]
		  if include_dir not in compiler_includes_list:
			compiler_includes_list.append(include_dir)
	  if config.has_key('include_dirs'):
		include_dirs = config['include_dirs']
		for shared_intermediate_dir in shared_intermediate_dirs:
		  for include_dir in include_dirs:
			include_dir = include_dir.replace('$SHARED_INTERMEDIATE_DIR',
											  shared_intermediate_dir)
			if not os.path.isabs(include_dir):
			  base_dir = os.path.dirname(target_name)
			  include_dir = base_dir + '/' + include_dir
			  include_dir = os.path.abspath(include_dir)
			gyp_includes_set.add(include_dir)
  all_includes_list = list(gyp_includes_set)
  all_includes_list.sort()
  for compiler_include in compiler_includes_list:
	if not compiler_include in gyp_includes_set:
	  all_includes_list.append(compiler_include)
  return all_includes_list
def GetCompilerPath(target_list, data, options):
  build_file, _, _ = gyp.common.ParseQualifiedTarget(target_list[0])
  make_global_settings_dict = data[build_file].get('make_global_settings', {})
  for key, value in make_global_settings_dict:
	if key in ['CC', 'CXX']:
	  return os.path.join(options.toplevel_dir, value)
  for key in ['CC_target', 'CC', 'CXX']:
	compiler = os.environ.get(key)
	if compiler:
	  return compiler
  return 'gcc'
def GetAllDefines(target_list, target_dicts, data, config_name, params,
				  compiler_path):
  all_defines = {}
  flavor = gyp.common.GetFlavor(params)
  if flavor == 'win':
	generator_flags = params.get('generator_flags', {})
  for target_name in target_list:
	target = target_dicts[target_name]
	if flavor == 'win':
	  msvs_settings = gyp.msvs_emulation.MsvsSettings(target, generator_flags)
	  extra_defines = msvs_settings.GetComputedDefines(config_name)
	else:
	  extra_defines = []
	if config_name in target['configurations']:
	  config = target['configurations'][config_name]
	  target_defines = config['defines']
	else:
	  target_defines = []
	for define in target_defines + extra_defines:
	  split_define = define.split('=', 1)
	  if len(split_define) == 1:
		split_define.append('1')
	  if split_define[0].strip() in all_defines:
		continue
	  all_defines[split_define[0].strip()] = split_define[1].strip()
  if flavor == 'win':
	return all_defines
  if compiler_path:
	command = shlex.split(compiler_path)
	command.extend(['-E', '-dM', '-'])
	cpp_proc = subprocess.Popen(args=command, cwd='.',
								stdin=subprocess.PIPE, stdout=subprocess.PIPE)
	cpp_output = cpp_proc.communicate()[0]
	cpp_lines = cpp_output.split('\n')
	for cpp_line in cpp_lines:
	  if not cpp_line.strip():
		continue
	  cpp_line_parts = cpp_line.split(' ', 2)
	  key = cpp_line_parts[1]
	  if len(cpp_line_parts) >= 3:
		val = cpp_line_parts[2]
	  else:
		val = '1'
	  all_defines[key] = val
  return all_defines
def WriteIncludePaths(out, eclipse_langs, include_dirs):
  out.write('  <section name="org.eclipse.cdt.internal.ui.wizards.' \
			'settingswizards.IncludePaths">\n')
  out.write('	<language name="holder for library settings"></language>\n')
  for lang in eclipse_langs:
	out.write('	<language name="%s">\n' % lang)
	for include_dir in include_dirs:
	  out.write('	  <includepath workspace_path="false">%s</includepath>\n' %
				include_dir)
	out.write('	</language>\n')
  out.write('  </section>\n')
def WriteMacros(out, eclipse_langs, defines):
  out.write('  <section name="org.eclipse.cdt.internal.ui.wizards.' \
			'settingswizards.Macros">\n')
  out.write('	<language name="holder for library settings"></language>\n')
  for lang in eclipse_langs:
	out.write('	<language name="%s">\n' % lang)
	for key in sorted(defines.iterkeys()):
	  out.write('	  <macro><name>%s</name><value>%s</value></macro>\n' %
				(escape(key), escape(defines[key])))
	out.write('	</language>\n')
  out.write('  </section>\n')
def GenerateOutputForConfig(target_list, target_dicts, data, params,
							config_name):
  options = params['options']
  generator_flags = params.get('generator_flags', {})
  build_dir = os.path.join(generator_flags.get('output_dir', 'out'),
						   config_name)
  toplevel_build = os.path.join(options.toplevel_dir, build_dir)
  shared_intermediate_dirs = [os.path.join(toplevel_build, 'obj', 'gen'),
							  os.path.join(toplevel_build, 'gen')]
  GenerateCdtSettingsFile(target_list,
						  target_dicts,
						  data,
						  params,
						  config_name,
						  os.path.join(toplevel_build,
									   'eclipse-cdt-settings.xml'),
						  options,
						  shared_intermediate_dirs)
  GenerateClasspathFile(target_list,
						target_dicts,
						options.toplevel_dir,
						toplevel_build,
						os.path.join(toplevel_build,
									 'eclipse-classpath.xml'))
def GenerateCdtSettingsFile(target_list, target_dicts, data, params,
							config_name, out_name, options,
							shared_intermediate_dirs):
  gyp.common.EnsureDirExists(out_name)
  with open(out_name, 'w') as out:
	out.write('<?xml version="1.0" encoding="UTF-8"?>\n')
	out.write('<cdtprojectproperties>\n')
	eclipse_langs = ['C++ Source File', 'C Source File', 'Assembly Source File',
					 'GNU C++', 'GNU C', 'Assembly']
	compiler_path = GetCompilerPath(target_list, data, options)
	include_dirs = GetAllIncludeDirectories(target_list, target_dicts,
											shared_intermediate_dirs,
											config_name, params, compiler_path)
	WriteIncludePaths(out, eclipse_langs, include_dirs)
	defines = GetAllDefines(target_list, target_dicts, data, config_name,
							params, compiler_path)
	WriteMacros(out, eclipse_langs, defines)
	out.write('</cdtprojectproperties>\n')
def GenerateClasspathFile(target_list, target_dicts, toplevel_dir,
						  toplevel_build, out_name):
  gyp.common.EnsureDirExists(out_name)
  result = ET.Element('classpath')
  def AddElements(kind, paths):
	rel_paths = set()
	for path in paths:
	  if os.path.isabs(path):
		rel_paths.add(os.path.relpath(path, toplevel_dir))
	  else:
		rel_paths.add(path)
	for path in sorted(rel_paths):
	  entry_element = ET.SubElement(result, 'classpathentry')
	  entry_element.set('kind', kind)
	  entry_element.set('path', path)
  AddElements('lib', GetJavaJars(target_list, target_dicts, toplevel_dir))
  AddElements('src', GetJavaSourceDirs(target_list, target_dicts, toplevel_dir))
  AddElements('con', ['org.eclipse.jdt.launching.JRE_CONTAINER'])
  AddElements('output', [os.path.join(toplevel_build, '.eclipse-java-build')])
  ET.ElementTree(result).write(out_name)
def GetJavaJars(target_list, target_dicts, toplevel_dir):
  for target_name in target_list:
	target = target_dicts[target_name]
	for action in target.get('actions', []):
	  for input_ in action['inputs']:
		if os.path.splitext(input_)[1] == '.jar' and not input_.startswith('$'):
		  if os.path.isabs(input_):
			yield input_
		  else:
			yield os.path.join(os.path.dirname(target_name), input_)
def GetJavaSourceDirs(target_list, target_dicts, toplevel_dir):
  for target_name in target_list:
	target = target_dicts[target_name]
	for action in target.get('actions', []):
	  for input_ in action['inputs']:
		if (os.path.splitext(input_)[1] == '.java' and
			not input_.startswith('$')):
		  dir_ = os.path.dirname(os.path.join(os.path.dirname(target_name),
											  input_))
		  parent_search = dir_
		  while os.path.basename(parent_search) not in ['src', 'java']:
			parent_search, _ = os.path.split(parent_search)
			if not parent_search or parent_search == toplevel_dir:
			  yield dir_
			  break
		  else:
			yield parent_search
def GenerateOutput(target_list, target_dicts, data, params):
  if params['options'].generator_output:
	raise NotImplementedError("--generator_output not implemented for eclipse")
  user_config = params.get('generator_flags', {}).get('config', None)
  if user_config:
	GenerateOutputForConfig(target_list, target_dicts, data, params,
							user_config)
  else:
	config_names = target_dicts[target_list[0]]['configurations'].keys()
	for config_name in config_names:
	  GenerateOutputForConfig(target_list, target_dicts, data, params,
							  config_name)