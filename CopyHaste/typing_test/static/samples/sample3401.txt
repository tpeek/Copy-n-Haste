_state = {'port_count': 0}
def _refresh_port_list():
	if _state['port_count'] == 0:
		pm.lib.Pm_Terminate()
		pm.lib.Pm_Initialize()
def _check_error(return_value):
	if return_value < 0:
		raise IOError(pm.lib.Pm_GetErrorText(return_value))
	
	
def _get_device(device_id):
	device = {}
	
	info_pointer = pm.lib.Pm_GetDeviceInfo(device_id)
	if not info_pointer:
		raise IOError('PortMidi device with id={} not found'.format(
			device_id))
	info = info_pointer.contents
	 
	return {
		'id': device_id,
		'interface': info.interface.decode('utf-8'),
		'name': info.name.decode('utf-8'),
		'is_input': info.is_input,
		'is_output': info.is_output,
		'opened': bool(info.opened),
	}
def _get_default_device(get_input):
	if get_input:
		device_id = pm.lib.Pm_GetDefaultInputDeviceID()
	else:
		device_id = pm.lib.Pm_GetDefaultOutputDeviceID()
		
	if device_id < 0:
		raise IOError('no default port found')
	
	return _get_device(device_id)
def _get_named_device(name, get_input):
	for device in get_devices():
		if device['name'] != name:
			continue
		if get_input:
			if device['is_output']:
				continue
		else:
			if device['is_input']:
				continue
		if device['opened']:
			raise IOError('port already opened: {!r}'.format(name))
		return device
	else:
		raise IOError('unknown port {!r}'.format(name))
def get_devices(**kwargs):
	_refresh_port_list()
	return [_get_device(i) for i in range(pm.lib.Pm_CountDevices())]
class PortCommon(object):
	def _open(self, **kwargs):
		_refresh_port_list()
		if 'virtual' in kwargs and kwargs['virtual'] == True:
			raise IOError(
				"virtual ports are not supported by the PortMidi backend")
		self._stream = pm.PortMidiStreamPtr()
		opening_input = hasattr(self, 'receive')
		if self.name is None:
			device = _get_default_device(opening_input)
			self.name = device['name']
		else:
			device = _get_named_device(self.name, opening_input)
		if device['opened']:
			if opening_input:
				devtype = 'input'
			else:
				devtype = 'output'
			raise IOError('{} port {!r} is already open'.format(devtype,
																self.name))
		
		if opening_input:
			_check_error(pm.lib.Pm_OpenInput(
						 pm.byref(self._stream),
						 device['id'],
						 pm.null,
						 1000,
						 pm.NullTimeProcPtr,
						 pm.null))
		else:
			_check_error(pm.lib.Pm_OpenOutput(
						 pm.byref(self._stream),
						 device['id'],
						 pm.null,
						 0,
						 pm.NullTimeProcPtr,
						 pm.null,
						 0))
		self.closed = False
		_state['port_count'] += 1
 
		if opening_input and self.callback:
			self._callback_thread = threading.Thread(
				target=self._thread_main)
			self._callback_thread.daemon = True
			self._callback_thread.start()
			self._messages = deque()
		self._device_type = 'PortMidi/{}'.format(device['interface'])
	def _close(self):
		_check_error(pm.lib.Pm_Close(self._stream))
		_state['port_count'] -= 1
class Input(PortCommon, BaseInput):
	def _receive(self, block=True):
		max_events = 1
		BufferType = pm.PmEvent * max_events
		read_buffer = BufferType()
		while pm.lib.Pm_Poll(self._stream):
			length = 1
			num_events = pm.lib.Pm_Read(self._stream, read_buffer, length)
			_check_error(num_events)
			event = read_buffer[0]
			packed_message = event.message & 0xffffffff
			for i in range(4):
				byte = packed_message & 0xff
				self._parser.feed_byte(byte)
				packed_message >>= 8
	def _thread_main(self):
		try:
			while True:
				self._receive()
				for message in self._parser:
					if self.callback:
						self.callback(message)
				sleep()
		except IOError:
			if self.closed:
				return
			else:
				raise
	def _close(self):
		self.callback = False
		PortCommon._close(self)
class Output(PortCommon, BaseOutput):
	def _send(self, message):
		if message.type == 'sysex':
			string = pm.c_char_p(bytes(message.bin()))
			timestamp = 0
			_check_error(pm.lib.Pm_WriteSysEx(self._stream, timestamp, string))
		else:
			packed_message = 0
			for byte in reversed(message.bytes()):
				packed_message <<= 8
				packed_message |= byte
			timestamp = 0
			_check_error(pm.lib.Pm_WriteShort(self._stream,
											  timestamp,
											  packed_message))