__date__='06/01/15'
__author__='suchet'
def evaluate_max_f1(true_labels, probs, threshold=None, verbose=True, plot_f1=False, primary_class=1):
	if threshold is not None:
		predictions = 1*(probs[:, primary_class]>threshold)
		pout, rout, fout, _= precision_recall_fscore_support(true_labels, predictions)
		precision, recall, f_score = pout[primary_class], rout[primary_class], fout[primary_class]
		if verbose:
			print 'F1 score: {}'.format(f_score)
			print 'Precision: {}'.format(precision)
			print 'Recall: {}'.format(recall)
			print 'Threshold applied: {}'.format(threshold)
	else:
		p, r, th = precision_recall_curve(true_labels, probs[:, primary_class])
		f1 = 2*(p*r)/(p+r)
		f_score = np.nanmax(f1)
		precision = p[f1 == np.nanmax(f1)]
		recall = r[f1 == np.nanmax(f1)]
		threshold = th[np.where(f1 == np.nanmax(f1))]
		if plot_f1:
			plt.figure()
			plt.plot(np.hstack([0, th]), p)
			plt.plot(np.hstack([0, th]), r)
			plt.plot(np.hstack([0, th]), f1)
			plt.legend(['precision', 'recall','f1-score'], loc=0)
			plt.show()
		if verbose:
			print 'Max f1 score: {}'.format(np.nanmax(f1))
			print 'Precision at max: {}'.format(p[f1 == np.nanmax(f1)])
			print 'Recall at max: {}'.format(r[f1 == np.nanmax(f1)])
			print 'Threshold at max: {}'.format(th[np.where(f1 == np.nanmax(f1))])
	return f_score, precision, recall, threshold
def evaluate_binary_image_score(threshold_images, labels, crop_pixels=32, verbose=True):
	if crop_pixels is not None:
		internal_notify('Croping the edge {} pixels'.format(crop_pixels), verbose)
		threshold_images = threshold_images[:,crop_pixels:-crop_pixels, crop_pixels:-crop_pixels]
		labels = labels[:,crop_pixels:-crop_pixels, crop_pixels:-crop_pixels]
	internal_notify('Evaluating F1-score on input size {}'.format(threshold_images.shape), verbose)
	predictions = threshold_images.ravel()
	pout, rout, fout, _= precision_recall_fscore_support(labels.ravel(), predictions, labels=[0, 1])
	precision, recall, f_score = pout[1], rout[1], fout[1]
	return f_score, precision, recall
def evaluate_image_score(prob_images, labels, primary_class = 1, threshold=None, crop_pixels=32, verbose=True, plot_on=False):
	assert np.ndim(prob_images)==4
	assert np.ndim(labels)==3
	if crop_pixels is not None:
		internal_notify('Croping the edge {} pixels'.format(crop_pixels), verbose)
		prob_images = prob_images[:,crop_pixels:-crop_pixels, crop_pixels:-crop_pixels, :]
		labels = labels[:,crop_pixels:-crop_pixels, crop_pixels:-crop_pixels]
	if threshold is not None:
		internal_notify('Evaluating F1-score on input size {}'.format(prob_images.shape), verbose)
		predictions = 1*(prob_images[...,primary_class].ravel()>threshold)
		pout, rout, fout, _= precision_recall_fscore_support(labels.ravel(), predictions, labels=[0, 1])
		precision, recall, f_score = pout[primary_class], rout[primary_class], fout[primary_class]
	else:
		if verbose:
			print 'Evaluating Maximum f1-score on input size {}'.format(prob_images.shape)
		delta_threshold = 0.01
		th_min = 0.4
		threshold_vector = np.arange(th_min+delta_threshold, 1., delta_threshold)
		pvec = np.zeros(threshold_vector.shape)
		rvec = np.zeros(threshold_vector.shape)
		f1vec = np.zeros(threshold_vector.shape)
		for (i, th) in enumerate(threshold_vector):
			predictions = 1*(prob_images[...,primary_class].ravel()>th)
			pout, rout, fout, _= precision_recall_fscore_support(labels.ravel(), predictions)
			pvec[i], rvec[i], f1vec[i] = pout[primary_class], rout[primary_class], fout[primary_class]
		if plot_on:
			plt.figure()
			plt.plot(threshold_vector, pvec)
			plt.plot(threshold_vector, rvec)
			plt.plot(threshold_vector, f1vec)
			plt.legend(['precision', 'recall','f1-score'], loc=0)
			plt.show()
		f_score = np.nanmax(f1vec)
		precision = pvec[f1vec == np.nanmax(f1vec)][0]
		recall = rvec[f1vec == np.nanmax(f1vec)][0]
		threshold = threshold_vector[np.where(f1vec == np.nanmax(f1vec))][0]
	if verbose:
		print 'F1 score: {}'.format(f_score)
		print 'Precision: {}'.format(precision)
		print 'Recall: {}'.format(recall)
		print 'Threshold: {}'.format(threshold)
	return f_score, precision, recall, threshold
def evaluate_image_score_with_smoothing(prob_images, labels, optimal_threshold, morph_radius=3, crop_pixels=32, verbose=False):
	if verbose:
		print 'Optimal Threshold: {}'.format(optimal_threshold)
	all_threshold_images = np.zeros(labels.shape)
	for img_idx in range(prob_images.shape[0]):
		prob_image = prob_images[img_idx, ...]
		current_threshold_image = 1*(prob_image[..., -1] > optimal_threshold)
		all_threshold_images[img_idx, ...] = image_opening(current_threshold_image.astype('uint8'), morph_radius)
	fscore, precision, recall = evaluate_binary_image_score(all_threshold_images, labels, verbose=False, crop_pixels=crop_pixels)
	if verbose:
		print 'Fscore: {}, Precision: {}, Recall: {}'.format(fscore, precision, recall)
	return fscore, precision, recall, optimal_threshold
def crop_2d_data(data, crop_pixels=32):
	data_out = data[crop_pixels:-crop_pixels, crop_pixels:-crop_pixels]
	return data_out
def eval_detection_results(true_positives, false_positives, false_negatives):
	precision = true_positives/float(true_positives+false_positives)
	recall = true_positives/float(true_positives+false_negatives)
	f1score = 2*(precision*recall)/float(precision+recall)
	return f1score, precision, recall
def get_image_detection_results(image, ground_truth, min_joint_area, min_area, min_dist, crop_pixels=32):
	gt_segments, pred_segments = [get_blob_segments(seg_img, min_joint_area, crop_pixels, min_area) for seg_img in [ground_truth, image]]
	tp, fp, fn = segment_centroid_matching(gt_segments,
										   pred_segments,
										   min_dist=min_dist)
	return tp, fp, fn
def evaluate_image_score_with_detection(prob_images, labels, optimal_threshold, morph_radius=3, crop_pixels=32, detection_params=None):
	true_positives = 0
	false_positives = 0
	false_negatives = 0
	for img_idx in range(prob_images.shape[0]):
		gt_label_raw = labels[img_idx, ...]
		gt_label = image_opening(gt_label_raw, disk_radius=morph_radius)*255
		prob_image = prob_images[img_idx, ...]
		current_threshold_image = 1*(prob_image[..., -1] > optimal_threshold)
		current_threshold_image = image_opening(current_threshold_image.astype('uint8'), disk_radius=morph_radius)
		pred_label = current_threshold_image*255
		gt_segments, pred_segments = [watershed_segments(img, min_joining_seg=detection_params['min_joint_area']) for img in [gt_label, pred_label]]
		gt_segments, pred_segments = [crop_2d_data(seg_img, crop_pixels=crop_pixels) for seg_img in [gt_segments, pred_segments]]
		gt_segments, pred_segments = [remove_small_segments(seg_img, min_size=detection_params['min_area']) for seg_img in [gt_segments, pred_segments]]
		tp, fp, fn = segment_centroid_matching(gt_segments,
											   pred_segments,
											   min_dist=detection_params['min_dist'])
		true_positives += len(tp)
		false_positives += len(fp)
		false_negatives += len(fn)
	f1score, precision, recall = eval_detection_results(true_positives, false_positives, false_negatives)
	return f1score, precision, recall, optimal_threshold