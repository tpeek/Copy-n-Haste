__about__ =
__all__ = ['heappush', 'heappop', 'heapify', 'heapreplace', 'merge',
		   'nlargest', 'nsmallest', 'heappushpop']
def heappush(heap, item):
	heap.append(item)
	_siftdown(heap, 0, len(heap)-1)
def heappop(heap):
	lastelt = heap.pop()
	if heap:
		returnitem = heap[0]
		heap[0] = lastelt
		_siftup(heap, 0)
		return returnitem
	return lastelt
def heapreplace(heap, item):
	returnitem = heap[0]
	heap[0] = item
	_siftup(heap, 0)
	return returnitem
def heappushpop(heap, item):
	if heap and heap[0] < item:
		item, heap[0] = heap[0], item
		_siftup(heap, 0)
	return item
def heapify(x):
	n = len(x)
	for i in reversed(range(n//2)):
		_siftup(x, i)
def _heappop_max(heap):
	lastelt = heap.pop()
	if heap:
		returnitem = heap[0]
		heap[0] = lastelt
		_siftup_max(heap, 0)
		return returnitem
	return lastelt
def _heapreplace_max(heap, item):
	returnitem = heap[0]
	heap[0] = item
	_siftup_max(heap, 0)
	return returnitem
def _heapify_max(x):
	n = len(x)
	for i in reversed(range(n//2)):
		_siftup_max(x, i)
def _siftdown(heap, startpos, pos):
	newitem = heap[pos]
	while pos > startpos:
		parentpos = (pos - 1) >> 1
		parent = heap[parentpos]
		if newitem < parent:
			heap[pos] = parent
			pos = parentpos
			continue
		break
	heap[pos] = newitem
def _siftup(heap, pos):
	endpos = len(heap)
	startpos = pos
	newitem = heap[pos]
	childpos = 2*pos + 1
	while childpos < endpos:
		rightpos = childpos + 1
		if rightpos < endpos and not heap[childpos] < heap[rightpos]:
			childpos = rightpos
		heap[pos] = heap[childpos]
		pos = childpos
		childpos = 2*pos + 1
	heap[pos] = newitem
	_siftdown(heap, startpos, pos)
def _siftdown_max(heap, startpos, pos):
	'Maxheap variant of _siftdown'
	newitem = heap[pos]
	while pos > startpos:
		parentpos = (pos - 1) >> 1
		parent = heap[parentpos]
		if parent < newitem:
			heap[pos] = parent
			pos = parentpos
			continue
		break
	heap[pos] = newitem
def _siftup_max(heap, pos):
	'Maxheap variant of _siftup'
	endpos = len(heap)
	startpos = pos
	newitem = heap[pos]
	childpos = 2*pos + 1
	while childpos < endpos:
		rightpos = childpos + 1
		if rightpos < endpos and not heap[rightpos] < heap[childpos]:
			childpos = rightpos
		heap[pos] = heap[childpos]
		pos = childpos
		childpos = 2*pos + 1
	heap[pos] = newitem
	_siftdown_max(heap, startpos, pos)
def merge(iterables, key=None, reverse=False):
	h = []
	h_append = h.append
	if reverse:
		_heapify = _heapify_max
		_heappop = _heappop_max
		_heapreplace = _heapreplace_max
		direction = -1
	else:
		_heapify = heapify
		_heappop = heappop
		_heapreplace = heapreplace
		direction = 1
	if key is None:
		for order, it in enumerate(map(iter, iterables)):
			try:
				h_append([next(it), order * direction, it])
			except StopIteration:
				pass
		_heapify(h)
		while len(h) > 1:
			try:
				while True:
					value, order, it = s = h[0]
					yield value
					s[0] = next(it)
					_heapreplace(h, s)
			except StopIteration:
				_heappop(h)
		if h:
			value, order, it = h[0]
			yield value
			for value in it:
				yield value
		return
	for order, it in enumerate(map(iter, iterables)):
		try:
			value = next(it)
			h_append([key(value), order * direction, value, it])
		except StopIteration:
			pass
	_heapify(h)
	while len(h) > 1:
		try:
			while True:
				key_value, order, value, it = s = h[0]
				yield value
				value = next(it)
				s[0] = key(value)
				s[2] = value
				_heapreplace(h, s)
		except StopIteration:
			_heappop(h)
	if h:
		key_value, order, value, it = h[0]
		yield value
		for value in it:
			yield value
def nsmallest(n, iterable, key=None):
	if n == 1:
		it = iter(iterable)
		sentinel = object()
		if key is None:
			result = min(it, default=sentinel)
		else:
			result = min(it, default=sentinel, key=key)
		return [] if result is sentinel else [result]
	try:
		size = len(iterable)
	except (TypeError, AttributeError):
		pass
	else:
		if n >= size:
			return sorted(iterable, key=key)[:n]
	if key is None:
		it = iter(iterable)
		result = [(elem, i) for i, elem in zip(range(n), it)]
		if not result:
			return result
		_heapify_max(result)
		top = result[0][0]
		order = n
		_heapreplace = _heapreplace_max
		for elem in it:
			if elem < top:
				_heapreplace(result, (elem, order))
				top = result[0][0]
				order += 1
		result.sort()
		return [r[0] for r in result]
	it = iter(iterable)
	result = [(key(elem), i, elem) for i, elem in zip(range(n), it)]
	if not result:
		return result
	_heapify_max(result)
	top = result[0][0]
	order = n
	_heapreplace = _heapreplace_max
	for elem in it:
		k = key(elem)
		if k < top:
			_heapreplace(result, (k, order, elem))
			top = result[0][0]
			order += 1
	result.sort()
	return [r[2] for r in result]
def nlargest(n, iterable, key=None):
	if n == 1:
		it = iter(iterable)
		sentinel = object()
		if key is None:
			result = max(it, default=sentinel)
		else:
			result = max(it, default=sentinel, key=key)
		return [] if result is sentinel else [result]
	try:
		size = len(iterable)
	except (TypeError, AttributeError):
		pass
	else:
		if n >= size:
			return sorted(iterable, key=key, reverse=True)[:n]
	if key is None:
		it = iter(iterable)
		result = [(elem, i) for i, elem in zip(range(0, -n, -1), it)]
		if not result:
			return result
		heapify(result)
		top = result[0][0]
		order = -n
		_heapreplace = heapreplace
		for elem in it:
			if top < elem:
				_heapreplace(result, (elem, order))
				top = result[0][0]
				order -= 1
		result.sort(reverse=True)
		return [r[0] for r in result]
	it = iter(iterable)
	result = [(key(elem), i, elem) for i, elem in zip(range(0, -n, -1), it)]
	if not result:
		return result
	heapify(result)
	top = result[0][0]
	order = -n
	_heapreplace = heapreplace
	for elem in it:
		k = key(elem)
		if top < k:
			_heapreplace(result, (k, order, elem))
			top = result[0][0]
			order -= 1
	result.sort(reverse=True)
	return [r[2] for r in result]
try:
except ImportError:
	pass
try:
except ImportError:
	pass
try:
except ImportError:
	pass
try:
except ImportError:
	pass
if __name__ == "__main__":
	(failure_count, test_count) = doctest.testmod()
	if failure_count:
		exit(-1)