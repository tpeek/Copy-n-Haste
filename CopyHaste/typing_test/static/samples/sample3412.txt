if sys.version >= '3':
	long = int
__all__ = ['DistributedMatrix', 'RowMatrix', 'IndexedRow',
		   'IndexedRowMatrix', 'MatrixEntry', 'CoordinateMatrix',
		   'BlockMatrix']
class DistributedMatrix(object):
	def numRows(self):
		raise NotImplementedError
	def numCols(self):
		raise NotImplementedError
class RowMatrix(DistributedMatrix):
	def __init__(self, rows, numRows=0, numCols=0):
		if isinstance(rows, RDD):
			rows = rows.map(_convert_to_vector)
			java_matrix = callMLlibFunc("createRowMatrix", rows, long(numRows), int(numCols))
		elif (isinstance(rows, JavaObject)
			  and rows.getClass().getSimpleName() == "RowMatrix"):
			java_matrix = rows
		else:
			raise TypeError("rows should be an RDD of vectors, got %s" % type(rows))
		self._java_matrix_wrapper = JavaModelWrapper(java_matrix)
	@property
	def rows(self):
		return self._java_matrix_wrapper.call("rows")
	def numRows(self):
		return self._java_matrix_wrapper.call("numRows")
	def numCols(self):
		return self._java_matrix_wrapper.call("numCols")
class IndexedRow(object):
	def __init__(self, index, vector):
		self.index = long(index)
		self.vector = _convert_to_vector(vector)
	def __repr__(self):
		return "IndexedRow(%s, %s)" % (self.index, self.vector)
def _convert_to_indexed_row(row):
	if isinstance(row, IndexedRow):
		return row
	elif isinstance(row, tuple) and len(row) == 2:
		return IndexedRow(*row)
	else:
		raise TypeError("Cannot convert type %s into IndexedRow" % type(row))
class IndexedRowMatrix(DistributedMatrix):
	def __init__(self, rows, numRows=0, numCols=0):
		if isinstance(rows, RDD):
			rows = rows.map(_convert_to_indexed_row)
			java_matrix = callMLlibFunc("createIndexedRowMatrix", rows.toDF(),
										long(numRows), int(numCols))
		elif (isinstance(rows, JavaObject)
			  and rows.getClass().getSimpleName() == "IndexedRowMatrix"):
			java_matrix = rows
		else:
			raise TypeError("rows should be an RDD of IndexedRows or (long, vector) tuples, "
							"got %s" % type(rows))
		self._java_matrix_wrapper = JavaModelWrapper(java_matrix)
	@property
	def rows(self):
		rows_df = callMLlibFunc("getIndexedRows", self._java_matrix_wrapper._java_model)
		rows = rows_df.map(lambda row: IndexedRow(row[0], row[1]))
		return rows
	def numRows(self):
		return self._java_matrix_wrapper.call("numRows")
	def numCols(self):
		return self._java_matrix_wrapper.call("numCols")
	def toRowMatrix(self):
		java_row_matrix = self._java_matrix_wrapper.call("toRowMatrix")
		return RowMatrix(java_row_matrix)
	def toCoordinateMatrix(self):
		java_coordinate_matrix = self._java_matrix_wrapper.call("toCoordinateMatrix")
		return CoordinateMatrix(java_coordinate_matrix)
	def toBlockMatrix(self, rowsPerBlock=1024, colsPerBlock=1024):
		java_block_matrix = self._java_matrix_wrapper.call("toBlockMatrix",
														   rowsPerBlock,
														   colsPerBlock)
		return BlockMatrix(java_block_matrix, rowsPerBlock, colsPerBlock)
class MatrixEntry(object):
	def __init__(self, i, j, value):
		self.i = long(i)
		self.j = long(j)
		self.value = float(value)
	def __repr__(self):
		return "MatrixEntry(%s, %s, %s)" % (self.i, self.j, self.value)
def _convert_to_matrix_entry(entry):
	if isinstance(entry, MatrixEntry):
		return entry
	elif isinstance(entry, tuple) and len(entry) == 3:
		return MatrixEntry(*entry)
	else:
		raise TypeError("Cannot convert type %s into MatrixEntry" % type(entry))
class CoordinateMatrix(DistributedMatrix):
	def __init__(self, entries, numRows=0, numCols=0):
		if isinstance(entries, RDD):
			entries = entries.map(_convert_to_matrix_entry)
			java_matrix = callMLlibFunc("createCoordinateMatrix", entries.toDF(),
										long(numRows), long(numCols))
		elif (isinstance(entries, JavaObject)
			  and entries.getClass().getSimpleName() == "CoordinateMatrix"):
			java_matrix = entries
		else:
			raise TypeError("entries should be an RDD of MatrixEntry entries or "
							"(long, long, float) tuples, got %s" % type(entries))
		self._java_matrix_wrapper = JavaModelWrapper(java_matrix)
	@property
	def entries(self):
		entries_df = callMLlibFunc("getMatrixEntries", self._java_matrix_wrapper._java_model)
		entries = entries_df.map(lambda row: MatrixEntry(row[0], row[1], row[2]))
		return entries
	def numRows(self):
		return self._java_matrix_wrapper.call("numRows")
	def numCols(self):
		return self._java_matrix_wrapper.call("numCols")
	def toRowMatrix(self):
		java_row_matrix = self._java_matrix_wrapper.call("toRowMatrix")
		return RowMatrix(java_row_matrix)
	def toIndexedRowMatrix(self):
		java_indexed_row_matrix = self._java_matrix_wrapper.call("toIndexedRowMatrix")
		return IndexedRowMatrix(java_indexed_row_matrix)
	def toBlockMatrix(self, rowsPerBlock=1024, colsPerBlock=1024):
		java_block_matrix = self._java_matrix_wrapper.call("toBlockMatrix",
														   rowsPerBlock,
														   colsPerBlock)
		return BlockMatrix(java_block_matrix, rowsPerBlock, colsPerBlock)
def _convert_to_matrix_block_tuple(block):
	if (isinstance(block, tuple) and len(block) == 2
			and isinstance(block[0], tuple) and len(block[0]) == 2
			and isinstance(block[1], Matrix)):
		blockRowIndex = int(block[0][0])
		blockColIndex = int(block[0][1])
		subMatrix = block[1]
		return ((blockRowIndex, blockColIndex), subMatrix)
	else:
		raise TypeError("Cannot convert type %s into a sub-matrix block tuple" % type(block))
class BlockMatrix(DistributedMatrix):
	def __init__(self, blocks, rowsPerBlock, colsPerBlock, numRows=0, numCols=0):
		if isinstance(blocks, RDD):
			blocks = blocks.map(_convert_to_matrix_block_tuple)
			java_matrix = callMLlibFunc("createBlockMatrix", blocks.toDF(),
										int(rowsPerBlock), int(colsPerBlock),
										long(numRows), long(numCols))
		elif (isinstance(blocks, JavaObject)
			  and blocks.getClass().getSimpleName() == "BlockMatrix"):
			java_matrix = blocks
		else:
			raise TypeError("blocks should be an RDD of sub-matrix blocks as "
							"((int, int), matrix) tuples, got %s" % type(blocks))
		self._java_matrix_wrapper = JavaModelWrapper(java_matrix)
	@property
	def blocks(self):
		blocks_df = callMLlibFunc("getMatrixBlocks", self._java_matrix_wrapper._java_model)
		blocks = blocks_df.map(lambda row: ((row[0][0], row[0][1]), row[1]))
		return blocks
	@property
	def rowsPerBlock(self):
		return self._java_matrix_wrapper.call("rowsPerBlock")
	@property
	def colsPerBlock(self):
		return self._java_matrix_wrapper.call("colsPerBlock")
	@property
	def numRowBlocks(self):
		return self._java_matrix_wrapper.call("numRowBlocks")
	@property
	def numColBlocks(self):
		return self._java_matrix_wrapper.call("numColBlocks")
	def numRows(self):
		return self._java_matrix_wrapper.call("numRows")
	def numCols(self):
		return self._java_matrix_wrapper.call("numCols")
	def toLocalMatrix(self):
		return self._java_matrix_wrapper.call("toLocalMatrix")
	def toIndexedRowMatrix(self):
		java_indexed_row_matrix = self._java_matrix_wrapper.call("toIndexedRowMatrix")
		return IndexedRowMatrix(java_indexed_row_matrix)
	def toCoordinateMatrix(self):
		java_coordinate_matrix = self._java_matrix_wrapper.call("toCoordinateMatrix")
		return CoordinateMatrix(java_coordinate_matrix)
def _test():
	globs = pyspark.mllib.linalg.distributed.__dict__.copy()
	globs['sc'] = SparkContext('local[2]', 'PythonTest', batchSize=2)
	globs['sqlContext'] = SQLContext(globs['sc'])
	globs['Matrices'] = Matrices
	(failure_count, test_count) = doctest.testmod(globs=globs, optionflags=doctest.ELLIPSIS)
	globs['sc'].stop()
	if failure_count:
		exit(-1)
if __name__ == "__main__":
	_test()