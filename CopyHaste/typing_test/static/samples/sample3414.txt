if sys.version >= '3':
	long = int
	unicode = str
_old_smart_decode = py4j.protocol.smart_decode
_float_str_mapping = {
	'nan': 'NaN',
	'inf': 'Infinity',
	'-inf': '-Infinity',
}
def _new_smart_decode(obj):
	if isinstance(obj, float):
		s = str(obj)
		return _float_str_mapping.get(s, s)
	return _old_smart_decode(obj)
py4j.protocol.smart_decode = _new_smart_decode
_picklable_classes = [
	'LinkedList',
	'SparseVector',
	'DenseVector',
	'DenseMatrix',
	'Rating',
	'LabeledPoint',
]
def _to_java_object_rdd(rdd):
	rdd = rdd._reserialize(AutoBatchedSerializer(PickleSerializer()))
	return rdd.ctx._jvm.SerDe.pythonToJava(rdd._jrdd, True)
def _py2java(sc, obj):
	if isinstance(obj, RDD):
		obj = _to_java_object_rdd(obj)
	elif isinstance(obj, DataFrame):
		obj = obj._jdf
	elif isinstance(obj, SparkContext):
		obj = obj._jsc
	elif isinstance(obj, list):
		obj = ListConverter().convert([_py2java(sc, x) for x in obj], sc._gateway._gateway_client)
	elif isinstance(obj, JavaObject):
		pass
	elif isinstance(obj, (int, long, float, bool, bytes, unicode)):
		pass
	else:
		data = bytearray(PickleSerializer().dumps(obj))
		obj = sc._jvm.SerDe.loads(data)
	return obj
def _java2py(sc, r, encoding="bytes"):
	if isinstance(r, JavaObject):
		clsName = r.getClass().getSimpleName()
		if clsName != 'JavaRDD' and clsName.endswith("RDD"):
			r = r.toJavaRDD()
			clsName = 'JavaRDD'
		if clsName == 'JavaRDD':
			jrdd = sc._jvm.SerDe.javaToPython(r)
			return RDD(jrdd, sc)
		if clsName == 'DataFrame':
			return DataFrame(r, SQLContext(sc))
		if clsName in _picklable_classes:
			r = sc._jvm.SerDe.dumps(r)
		elif isinstance(r, (JavaArray, JavaList)):
			try:
				r = sc._jvm.SerDe.dumps(r)
			except Py4JJavaError:
				pass
	if isinstance(r, (bytearray, bytes)):
		r = PickleSerializer().loads(bytes(r), encoding=encoding)
	return r
def callJavaFunc(sc, func, *args):
	args = [_py2java(sc, a) for a in args]
	return _java2py(sc, func(*args))
def callMLlibFunc(name, *args):
	sc = SparkContext._active_spark_context
	api = getattr(sc._jvm.PythonMLLibAPI(), name)
	return callJavaFunc(sc, api, *args)
class JavaModelWrapper(object):
	def __init__(self, java_model):
		self._sc = SparkContext._active_spark_context
		self._java_model = java_model
	def __del__(self):
		self._sc._gateway.detach(self._java_model)
	def call(self, name, *a):
		return callJavaFunc(self._sc, getattr(self._java_model, name), *a)
def inherit_doc(cls):
	for name, func in vars(cls).items():
		if name.startswith("_"):
			continue
		if not func.__doc__:
			for parent in cls.__bases__:
				parent_func = getattr(parent, name, None)
				if parent_func and getattr(parent_func, "__doc__", None):
					func.__doc__ = parent_func.__doc__
					break
	return cls