
def vMaxPoints(xPoints):
  rPoints = [util.points_to_radius(xPoints[i-1:i+2]) for i in range(1,len(xPoints)-1)]
  sPoints = [0 for i in range(0,len(xPoints))]
  for i in range(0, len(xPoints)-1):
	sPoints[i+1] = sPoints[i] + np.linalg.norm(xPoints[i+1] - xPoints[i])
  maxPoints = [0] + [min(np.sqrt(r*config.lateralAccelTol), config.maxSpeed) for r in rPoints] + [0]
  return [sPoints, maxPoints]
def sort_vMaxindices(vMaxPoints):
  vMaxindices = range(len(vMaxPoints))
  sortedIndices = sorted(vMaxindices, key = lambda i: vMaxPoints[i],)
  return sortedIndices
def get_relevant_indices(vMaxPoints, sPoints):
  lowest = sort_vMaxindices(vMaxPoints)	
  relevantIndices = [0, len(vMaxPoints)- 1]
  print 
  def newLocationisBad(i):
	if i < len(lowes