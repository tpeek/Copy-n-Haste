def add_indra_lib_path():
	root = os.path.realpath(__file__)
	dir = os.path.dirname(root)
	if dir not in sys.path:
		sys.path.insert(0, dir)
	while root != os.path.sep:
		root = os.path.dirname(root)
		dir = os.path.join(root, 'indra', 'lib', 'python')
		if os.path.isdir(dir):
			if dir not in sys.path:
				sys.path.insert(0, dir)
			return root
	else:
		print >>sys.stderr, "This script is not inside a valid installation."
		sys.exit(1)
base_dir = add_indra_lib_path()
defaultUserAgent = 'Lynx/2.8.6rel.5 libwww-FM/2.14'
try:
except ImportError:
class InstallFile(object):
	"This is just a handy way to throw around details on a file in memory."
	def __init__(self, pkgname, url, md5sum, cache_dir, platform_path):
		self.pkgname = pkgname
		self.url = url
		self.md5sum = md5sum
		filename = urlparse.urlparse(url)[2].split('/')[-1]
		self.filename = os.path.join(cache_dir, filename)
		self.platform_path = platform_path
	def __str__(self):
		return "ifile{%s:%s}" % (self.pkgname, self.url)
	def _is_md5sum_match(self):
		hasher = md5(file(self.filename, 'rb').read())
		md5_sum = hasher.hexdigest()
		if md5_sum == self.md5sum:
			return  True
		print "Got:", md5_sum, " Expected ", self.md5sum
		return False
	def is_match(self, platform):
		if self.platform_path[0] == 'common':
			return True
		req_platform_path = platform.split('/')
		match_count = min(len(req_platform_path), len(self.platform_path))
		for ii in range(0, match_count):
			if req_platform_path[ii] != self.platform_path[ii]:
				return False
		return True
	def fetch_local(self):
		cache_path, cache_file = os.path.split(self.filename)
		cache_path, cache_folder = os.path.split(os.path.normpath(cache_path))
		cache_file = os.path.join(cache_path, cache_folder.rsplit('.',1)[0] + ".<user>", cache_file)
		if not os.path.exists(self.filename):
			pass
		elif self.md5sum and not self._is_md5sum_match():
			print "md5 mismatch:", cache_file
			os.remove(self.filename)
		else:
			print "Found matching package:", cache_file
			return
		print "Downloading",self.url,"to local file",cache_file
		request = urllib2.Request(self.url)
		if re.match("/^http:\/\/github.com/", self.url):
			request.add_header('User-agent', defaultUserAgent)
		file(self.filename, 'wb').write(urllib2.urlopen(request).read())
		if self.md5sum and not self._is_md5sum_match():
			raise RuntimeError("Error matching md5 for %s" % self.url)
class LicenseDefinition(object):
	def __init__(self, definition):
		self._definition = definition
class InstallableDefinition(object):
	def __init__(self, definition):
		self._definition = definition
	def _ifiles_
		return self._ifiles_
	def _ifiles_
		ifiles = []
		if 'url' in tree:
			ifiles.append(InstallFile(
				pkgname,
				tree['url'],
				tree.get('md5sum', None),
				cache_dir,
				path))
		else:
			for key in tree:
				platform_path = copy.copy(path)
				platform_path.append(key)
				ifiles.extend(
					self._ifiles_
						tree[key],
						pkgname,
						cache_dir,
						platform_path))
		return ifiles
	def ifiles(self, pkgname, platform, cache_dir):
		if 'packages' not in self._definition:
			return []
		all_ifiles = self._ifiles_
			self._definition['packages'],
			pkgname,
			cache_dir)
		if platform == 'all':
			return all_ifiles
		files = [ifile for ifile in all_ifiles if ifile.is_match(platform)]
		return files
class InstalledPackage(object):
	def __init__(self, definition):
		self._installed = {}
		for url in definition:
			self._installed[url] = definition[url]
	def urls(self):
		return self._installed.keys()
	def files_in(self, url):
		return self._installed[url].get('files', [])
	def get_md5sum(self, url):
		return self._installed[url].get('md5sum', None)
	def remove(self, url):
		self._installed.pop(url)
	def add_files(self, url, files):
		if url not in self._installed:
			self._installed[url] = {}
		self._installed[url]['files'] = files
	def set_md5sum(self, url, md5sum):
		if url not in self._installed:
			self._installed[url] = {}
		self._installed[url]['md5sum'] = md5sum
class Installer(object):
	def __init__(self, install_filename, installed_filename, dryrun):
		self._install_filename = install_filename
		self._install_changed = False
		self._installed_filename = installed_filename
		self._installed_changed = False
		self._dryrun = dryrun
		self._installables = {}
		self._licenses = {}
		self._installed = {}
		self.load()
	def load(self):
		if os.path.exists(self._install_filename):
			install = llsd.parse(file(self._install_filename, 'rb').read())
			try:
				for name in install['installables']:
					self._installables[name] = InstallableDefinition(
						install['installables'][name])
			except KeyError:
				pass
			try:
				for name in install['licenses']:
					self._licenses[name] = LicenseDefinition(install['licenses'][name])
			except KeyError:
				pass
		if os.path.exists(self._installed_filename):
			installed = llsd.parse(file(self._installed_filename, 'rb').read())
			try:
				bins = installed['installables']
				for name in bins:
					self._installed[name] = InstalledPackage(bins[name])
			except KeyError:
				pass
	def _write(self, filename, state):
		print "Writing state to",filename
		if not self._dryrun:
			file(filename, 'wb').write(llsd.format_pretty_xml(state))
	def save(self):
		if self._install_changed:
			state = {}
			state['licenses'] = {}
			for name in self._licenses:
				state['licenses'][name] = self._licenses[name]._definition
			state['installables'] = {}
			for name in self._installables:
				state['installables'][name] = \
										self._installables[name]._definition
			self._write(self._install_filename, state)
		if self._installed_changed:
			state = {}
			state['installables'] = {}
			bin = state['installables']
			for name in self._installed:
				bin[name] = self._installed[name]._installed
			self._write(self._installed_filename, state)
	def is_valid_license(self, bin):
		"@brief retrun true if we have valid license info for installable."
		installable = self._installables[bin]._definition
		if 'license' not in installable:
			print >>sys.stderr, "No license info found for", bin
			print >>sys.stderr, 'Please add the license with the',
			print >>sys.stderr, '--add-installable option. See', \
								 sys.argv[0], '--help'
			return False
		if installable['license'] not in self._licenses:
			lic = installable['license']
			print >>sys.stderr, "Missing license info for '" + lic + "'.",
			print >>sys.stderr, 'Please add the license with the',
			print >>sys.stderr, '--add-license option. See', sys.argv[0],
			print >>sys.stderr, '--help'
			return False
		return True
	def list_installables(self):
		"Return a list of all known installables."
		return sorted(self._installables.keys())
	def detail_installable(self, name):
		"Return a installable definition detail"
		return self._installables[name]._definition
	def list_licenses(self):
		"Return a list of all known licenses."
		return sorted(self._licenses.keys())
	def detail_license(self, name):
		"Return a license definition detail"
		return self._licenses[name]._definition
	def list_installed(self):
		"Return a list of installed packages."
		return sorted(self._installed.keys())
	def detail_installed(self, name):
		"Return file list for specific installed package."
		filelist = []
		for url in self._installed[name]._installed.keys():
			filelist.extend(self._installed[name].files_in(url))
		return filelist
	def _update_field(self, description, field, value, multiline=False):
		if value:
			description[field] = value
		else:
			if field in description:
				print "Update value for '" + field + "'"
				print "(Leave blank to keep current value)"
				print "Current Value:  '" + description[field] + "'"
			else:
				print "Specify value for '" + field + "'"
			if not multiline:
				new_value = raw_input("Enter New Value: ")
			else:
				print "Please enter " + field + ". End input with EOF (^D)."
				new_value = sys.stdin.read()
			if field in description and not new_value:
				pass
			elif new_value:
				description[field] = new_value
		self._install_changed = True
		return True
	def _update_installable(self, name, platform, url, md5sum):
		installable  = self._installables[name]._definition
		path = platform.split('/')
		if 'packages' not in  installable:
			installable['packages'] = {}
		update = installable['packages']
		for child in path:
			if child not in update:
				update[child] = {}
			parent = update
			update = update[child]
		parent[child]['url'] = llsd.uri(url)
		parent[child]['md5sum'] = md5sum
		self._install_changed = True
		return True
	def add_installable_package(self, name, **kwargs):
		platform_help_str =
		if name not in self._installables:
			print "Error: must add library with --add-installable or " \
				  +"--add-installable-metadata before using " \
				  +"--add-installable-package option"
			return False
		else:
			print "Updating installable '" + name + "'."
		for arg in ('platform', 'url', 'md5sum'):
			if not kwargs[arg]:
				if arg == 'platform':
					print platform_help_str
				kwargs[arg] = raw_input("Package "+arg+":")
		return self._update_installable(name, kwargs['platform'],
						kwargs['url'], kwargs['md5sum'])
	def add_installable_metadata(self, name, **kwargs):
		if name not in self._installables:
			print "Adding installable '" + name + "'."
			self._installables[name] = InstallableDefinition({})
		else:
			print "Updating installable '" + name + "'."
		installable  = self._installables[name]._definition
		for field in ('copyright', 'license', 'description'):
			self._update_field(installable, field, kwargs[field])
		print "Added installable '" + name + "':"
		pprint.pprint(self._installables[name])
		return True
	def add_installable(self, name, **kwargs):
		"Interactively pull a new installable into the install"
		ret_a = self.add_installable_metadata(name, **kwargs)
		ret_b = self.add_installable_package(name, **kwargs)
		return (ret_a and ret_b)
	def remove_installable(self, name):
		self._installables.pop(name)
		self._install_changed = True
	def add_license(self, name, **kwargs):
		if name not in self._licenses:
			print "Adding license '" + name + "'."
			self._licenses[name] = LicenseDefinition({})
		else:
			print "Updating license '" + name + "'."
		the_license  = self._licenses[name]._definition
		for field in ('url', 'text'):
			multiline = False
			if field == 'text':
				multiline = True
			self._update_field(the_license, field, kwargs[field], multiline)
		self._install_changed = True
		return True
	def remove_license(self, name):
		self._licenses.pop(name)
		self._install_changed = True
	def _uninstall(self, installables):
		remove_file_list = []
		for pkgname in installables:
			for url in self._installed[pkgname].urls():
				remove_file_list.extend(
					self._installed[pkgname].files_in(url))
				self._installed[pkgname].remove(url)
				if not self._dryrun:
					self._installed_changed = True
			if not self._dryrun:
				self._installed.pop(pkgname)
		remove_dir_set = set()
		for filename in remove_file_list:
			print "rm",filename
			if not self._dryrun:
				if os.path.lexists(filename):
					remove_dir_set.add(os.path.dirname(filename))
					try:
						os.remove(filename)
					except OSError:
						pass
		for dirname in remove_dir_set:
			try:
				os.removedirs(dirname)
			except OSError:
				pass
	def uninstall(self, installables, install_dir):
		print "uninstall",installables,"
		cwd = os.getcwdu()
		os.chdir(install_dir)
		try:
			self._uninstall(installables)
		finally:
			os.chdir(cwd)
	def _build_ifiles(self, platform, cache_dir):
		ifiles = []
		for bin in self._installables:
			ifiles.extend(self._installables[bin].ifiles(bin,
														 platform,
														 cache_dir))
		to_install = []
		to_uninstall = []
		for ifile in ifiles:
			if ifile.pkgname not in self._installed:
				to_install.append(ifile)
			elif ifile.url not in self._installed[ifile.pkgname].urls():
				to_uninstall.append(ifile.pkgname)
				to_install.append(ifile)
			elif ifile.md5sum != \
				 self._installed[ifile.pkgname].get_md5sum(ifile.url):
				to_uninstall.append(ifile.pkgname)
				to_install.append(ifile)
			else:
				pass
		return [to_install, to_uninstall]
	def _install(self, to_install, install_dir):
		for ifile in to_install:
			tar = tarfile.open(ifile.filename, 'r')
			print "Extracting",ifile.filename,"to",install_dir
			if not self._dryrun:
				try:
					tar.extractall(path=install_dir)
				except AttributeError:
					_extractall(tar, path=install_dir)
			symlinks = []
			filenames = tar.getnames()
			if('autobuild-package.xml' in filenames):
				filenames.remove("autobuild-package.xml")
				rem_file = os.path.join(install_dir, "autobuild-package.xml")
				if os.path.exists(rem_file):
					os.remove(rem_file)
			if _get_platform() == 'linux' or _get_platform() == 'linux64':
				first = 1
				for tfile in filenames:
					if tfile.find('.so.') > 0:
						LINK = re.sub(r'\.so\.[0-9.]*$', '.so', tfile)
						link_name = install_dir + "/" + LINK
						if not os.path.exists(link_name):
							if first == 1:
								first = 0
								print "Adding missing symlink(s) for package %s:" % ifile.filename
							target = os.path.basename(tfile)
							soname = os.popen("readelf -d \"%(install_dir)s/%(tfile)s\" %(stderr_redirect)s"
								" | grep SONAME | sed -e 's/.*\[//;s/\].*//'" %
																{"install_dir": install_dir, "tfile": tfile, "stderr_redirect": ("2>/dev/null" if self._dryrun else "")}).read()
							soname = soname.strip()
							if soname:
								tmpfname = os.path.dirname(LINK) + "/" + soname
								if os.path.exists(install_dir + "/" + tmpfname):
									target = soname
								else:
									print "WARNING: SONAME %s doesn't exist!" % tmpfname
							if not self._dryrun:
								os.symlink(target, link_name)
							symlinks += [LINK]
							print "	%s --> %s" % (LINK, target)
			if ifile.pkgname in self._installed:
				self._installed[ifile.pkgname].add_files(
					ifile.url,
					filenames + symlinks)
				self._installed[ifile.pkgname].set_md5sum(
					ifile.url,
					ifile.md5sum)
			else:
				definition = { ifile.url :
							   {'files': filenames + symlinks,
								'md5sum' : ifile.md5sum } }
				self._installed[ifile.pkgname] = InstalledPackage(definition)
			self._installed_changed = True
	def install(self, installables, platform, install_dir, cache_dir):
		install_dir = os.path.realpath(install_dir)
		cache_dir = os.path.realpath(cache_dir)
		_mkdir(install_dir)
		_mkdir(cache_dir)
		to_install_uninstall = self._build_ifiles(platform, cache_dir)
		to_install = to_install_uninstall[0]
		to_uninstall = to_install_uninstall[1]
		to_install = [ifl for ifl in to_install if ifl.pkgname in installables]
		to_uninstall = [ifl for ifl in to_uninstall if ifl in installables]
		for ifile in to_install:
			ifile.fetch_local()
		if to_uninstall:
			self.uninstall(to_uninstall, install_dir)
		self._install(to_install, install_dir)
	def do_install(self, installables, platform, install_dir, cache_dir=None,
				   check_license=True, scp=None):
		if not cache_dir:
			cache_dir = _default_installable_cache()
		all_installables = self.list_installables()
		if not len(installables):
			install_installables = all_installables
		else:
			install_installables = installables
			for installable in install_installables:
				if installable not in all_installables:
					raise RuntimeError('Unknown installable: %s' %
									   (installable,))
		if check_license:
			for installable in install_installables:
				if not self.is_valid_license(installable):
					return 1
		opener = urllib2.build_opener()
		scp_or_http = SCPOrHTTPHandler(scp)
		opener.add_handler(scp_or_http)
		urllib2.install_opener(opener)
		self.install(
			install_installables,
			platform,
			install_dir,
			cache_dir)
		scp_or_http.cleanup()
		for pkg in installables:
			if pkg not in self._installed:
				raise RuntimeError("No '%s' available for '%s'." %
								   (pkg, platform))
	def do_uninstall(self, installables, install_dir):
		all_installed = self.list_installed()
		if not len(installables):
			uninstall_installables = all_installed
		else:
			uninstall_installables = installables
			for installable in uninstall_installables:
				if installable not in all_installed:
					raise RuntimeError('Installable not installed: %s' %
									   (installable,))
		self.uninstall(uninstall_installables, install_dir)
class SCPOrHTTPHandler(urllib2.BaseHandler):
	def __init__(self, scp_binary):
		self._scp = scp_binary
		self._dir = None
	def scp_open(self, request):
		remote = request.get_full_url()[4:]
		if os.getenv('INSTALL_USE_HTTP_FOR_SCP', None) == 'true':
			return self.do_http(remote)
		try:
			return self.do_scp(remote)
		except:
			self.cleanup()
			raise
	def do_http(self, remote):
		url = remote.split(':',1)
		if not url[1].startswith('/'):
			url.insert(1, '/')
		url.insert(0, "http://")
		url = ''.join(url)
		print "Using HTTP:",url
		request = urllib2.Request(url)
		request.add_header('User-agent', defaultUserAgent)
		return urllib2.urlopen(request)
	def do_scp(self, remote):
		if not self._dir:
			self._dir = tempfile.mkdtemp()
		local = os.path.join(self._dir, remote.split('/')[-1:][0])
		command = []
		for part in (self._scp, remote, local):
			if ' ' in part:
				part.replace('\\', '\\\\')
				part.replace('"', '\\"')
				command.append('"%s"' % part)
			else:
				command.append(part)
		rv = os.system(' '.join(command))
		if rv != 0:
			raise RuntimeError("Cannot fetch: %s" % remote)
		return file(local, 'rb')
	def cleanup(self):
		if self._dir:
			shutil.rmtree(self._dir)
	directories = []
	if members is None:
		members = tar
	for tarinfo in members:
		if tarinfo.isdir():
			try:
				os.makedirs(os.path.join(path, tarinfo.name), 0777)
			except EnvironmentError:
				pass
			directories.append(tarinfo)
		else:
			tar.extract(tarinfo, path)
	directories.sort(lambda a, b: cmp(a.name, b.name))
	directories.reverse()
	for tarinfo in directories:
		path = os.path.join(path, tarinfo.name)
		try:
			tar.chown(tarinfo, path)
			tar.utime(tarinfo, path)
			tar.chmod(tarinfo, path)
		except tarfile.ExtractError, e:
			if tar.errorlevel > 1:
				raise
			else:
				tar._dbg(1, "tarfile: %s" % e)
def _mkdir(directory):
	"Safe, repeatable way to make a directory."
	if not os.path.exists(directory):
		os.makedirs(directory)
def _get_platform():
	"Return appropriate platform packages for the environment."
	platform_map = {
		'darwin': 'darwin',
		'linux2': 'linux',
		'win32' : 'windows',
		'cygwin' : 'windows',
		'solaris' : 'solaris'
		}
	this_platform = platform_map[sys.platform]
	if this_platform == 'linux':
		if platform.architecture()[0] == '64bit':
			this_platform = 'linux64'
	return this_platform
def _getuser():
	"Get the user"
	try:
		return getpass.getuser()
	except ImportError:
		return win32api.GetUserName()
def _default_installable_cache():
	user = _getuser()
	cache_dir = "/var/tmp/%s/sg.install.cache" % user
	if _get_platform() == 'windows':
		cache_dir = os.path.join(tempfile.gettempdir(), \
								 'sg.install.cache.%s' % user)
	return cache_dir
def parse_args():
	parser = optparse.OptionParser(
		usage="usage: %prog [options] [installable1 [installable2...]]",
		formatter = helpformatter.Formatter(),
		description=)
	parser.add_option(
		'--dry-run',
		action='store_true',
		default=False,
		dest='dryrun',
		help='Do not actually install files. Downloads will still happen.')
	parser.add_option(
		'--install-manifest',
		type='string',
		default=os.path.join(base_dir, 'install.xml'),
		dest='install_filename',
		help='The file used to describe what should be installed.')
	parser.add_option(
		'--installed-manifest',
		type='string',
		default=os.path.join(base_dir, 'installed.xml'),
		dest='installed_filename',
		help='The file used to record what is installed.')
	parser.add_option(
		'--export-manifest',
		action='store_true',
		default=False,
		dest='export_manifest',
		help="Print the install manifest to stdout and exit.")
	parser.add_option(
		'-p', '--platform',
		type='string',
		default=_get_platform(),
		dest='platform',
		help=)
	parser.add_option(
		'--cache-dir',
		type='string',
		default=_default_installable_cache(),
		dest='cache_dir',
		help='Where to download files. Default: %s'% \
			 (_default_installable_cache()))
	parser.add_option(
		'--install-dir',
		type='string',
		default=base_dir,
		dest='install_dir',
		help='Where to unpack the installed files.')
	parser.add_option(
		'--list-installed',
		action='store_true',
		default=False,
		dest='list_installed',
		help="List the installed package names and exit.")
	parser.add_option(
		'--skip-license-check',
		action='store_false',
		default=True,
		dest='check_license',
		help="Do not perform the license check.")
	parser.add_option(
		'--list-licenses',
		action='store_true',
		default=False,
		dest='list_licenses',
		help="List known licenses and exit.")
	parser.add_option(
		'--detail-license',
		type='string',
		default=None,
		dest='detail_license',
		help="Get detailed information on specified license and exit.")
	parser.add_option(
		'--add-license',
		type='string',
		default=None,
		dest='new_license',
		help=)
	parser.add_option(
		'--license-url',
		type='string',
		default=None,
		dest='license_url',
		help=)
	parser.add_option(
		'--license-text',
		type='string',
		default=None,
		dest='license_text',
		help=)
	parser.add_option(
		'--remove-license',
		type='string',
		default=None,
		dest='remove_license',
		help="Remove a named license.")
	parser.add_option(
		'--remove-installable',
		type='string',
		default=None,
		dest='remove_installable',
		help="Remove a installable
	parser.add_option(
		'--add-installable',
		type='string',
		default=None,
		dest='add_installable',
		help=)
	parser.add_option(
		'--add-installable-metadata',
		type='string',
		default=None,
		dest='add_installable_metadata',
		help=)
	parser.add_option(
		'--installable-copyright',
		type='string',
		default=None,
		dest='installable_copyright',
		help=)
	parser.add_option(
		'--installable-license',
		type='string',
		default=None,
		dest='installable_license',
		help=)
	parser.add_option(
		'--installable-description',
		type='string',
		default=None,
		dest='installable_description',
		help=)
	parser.add_option(
		'--add-installable-package',
		type='string',
		default=None,
		dest='add_installable_package',
		help=)
	parser.add_option(
		'--package-platform',
		type='string',
		default=None,
		dest='package_platform',
		help=)
	parser.add_option(
		'--package-url',
		type='string',
		default=None,
		dest='package_url',
		help=)
	parser.add_option(
		'--package-md5',
		type='string',
		default=None,
		dest='package_md5',
		help=)
	parser.add_option(
		'--list',
		action='store_true',
		default=False,
		dest='list_installables',
		help="List the installables in the install manifest and exit.")
	parser.add_option(
		'--detail',
		type='string',
		default=None,
		dest='detail_installable',
		help="Get detailed information on specified installable and exit.")
	parser.add_option(
		'--detail-installed',
		type='string',
		default=None,
		dest='detail_installed',
		help="Get list of files for specified installed installable and exit.")
	parser.add_option(
		'--uninstall',
		action='store_true',
		default=False,
		dest='uninstall',
		help=)
	parser.add_option(
		'--scp',
		type='string',
		default='scp',
		dest='scp',
		help="Specify the path to your scp program.")
	return parser.parse_args()
def main():
	options, args = parse_args()
	installer = Installer(
		options.install_filename,
		options.installed_filename,
		options.dryrun)
		print "installed list:", installer.list_installed()
		return 0
	if options.list_installables:
		print "installable list:", installer.list_installables()
		return 0
	if options.detail_installable:
		try:
			detail = installer.detail_installable(options.detail_installable)
			print "Detail on installable",options.detail_installable+":"
			pprint.pprint(detail)
		except KeyError:
			print "Installable '"+options.detail_installable+"' not found in",
			print "install file."
		return 0
	if options.detail_installed:
		try:
			detail = installer.detail_installed(options.detail_installed)
			for line in detail:
				print line
		except:
			raise
			print "Installable '"+options.detail_installed+"' not found in ",
			print "install file."
		return 0
	if options.list_licenses:
		print "license list:", installer.list_licenses()
		return 0
	if options.detail_license:
		try:
			detail = installer.detail_license(options.detail_license)
			print "Detail on license",options.detail_license+":"
			pprint.pprint(detail)
		except KeyError:
			print "License '"+options.detail_license+"' not defined in",
			print "install file."
		return 0
	if options.export_manifest:
		install = llsd.parse(file(options.install_filename, 'rb').read())
		pprint.pprint(install)
		return 0
		if not installer.add_license(
			options.new_license,
			text=options.license_text,
			url=options.license_url):
			return 1
	elif options.remove_license:
		installer.remove_license(options.remove_license)
	elif options.remove_installable:
		installer.remove_installable(options.remove_installable)
	elif options.add_installable:
		if not installer.add_installable(
			options.add_installable,
			copyright=options.installable_copyright,
			license=options.installable_license,
			description=options.installable_description,
			platform=options.package_platform,
			url=options.package_url,
			md5sum=options.package_md5):
			return 1
	elif options.add_installable_metadata:
		if not installer.add_installable_metadata(
			options.add_installable_metadata,
			copyright=options.installable_copyright,
			license=options.installable_license,
			description=options.installable_description):
			return 1
	elif options.add_installable_package:
		if not installer.add_installable_package(
			options.add_installable_package,
			platform=options.package_platform,
			url=options.package_url,
			md5sum=options.package_md5):
			return 1
	elif options.uninstall:
		installer.do_uninstall(args, options.install_dir)
	else:
		installer.do_install(args, options.platform, options.install_dir,
							 options.cache_dir, options.check_license,
							 options.scp)
	installer.save()
	return 0
if __name__ == '__main__':
	sys.exit(main())