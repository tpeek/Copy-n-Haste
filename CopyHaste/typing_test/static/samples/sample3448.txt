class UnbalancedBraces(Exception):
	pass
class UnknownDirective(Exception):
	pass
class BadDirective(Exception):
	pass
def format_value_for_path(value):
	if type(value) in [list, tuple]:
		return '/'.join([urllib.quote(str(item)) for item in value])
	else:
		return urllib.quote(str(value))
def format(format_str, context):
	while True:
		all_matches = _find_sub_matches(format_str)
		if not all_matches:
			break
		substitutions = 0
		while True:
			matches = all_matches.pop()
			matches.reverse()
			for pos in matches:
				end = format_str.index('}', pos)
				if format_str[pos + 1] == '$':
					value = context[format_str[pos + 2:end]]
					if value is not None:
						value = format_value_for_path(value)
				elif format_str[pos + 1] == '%':
					value = _build_query_string(
						context.get(format_str[pos + 2:end]))
				elif format_str[pos+1:pos+5] == 'http' or format_str[pos+1:pos+5] == 'file':
					value = _fetch_url_directive(format_str[pos + 1:end])
				else:
					raise UnknownDirective, format_str[pos:end + 1]
				if value is not None:
					format_str = format_str[:pos]+str(value)+format_str[end+1:]
					substitutions += 1
			if substitutions:
				break
			if not all_matches:
				break
		if not substitutions:
			break
	return format_str
def _find_sub_matches(format_str):
	depth = 0
	matches = []
	for pos in range(len(format_str)):
		if format_str[pos] == '{':
			depth += 1
			if not len(matches) == depth:
				matches.append([])
			matches[depth - 1].append(pos)
			continue
		if format_str[pos] == '}':
			depth -= 1
			continue
	if not depth == 0:
		raise UnbalancedBraces, format_str
	return matches
def _build_query_string(query_dict):
	if query_dict:
		keys = query_dict.keys()
		keys.sort()
		def stringize(value):
			if type(value) in (str,unicode):
				return value
			else:
				return str(value)
		query_list = [urllib.quote(str(key)) + '=' + urllib.quote(stringize(query_dict[key])) for key in keys]
		return '?' + '&'.join(query_list)
	else:
		return ''
def _fetch_url_directive(directive):
	"*FIX: This only supports GET"
	commands = directive.split('|')
	resource = llsdhttp.get(commands[0])
	if len(commands) == 3:
		resource = _walk_resource(resource, commands[2])
	return resource
def _walk_resource(resource, path):
	path = path.split('/')
	for child in path:
		if not child:
			continue
		resource = resource[child]
	return resource