class SqliteDB(object):
	def __init__(self, fileName=":memory:"):
		self._registeredDatabase = None
		self._dbCon = None
		self.registerDatabase(fileName)
	def getRegisteredDatabase(self):
		return self._registeredDatabase
	def registerDatabase(self, fileName):
		self.closeConnection()
		self._registeredDatabase = fileName
		self._openConnection()
	def _openConnection(self):
		if not self._registeredDatabase:
			raise self.SqliteDBError("database not registerd")
		if not self._dbCon:
			self._dbCon = sqlite3.connect(self._registeredDatabase)
	def closeConnection(self, discardChanges=False):
		if self._dbCon:
			if not discardChanges:
				self._dbCon.commit()
			self._dbCon.close()
			self._dbCon = None
	def _executeSQL(self, cmdString, parameterTuple=(), many=False):
		if not self._dbCon:
			self._openConnection()
		try:
			if not many:
				return self._dbCon.execute(cmdString, parameterTuple)
			else:
				return self._dbCon.executemany(cmdString, parameterTuple)
		except sqlite3.OperationalError:
			print("Error executing: %s" % cmdString)
			print("With parameters:")
			print(parameterTuple)
			raise
	def getAllTableNames(self):
		return [item[1] for item in self._executeSQL("select *
	def getTableInfo(self, tableName):
		return [ (item[1],item[2]) for item in self._executeSQL("pragma table_info(%s)" % tableName) ]
	def doesTableExist(self, tableName):
		return tableName in self.getAllTableNames()
	def createTableIfNotExists(self, tableName, nameAndTypeList):
		tableName = tableName.strip()
		if " " in tableName:
			raise sqlite3.OperationalError("SQL table name cannot contain blanks")
		if not ListRNew.isIterable(nameAndTypeList[0]):
			nameAndTypeList = [nameAndTypeList]
		if not self.doesTableExist(tableName):
			return self._executeSQL( "create table %s (%s)" % (tableName, ",".join(map(" ".join, nameAndTypeList))) )
		else:
			return False
	def insertIntoTable(self, tableName, valueList):
		if not ListRNew.isIterable(valueList):
			valueList = [valueList]
		if not ListRNew.isIterable(valueList[0]):
			valueList = [valueList]
		dataLength = len(valueList[0])
		returnValue = self._executeSQL("insert into %s values (%s)" % (tableName, ",".join("?"*dataLength)), valueList, many=True)
		return returnValue
	def selectFromTable(self, tableName, columnNameList="*", whereClause="", groupByClause="", orderByClause=""):
		if not ListRNew.isIterable(columnNameList):
			columnNameList = [columnNameList]
		columnNameListSQLString = ",".join(columnNameList)
		sqlCommand = "select %s
		if whereClause:
			sqlCommand += " where " + whereClause
		if groupByClause:
			sqlCommand += " group by " + groupByClause
		if orderByClause:
			sqlCommand += " order by " + orderByClause
		returnValue = self._executeSQL(sqlCommand).fetchall()
		return returnValue
	def dropTable(self, tableName):
		if tableName not in self.getAllTableNames():
			return False
		self._executeSQL("drop table %s" % tableName)
		return True
	def deleteDatabase(self, confirmation=False):
		if not confirmation:
			raise self.SqliteDBError("deletion not confirmed")
		db = self.getRegisteredDatabase()
		if not db: return False
		if not path.exists(db): return False
		unlink(db)
		return True
	def unpackDatabase(self, sep="\t", writeToFolder=".", ext=".dat", writeHeader=(True, "
		tableNames = self.getAllTableNames()
		for aTable in tableNames:
			with open(path.join(writeToFolder, aTable+ext), "w") as tableFile:
				if writeHeader[0]:
					fieldNames = [ item[0] for item in self.getTableInfo(aTable) ]
					tableFile.write(writeHeader[1] + sep.join(fieldNames) + "\n")
				for aRecond in self.selectFromTable(aTable):
					tableFile.write(sep.join( map(str, aRecond) ) + "\n")
	class SqliteDBError(sqlite3.OperationalError):
		pass
if __name__ == '__main__':
	doctest.testfile("DBR_readme.txt")