class StringSubstitution(object):
	
	@staticmethod
	def applySingleRule(rule, expression, restrictNumberOfRecursionsTo=None):
		key, value = rule
		if isinstance(value, str):
			formulate = lambda matchedResult: value.format(matchedResult.groups())
		elif hasattr(value, '__call__'):
			formulate = value
		else:
			formulate = lambda matchedResult: str(value)
		substitutedString = expression
		numberOfRecursions = 0
		matched = re.search(key, substitutedString)
		while matched:
			toBeSubstituted = formulate(matched)
			substitutedString = substitutedString.replace(matched.group(), toBeSubstituted)
			numberOfRecursions += 1
			if restrictNumberOfRecursionsTo and numberOfRecursions>=restrictNumberOfRecursionsTo: break
			matched = re.search(key, substitutedString)
		return (substitutedString, numberOfRecursions)
	def __init__(self, rules=[]):
		self.setRules(rules)
	def setRules(self, rules):
		self.rules = []
		for key, value in rules:
			self.rules.append((re.compile(key), value))
	def applyAllRules(self, expression, restrictNumberOfRecursionsPerScan=None, restrictNumberOfScans=None):
		numberOfScans = 0
		newExpression = expression
		changeFlag = True
		while changeFlag:
			changeFlag = False
			for rule in self.rules:
				newExpression, recursionNumber = self.applySingleRule(rule, newExpression, restrictNumberOfRecursionsTo=restrictNumberOfRecursionsPerScan)
				if recursionNumber>0: changeFlag = True
			if changeFlag: numberOfScans += 1
			if restrictNumberOfScans and numberOfScans>=restrictNumberOfScans: break
		return (newExpression, numberOfScans)
if __name__ == '__main__':
	doctest.testfile("StringSubstitution_readme.txt")