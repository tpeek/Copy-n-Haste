def toList(qvar):
	if type(qvar) != type([]): qvar = [qvar]
	return qvar
def flatten(nested):
	try:
		for sublist in nested:
		  if type(sublist)==type(""):
			yield sublist
		  else:
			for element in flatten(sublist):
				yield element
	except TypeError:
		yield nested
def FL(nested):
	for sublist in nested:
		if type(sublist) == type([]):
			for element in FL(sublist): yield element
		else:
			yield sublist
FLI = FL
def FLL(nested):
  return list(FL(nested))
def totalLen(nested):
  return len(FLL(nested))
def intersect(lists):
  if len(lists) == 0: return lists
  if len(lists) == 1: return lists[0]
  finalList = set(lists[0])
  for aList in lists[1:]:
	finalList = finalList & set(aList)
  return list(finalList)
def intersectAll(*lists):
  if len(lists) == 0: return lists
  if len(lists) == 1: return lists[0]
  finalList = set(lists[0])
  for aList in lists[1:]:
	finalList = finalList & set(aList)
  return list(finalList)
def union(lists):
  if len(lists) == 0: return lists
  if len(lists) == 1: return lists[0]
  finalList = set(lists[0])
  for aList in lists[1:]:
	finalList = finalList | set(aList)
  return list(finalList)
def difference(lists):
  if len(lists) == 0: return lists
  if len(lists) == 1: return lists[0]
  finalList = set(lists[0])
  for aList in lists[1:]:
	finalList = finalList - set(aList)
  return list(finalList)
def outer(lists, cuList=[]):
  if lists == []:
	yield cuList
	return
  for element in lists[0]:
	newList = list(cuList)
	newList.append(element)
	for elem in outer(lists[1:], newList):
	  yield elem
def strZip(list1, list2, string):
  result = []
  for x1, x2 in zip(list1, list2):
	result.append(str(x1)+string+str(x2))
  return result
def listToStr(list, seperator=" "):
  return seperator.join(map(str,list))
def applyOrderList(order, aList):
  if order==[]:
	return aList
  else:
	return map(lambda v:aList[v], order)
def applyOrderDic(order, aDic):
  if order==[]:
	return aDic.value()
  else:
	return map(lambda v:aDic[v], order)
def createOrderList(wantedOrder, currentOrder):
  return map(lambda x:currentOrder.index(x), wantedOrder)
def firstOccurenceInStr(aList, aString):
  for elem in aList:
	if elem in aString:
	  return elem
  else:
	return None
def getTailNumber(string):
	num = re.findall(r"[0-9][0-9\.]*", string)
	if num != []:
		return num[len(num)-1]
	else:
		return ""
def areDefined(names, dic):
  key_list = dic.keys()
  names = toList(names)
  for aName in names:
	if aName not in key_list: return False
	if dic[aName] == None: return False
  else:
	return True
def itemsList(dic):
  return map(list, dic.items())
def split(a_string, seperator):
  return a_string.split(seperator)
def _mimicCore(patternList, flatList):
  for elem in patternList:
	if type(elem) != type([]):
	  yield flatList[0]
	  flatList = flatList[1:]
	  continue
	else:
	  yield list(_mimicCore(elem, flatList[:len(list(FL(elem)))]))
	  flatList = flatList[len(list(FL(elem))):]
def mimic(patternList, flatList):
  if len(list(FL(patternList))) != len(flatList):
	print("patternList must have the same number of total elements as flatList!")
	return None
  return list(_mimicCore(patternList, flatList))
def containedIn(smaller, larger):
  for elem in toList(smaller):
	if elem not in larger: return False
  else:
	return True
def biDifference(larger, smaller):
  largerCopy = list(larger)
  for elem in toList(smaller):
	if elem in larger:
	  largerCopy.remove(elem)
  return largerCopy
def biSetDifference(larger, smaller):
  return list(set(flatten(larger))-set(smaller))
def removeListFromDict(aDict, aList):
  aList = toList(aList)
  if aList == []: return aDict
  for elem in aList:
	aDict.pop(elem)
  return aDict
def biIntersectI(list1, list2):
  for elem in toList(list1):
	if elem in list2: yield elem
def subDict(keys, aDict):
  preDict = []
  allKeys = aDict.keys()
  for aKey in toList(keys):
	if aKey in allKeys: preDict.append([aKey, aDict[aKey]])
  return dict(preDict)
def removeDuplicatesSimple(aList):
  return list(set(aList))
def _removeDuplicatesOneLevel(aList):
  result = []
  if aList == []: return
  if type(aList) != type([]): return aList
  for elem in aList:
	if elem not in result: result.append(elem)
  return result
def removeDuplicates(aList):
  if type(aList) != type([]): return aList
  result = []
  for elem in aList:
	result.append(removeDuplicates(elem))
  return _removeDuplicatesOneLevel(result)
def strEqual(str1, str2, ignoreCase=False):
  if ignoreCase==False:
	return str1.strip()==str2.strip()
  else:
	return str1.strip().upper()==str2.strip().upper()
def getValueListFromDict(keys, aDict):
	if type(keys)==type([]):
		return map(lambda x:aDict[x], keys)
	else:
		return []
def addItemsToDict(aList, aDict):
  return dict(removeDuplicates(itemsList(aDict)+aList))
def floatizeL(aList):
  return map(float, aList)
def floatizeItemInDict(aDict, keyList):
	keyList = toList(keyList)
	result = aDict
	for elem in keyList:
		result[elem] = float(aDict[elem])
	return result
def stringizeL(aList):
	if type(aList)==type([]):
		return map(str, flatten(aList))
	else:
		return str(aList)
def transpose(lists):
  if not lists: return []
  return map(lambda *row: list(row), *lists)
def transpose2(lists, defval=0):
  if not lists: return []
  return map(lambda *row: [elem or defval for elem in row], *lists)
def getColumn(data, colN):
  return transpose(data)[colN]
def getColumns(data, col_list):
  result = []
  for aRow in data:
	result.append(map(lambda column: aRow[column], col_list))
  return result
def separateStr(strV, seperationSymbols=[",", ";", " ", "\n"], stripStr=True, nonEmpty=True):
  if not strV:
	return []
  else:
	strings = [strV]
	for aSeperator in seperationSymbols:
		strings = FLL(map(lambda x:split(x, aSeperator), strings))
		if stripStr: strings = [x.strip() for x in strings]
		if nonEmpty: strings = filter(lambda x: x, strings)
  return strings
def readCSESD(strV, connectionSymbol="=", seperationSymbols=[",", " ", "-", "\n", "/", "\\"]):
  result = []
  strings = seperateStr(strV, seperationSymbols)
  for aStr in strings:
	if connectionSymbol not in aStr: continue
	result.append(split(aStr, connectionSymbol))
  result = removeDuplicates(result)
  if not result: result=[]
  if ([""] in result):
	result.remove([""])
  return dict(result)
def connectCSES(aList, connectionSymbol="=", seperationSymbol=","):
  if not aList: return ""
  return seperationSymbol.join(map(lambda x: connectionSymbol.join(x), aList))
def removeTailReturn(aStr):
  if aStr[-1:] == "\n":
	return aStr[:-1]
  else:
	 return aStr
def takeBlock(aList, row_l,row_r,col_l,col_r):
  result = []
  for aRow in aList[row_l:row_r]:
	result.append(aRow[col_l:col_r])
  return result
def takeBlock2(aList, row_list, col_list):
  result = []
  for row in row_list:
	result.append(map(lambda column: aList[row][column], col_list))
  return result
def intStr(i, total=3):
  return '0'*(total-len(str(i)))+str(i)
def isNested(data):
  if not data: return False
  if type(data[0]) != type([]): return False
  return True
def sliceMatrixData(data, columnStep=0, centralLargeness=0):
  Ny, Nx = len(data), len(data[0])
  if columnStep==0: columnStep = Nx
  if Ny % columnStep != 0:
	print("Total length of data is not dividable by columnStep (or did you use float number for colStep?)!")
	return []
  if centralLargeness == 0: centralLargeness = min(columnStep, Nx)
  y_left = int((columnStep-centralLargeness)/2)
  y_right = int((columnStep+centralLargeness)/2)
  x_left = int((Nx-centralLargeness)/2)
  x_right = int((Nx+centralLargeness)/2)
  result = []
  for i in range(Ny/columnStep):
	  result.append(take(data[i*columnStep:(i+1)*columnStep][:], y_left, y_right, x_left, x_right))
  return result
def next(aList, index):
  return (index+1) % len(aList)
def isFloat(string):
  try:
	float(string)
	return True
  except ValueError:
	return False
def zeros(m,n):
  return map(lambda var: map(lambda var: 0, range(n)), range(m));
def stringToNumbers(string, separators=[","], commentSymbol="
  if type(separators)!=type([]): separators = [separators]
  if "
  splitted = [string];
  for separator in flatten(separators): splitted = FLI([x.split(separator) for x in splitted]);
  splitted = FLI([x.split() for x in splitted]);
  if splitted == []: return [];
  lineData = [];
  for piece in splitted:
	if isFloat(piece):
	  lineData.append(float(piece));
	else:
	  lineData.append(piece);
  return lineData;
def tracedSort(L, cmp=None, key=None, reverse=False):
  retL = zip(L, range(len(L)));
  if cmp!=None:
	cmp_result=lambda x,y: cmp(x[0],y[0]);
  else:
	cmp_result=None;
  if key!=None:
	key_result=lambda x: key(x[0]);
  else:
	key_result=None;
  retL.sort(cmp_result, key_result, reverse);
  return [map(lambda x: x[0], retL), map(lambda x: x[1], retL)];
def listFormCubicLatticeD(L):
  L = removeDuplicatesSimple([tuple(x) for x in L]);
  projected = [];
  for ii in range(len(L[0])): projected.append(removeDuplicatesSimple([x[ii] for x in L]));
  product = 1;
  dim = [len(x) for x in projected];
  for x in dim: product = product*x;
  D = {};
  D["answer"] = (len(L)==product);
  D["dim"] = dim;
  return D;