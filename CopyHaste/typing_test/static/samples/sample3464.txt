_q_debug_ = False
def _toList(qvar):
	if type(qvar) != type([]): qvar = [qvar]
	return qvar
def __obsoleted_listNestedDir(dir_path):
	dirL=[dir_path]
	for name in os.listdir(dir_path):
		full_path = os.path.join(dir_path, name)
		if os.path.isdir(full_path):
			dirL.extend(__obsoleted_listNestedDir(full_path))
	return dirL
def _listNestedDir(dir_path):
	return list(map(lambda qvar: qvar[0], os.walk(dir_path)))
def _listNestedDir2(dir_path):
	return map(lambda qvar: qvar[0], os.walk(dir_path))
def _listSpecificNestedDir(dir_path, judgeFunction):
	return filter(judgeFunction, _listNestedDir(dir_path))
def hasNoSubDir(dir_path):
	for name in os.listdir(dir_path):
		full_path = os.path.join(dir_path, name)
		if os.path.isdir(full_path): break
	else:
		return True
	return False
def _listNestedLeafDir(dir_path):
	return _listSpecificNestedDir(dir_path, hasNoSubDir)
def _q_match(pattern, target, flags=None):
	if flags == None:
		return re.findall(pattern, target) != []
	else:
		return re.findall(pattern, target, flags) != []
def hasFiles(dir_path, filenames):
	filenames = _toList(filenames)
	for name in filenames:
		full_path = os.path.join(dir_path, name)
		if os.path.exists(full_path) == False: break
	else:
		return True
	return False
def listNestedDirContainsFiles(dir_path, filenames):
	def hasFilesHook(dir_path):
		return hasFiles(dir_path, filenames)
	return _listSpecificNestedDir(dir_path, hasFilesHook)
def hasFilesM(dir_path, filePatterns, flags=None):
	filenames = _toList(filePatterns)
	listNames = os.listdir(dir_path)
	for namePattern in filenames:
		for existedName in listNames:
			if _q_debug_ == True: print(existedName)
			if _q_match(namePattern, existedName, flags):
				break
		else:
			return False
	else:
		return True
def listNestedDirContainsFilesM(dir_path, filePatterns, flags=None):
	def hasFilesHook(dir_path):
		return hasFilesM(dir_path, filePatterns, flags)
	return _listSpecificNestedDir(dir_path, hasFilesHook)
def hasOneOfFiles(dir_path, filenames):
	filenames = _toList(filenames)
	for name in filenames:
		full_path = os.path.join(dir_path, name)
		if os.path.exists(full_path) == True: break
	else:
		return False
	return True
def listNestedDirContainsOneOfFiles(dir_path, filenames):
	def hasOneOfFilesHook(dir_path):
		return hasOneOfFiles(dir_path, filenames)
	return _listSpecificNestedDir(dir_path, hasOneOfFilesHook)
def hasOneOfFilesM(dir_path, filePatterns, flags=None):
	filenames = _toList(filePatterns)
	listNames = os.listdir(dir_path)
	for namePattern in filenames:
		for existedName in listNames:
			if _q_debug_ == True: print(existedName)
			if _q_match(namePattern, existedName, flags):
				return True
	else:
		return False
def listNestedDirContainsOneOfFilesM(dir_path, filePatterns, flags=None):
	def hasFilesHook(dir_path):
		return hasOneOfFilesM(dir_path, filePatterns, flags)
	return _listSpecificNestedDir(dir_path, hasFilesHook)
def _oneLevelAbove_allSubDirSatisfies(dir_path, judgeFunction):
	if hasNoSubDir(dir_path): return False
	for name in os.listdir(dir_path):
		full_path = os.path.join(dir_path, name)
		if os.path.isdir(full_path) == False: continue
		if judgeFunction(full_path) == False: break
	else:
		return True
	return False
def nested_oneL_allSubDir_hasAll(dir_path, filenames):
	def hook(dpath):
		return _oneLevelAbove_allSubDirSatisfies(dpath,
												lambda qvar: hasFiles(qvar, filenames))
	return _listSpecificNestedDir(dir_path, hook)
def nested_oneL_allSubDir_hasOneOf(dir_path, filenames):
	def hook(dpath):
		return _oneLevelAbove_allSubDirSatisfies(dpath,
												lambda qvar: hasOneOfFiles(qvar, filenames))
	return _listSpecificNestedDir(dir_path, hook)
def _oneLevelAbove_oneSubDirSatisfies(dir_path, judgeFunction):
	for name in os.listdir(dir_path):
		full_path = os.path.join(dir_path, name)
		if os.path.isdir(full_path) == False: continue
		if judgeFunction(full_path) == True: break
	else:
		return False
	return True
def nested_oneL_oneSubDir_hasAll(dir_path, filenames):
	def hook(dpath):
		return _oneLevelAbove_oneSubDirSatisfies(dpath,
												lambda qvar: hasFiles(qvar, filenames))
	return _listSpecificNestedDir(dir_path, hook)
def nested_oneL_oneSubDir_hasOneOf(dir_path, filenames):
	def hook(dpath):
		return _oneLevelAbove_oneSubDirSatisfies(dpath,
												lambda qvar: hasOneOfFiles(qvar, filenames))
	return _listSpecificNestedDir(dir_path, hook)
def listDir(dir_path, leaf_only=False):
	if leaf_only == False:
		functionToUse = _listNestedDir
	else:
		functionToUse = _listNestedLeafDir
	dirL = functionToUse(dir_path)
	return dirL
def listFilesMatch(dir_path, patterns, flags=None):
	patterns = _toList(patterns)
	result = []
	for name in os.listdir(dir_path):
		if os.path.isdir(os.path.join(dir_path, name)): continue
		for pattern in patterns:
			if _q_match(pattern, name, flags):
				result.append(name)
				break
	return result
def _relativePath(dir_path, full_path):
	return os.path.join(".",full_path[len(os.path.normpath(dir_path))+1:])
def _relativePathString(dir_path, full_path):
	return full_path[len(os.path.normpath(dir_path))+1:]
def lookUpForFiles(dir_path, filenames, level=2, notExact=False):
	if notExact == False:
		matchFnc = hasFiles
	else:
		matchFnc = hasFilesM
	currentPath = os.path.normpath(dir_path)
	for ii in range(level):
		if matchFnc(currentPath, filenames):
			return currentPath
		else:
			currentPath = os.path.dirname(currentPath)
	return None
def lookUpForOneOfFiles(dir_path, filenames, level=2, notExact=False):
	if notExact == False:
		matchFnc = hasOneOfFiles
	else:
		matchFnc = hasOneOfFilesM
	currentPath = os.path.normpath(dir_path)
	for ii in range(level):
		if matchFnc(currentPath, filenames):
			return currentPath
		else:
			currentPath = os.path.dirname(currentPath)
	return None
def listSubDirectories(dir_path):
	if not os.path.exists(dir_path):
		print("Path "+dir_path+" does not exist.");
		return [];
	return filter(os.path.isdir, map(lambda x: os.path.join(dir_path,x), os.listdir(dir_path)));
if __name__ == "__main__":
	if len(sys.argv) == 1:
		print("Welcome to dirR module. Use help(dirR) for information. (Zhi Qiu, 2009)")
	else:
		print("Executing: "+sys.argv[1]+"('"+"','".join(sys.argv[2:])+"')")
		exec(sys.argv[1]+"('"+"','".join(sys.argv[2:])+"')")