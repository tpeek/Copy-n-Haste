def WriteList(fp, list, prefix='',
						separator=',\n	',
						preamble=None,
						postamble=None):
  fp.write(preamble or '')
  fp.write((separator or ' ').join([prefix + l for l in list]))
  fp.write(postamble or '')
class TargetBase(object):
  is_ignored = False
  target_prefix = ''
  target_suffix = ''
  def __init__(self, spec):
	self.spec = spec
  def full_product_name(self):
	suffix = self.target_suffix
	product_extension = self.spec.get('product_extension')
	if product_extension:
	  suffix = '.' + product_extension
	prefix = self.spec.get('product_prefix', self.target_prefix)
	name = self.spec['target_name']
	name = prefix + self.spec.get('product_name', name) + suffix
	product_dir = self.spec.get('product_dir')
	if product_dir:
	  name = os.path.join(product_dir, name)
	else:
	  name = os.path.join(self.out_dir, name)
	return name
  def write_input_files(self, fp):
	sources = self.spec.get('sources')
	if not sources:
	  fp.write('\ninput_files = []\n')
	  return
	preamble = '\ninput_files = [\n	'
	postamble = ',\n]\n'
	WriteList(fp, map(repr, sources), preamble=preamble, postamble=postamble)
  def builder_call(self):
	name = self.full_product_name()
	return 'env.%s(env.File(%r), input_files)' % (self.builder_name, name)
  def write_target(self, fp, src_dir='', pre=''):
	fp.write('\n' + pre)
	fp.write('_outputs = %s\n' % self.builder_call())
	fp.write('target_files.extend(_outputs)\n')
class NoneTarget(TargetBase):
  def write_target(self, fp, src_dir='', pre=''):
	fp.write('\ntarget_files.extend(input_files)\n')
class SettingsTarget(TargetBase):
  is_ignored = True
compilable_sources_template =
class CompilableSourcesTargetBase(TargetBase):
  intermediate_builder_name = None
  def write_target(self, fp, src_dir='', pre=''):
	if self.intermediate_builder_name is None:
	  raise NotImplementedError
	if src_dir and not src_dir.endswith('/'):
	  src_dir += '/'
	variables = {
		'src_dir': src_dir,
		'name': self.intermediate_builder_name,
	}
	fp.write(compilable_sources_template % variables)
	super(CompilableSourcesTargetBase, self).write_target(fp)
class ProgramTarget(CompilableSourcesTargetBase):
  builder_name = 'GypProgram'
  intermediate_builder_name = 'StaticObject'
  target_prefix = '${PROGPREFIX}'
  target_suffix = '${PROGSUFFIX}'
  out_dir = '${TOP_BUILDDIR}'
class StaticLibraryTarget(CompilableSourcesTargetBase):
  builder_name = 'GypStaticLibrary'
  intermediate_builder_name = 'StaticObject'
  target_prefix = '${LIBPREFIX}'
  target_suffix = '${LIBSUFFIX}'
  out_dir = '${LIB_DIR}'
class SharedLibraryTarget(CompilableSourcesTargetBase):
  builder_name = 'GypSharedLibrary'
  intermediate_builder_name = 'SharedObject'
  target_prefix = '${SHLIBPREFIX}'
  target_suffix = '${SHLIBSUFFIX}'
  out_dir = '${LIB_DIR}'
class LoadableModuleTarget(CompilableSourcesTargetBase):
  builder_name = 'GypLoadableModule'
  intermediate_builder_name = 'SharedObject'
  target_prefix = '${SHLIBPREFIX}'
  target_suffix = '${SHLIBSUFFIX}'
  out_dir = '${TOP_BUILDDIR}'
TargetMap = {
  None : NoneTarget,
  'none' : NoneTarget,
  'settings' : SettingsTarget,
  'executable' : ProgramTarget,
  'static_library' : StaticLibraryTarget,
  'shared_library' : SharedLibraryTarget,
  'loadable_module' : LoadableModuleTarget,
}
def Target(spec):
  return TargetMap[spec.get('type')](spec)