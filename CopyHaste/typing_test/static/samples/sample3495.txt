WriteList = SCons.WriteList
generator_default_variables = {
	'EXECUTABLE_PREFIX': '',
	'EXECUTABLE_SUFFIX': '',
	'STATIC_LIB_PREFIX': '${LIBPREFIX}',
	'SHARED_LIB_PREFIX': '${SHLIBPREFIX}',
	'STATIC_LIB_SUFFIX': '${LIBSUFFIX}',
	'SHARED_LIB_SUFFIX': '${SHLIBSUFFIX}',
	'INTERMEDIATE_DIR': '${INTERMEDIATE_DIR}',
	'SHARED_INTERMEDIATE_DIR': '${SHARED_INTERMEDIATE_DIR}',
	'OS': 'linux',
	'PRODUCT_DIR': '$TOP_BUILDDIR',
	'SHARED_LIB_DIR': '$LIB_DIR',
	'LIB_DIR': '$LIB_DIR',
	'RULE_INPUT_ROOT': '${SOURCE.filebase}',
	'RULE_INPUT_DIRNAME': '${SOURCE.dir}',
	'RULE_INPUT_EXT': '${SOURCE.suffix}',
	'RULE_INPUT_NAME': '${SOURCE.file}',
	'RULE_INPUT_PATH': '${SOURCE.abspath}',
	'CONFIGURATION_NAME': '${CONFIG_NAME}',
}
generator_handles_variants = True
generator_wants_absolute_build_file_paths = True
def FixPath(path, prefix):
  if not os.path.isabs(path) and not path[0] == '$':
	path = prefix + path
  return path
header =
_alias_template =
_run_as_template =
_run_as_template_suffix =
_command_template =
_copy_action_template =
_rule_template =
_spawn_hack =
def EscapeShellArgument(s):
  return "'" + s.replace("'", "'\\''") + "'"
def InvertNaiveSConsQuoting(s):
  if ' ' in s or '\t' in s:
	s = '"' + s + '"'
  return s
def EscapeSConsVariableExpansion(s):
  return s.replace('$', '$$$$')
def EscapeCppDefine(s):
  s = EscapeShellArgument(s)
  s = InvertNaiveSConsQuoting(s)
  s = EscapeSConsVariableExpansion(s)
  return s
def GenerateConfig(fp, config, indent='', src_dir=''):
  var_mapping = {
	  'ASFLAGS' : 'asflags',
	  'CCFLAGS' : 'cflags',
	  'CFLAGS' : 'cflags_c',
	  'CXXFLAGS' : 'cflags_cc',
	  'CPPDEFINES' : 'defines',
	  'CPPPATH' : 'include_dirs',
	  'LINKFLAGS' : 'ldflags',
  }
  postamble='\n%s],\n' % indent
  for scons_var in sorted(var_mapping.keys()):
	  gyp_var = var_mapping[scons_var]
	  value = config.get(gyp_var)
	  if value:
		if gyp_var in ('defines',):
		  value = [EscapeCppDefine(v) for v in value]
		if gyp_var in ('include_dirs',):
		  if src_dir and not src_dir.endswith('/'):
			src_dir += '/'
		  result = []
		  for v in value:
			v = FixPath(v, src_dir)
			result.append('env.Dir(%r)' % v)
		  value = result
		else:
		  value = map(repr, value)
		WriteList(fp,
				  value,
				  prefix=indent,
				  preamble='%s%s = [\n	' % (indent, scons_var),
				  postamble=postamble)
def GenerateSConscript(output_filename, spec, build_file, build_file_data):
  scons_target = SCons.Target(spec)
  gyp_dir = os.path.dirname(output_filename)
  if not gyp_dir:
	  gyp_dir = '.'
  gyp_dir = os.path.abspath(gyp_dir)
  output_dir = os.path.dirname(output_filename)
  src_dir = build_file_data['_DEPTH']
  src_dir_rel = gyp.common.RelativePath(src_dir, output_dir)
  subdir = gyp.common.RelativePath(os.path.dirname(build_file), src_dir)
  src_subdir = '$SRC_DIR/' + subdir
  src_subdir_ = src_subdir + '/'
  component_name = os.path.splitext(os.path.basename(build_file))[0]
  target_name = spec['target_name']
  if not os.path.exists(gyp_dir):
	os.makedirs(gyp_dir)
  fp = open(output_filename, 'w')
  fp.write(header)
  fp.write('\n
  fp.write('\nImport("env")\n')
  fp.write('env = env.Clone(COMPONENT_NAME=%s,\n' % repr(component_name))
  fp.write('				TARGET_NAME=%s)\n' % repr(target_name))
	if config.get('scons_line_length'):
	  fp.write(_spawn_hack)
	  break
  fp.write('\n')
  fp.write('configurations = {\n')
  for config_name, config in spec['configurations'].iteritems():
	fp.write('	\'%s\' : {\n' % config_name)
	fp.write('		\'Append\' : dict(\n')
	GenerateConfig(fp, config, indent, src_subdir)
	libraries = spec.get('libraries')
	if libraries:
	  WriteList(fp,
				map(repr, libraries),
				prefix=indent,
				preamble='%sLIBS = [\n	' % indent,
				postamble='\n%s],\n' % indent)
	fp.write('		),\n')
	fp.write('		\'FilterOut\' : dict(\n' )
	for key, var in config.get('scons_remove', {}).iteritems():
	  fp.write('			 %s = %s,\n' % (key, repr(var)))
	fp.write('		),\n')
	fp.write('		\'Replace\' : dict(\n' )
	scons_settings = config.get('scons_variable_settings', {})
	for key in sorted(scons_settings.keys()):
	  val = pprint.pformat(scons_settings[key])
	  fp.write('			 %s = %s,\n' % (key, val))
	if 'c++' in spec.get('link_languages', []):
	  fp.write('			 %s = %s,\n' % ('LINK', repr('$CXX')))
	if config.get('scons_line_length'):
	  fp.write('			 SPAWN = gyp_spawn,\n')
	fp.write('		),\n')
	fp.write('		\'ImportExternal\' : [\n' )
	for var in config.get('scons_
	  fp.write('			 %s,\n' % repr(var))
	fp.write('		],\n')
	fp.write('		\'PropagateExternal\' : [\n' )
	for var in config.get('scons_propagate_variables', []):
	  fp.write('			 %s,\n' % repr(var))
	fp.write('		],\n')
	fp.write('	},\n')
  fp.write('}\n')
  fp.write('\n'
		   'config = configurations[env[\'CONFIG_NAME\']]\n'
		   'env.Append(**config[\'Append\'])\n'
		   'env.FilterOut(**config[\'FilterOut\'])\n'
		   'env.Replace(**config[\'Replace\'])\n')
  fp.write('\n'
		   '
		   '
		   '
		   '
		   '
		   'env[\'SHCCFLAGS\'] = [\'$CCFLAGS\']\n')
  fp.write('\n'
		   'for _var in config[\'ImportExternal\']:\n'
		   '  if _var in ARGUMENTS:\n'
		   '	env[_var] = ARGUMENTS[_var]\n'
		   '  elif _var in os.environ:\n'
		   '	env[_var] = os.environ[_var]\n'
		   'for _var in config[\'PropagateExternal\']:\n'
		   '  if _var in ARGUMENTS:\n'
		   '	env[_var] = ARGUMENTS[_var]\n'
		   '  elif _var in os.environ:\n'
		   '	env[\'ENV\'][_var] = os.environ[_var]\n')
  fp.write('\n'
		   "env['ENV']['LD_LIBRARY_PATH'] = env.subst('$LIB_DIR')\n")
  variants = spec.get('variants', {})
  for setting in sorted(variants.keys()):
	if_fmt = 'if ARGUMENTS.get(%s) not in (None, \'0\'):\n'
	fp.write('\n')
	fp.write(if_fmt % repr(setting.upper()))
	fp.write('  env.AppendUnique(\n')
	GenerateConfig(fp, variants[setting], indent, src_subdir)
	fp.write('  )\n')
  fp.write('\n')
  fp.write('target_files = []\n')
  prerequisites = spec.get('scons_prerequisites', [])
  fp.write('prerequisites = %s\n' % pprint.pformat(prerequisites))
  actions = spec.get('actions', [])
  for action in actions:
	a = ['cd', src_subdir, '&&'] + action['action']
	message = action.get('message')
	if message:
	  message = repr(message)
	inputs = [FixPath(f, src_subdir_) for f in action.get('inputs', [])]
	outputs = [FixPath(f, src_subdir_) for f in action.get('outputs', [])]
	if outputs:
	  template = _command_template
	else:
	  template = _alias_template
	fp.write(template % {
				 'inputs' : pprint.pformat(inputs),
				 'outputs' : pprint.pformat(outputs),
				 'action' : pprint.pformat(a),
				 'message' : message,
				 'target_name': target_name,
			 })
	if int(action.get('process_outputs_as_sources', 0)):
	  fp.write('input_files.extend(_outputs)\n')
	fp.write('prerequisites.extend(_outputs)\n')
	fp.write('target_files.extend(_outputs)\n')
  rules = spec.get('rules', [])
  for rule in rules:
	name = re.sub('[^a-zA-Z0-9_]', '_', rule['rule_name'])
	message = rule.get('message')
	if message:
		message = repr(message)
	if int(rule.get('process_outputs_as_sources', 0)):
	  poas_line = '_processed_input_files.extend(_generated)'
	else:
	  poas_line = '_processed_input_files.append(infile)'
	inputs = [FixPath(f, src_subdir_) for f in rule.get('inputs', [])]
	outputs = [FixPath(f, src_subdir_) for f in rule.get('outputs', [])]
	if 'action' not in rule and not rule.get('rule_sources', []):
	  continue
	a = ['cd', src_subdir, '&&'] + rule['action']
	fp.write(_rule_template % {
				 'inputs' : pprint.pformat(inputs),
				 'outputs' : pprint.pformat(outputs),
				 'action' : pprint.pformat(a),
				 'extension' : rule['extension'],
				 'name' : name,
				 'message' : message,
				 'process_outputs_as_sources_line' : poas_line,
				 'src_dir' : src_subdir_,
			 })
  scons_target.write_target(fp, src_subdir)
  copies = spec.get('copies', [])
  if copies:
	fp.write(_copy_action_template)
  for copy in copies:
	destdir = None
	files = None
	try:
	  destdir = copy['destination']
	except KeyError, e:
	  gyp.common.ExceptionAppend(
		e,
		"Required 'destination' key missing for 'copies' in %s." % build_file)
	  raise
	try:
	  files = copy['files']
	except KeyError, e:
	  gyp.common.ExceptionAppend(
		e, "Required 'files' key missing for 'copies' in %s." % build_file)
	  raise
	if not files:
	  continue
	if not destdir:
	  raise Exception(
		"Required 'destination' key is empty for 'copies' in %s." % build_file)
	fmt = ('\n'
		   '_outputs = env.Command(%s,\n'
		   '	%s,\n'
		   '	GYPCopy(\'$TARGET\', \'$SOURCE\'))\n')
	for f in copy['files']:
	  dest = os.path.join(destdir, os.path.basename(f.rstrip(os.sep)))
	  f = FixPath(f, src_subdir_)
	  dest = FixPath(dest, src_subdir_)
	  fp.write(fmt % (repr(dest), repr(f)))
	  fp.write('target_files.extend(_outputs)\n')
  run_as = spec.get('run_as')
  if run_as:
	action = run_as.get('action', [])
	working_directory = run_as.get('working_directory')
	if not working_directory:
	  working_directory = gyp_dir
	else:
	  if not os.path.isabs(working_directory):
		working_directory = os.path.normpath(os.path.join(gyp_dir,
														  working_directory))
	if run_as.get('environment'):
	  for (key, val) in run_as.get('environment').iteritems():
		action = ['%s="%s"' % (key, val)] + action
	action = ['cd', '"%s"' % working_directory, '&&'] + action
	fp.write(_run_as_template % {
	  'action' : pprint.pformat(action),
	  'message' : run_as.get('message', ''),
	})
  fmt = "\ngyp_target = env.Alias('%s', target_files)\n"
  fp.write(fmt % target_name)
  dependencies = spec.get('scons_dependencies', [])
  if dependencies:
	WriteList(fp, dependencies, preamble='dependencies = [\n	',
								postamble='\n]\n')
	fp.write('env.Requires(target_files, dependencies)\n')
	fp.write('env.Requires(gyp_target, dependencies)\n')
	fp.write('for prerequisite in prerequisites:\n')
	fp.write('  env.Requires(prerequisite, dependencies)\n')
  fp.write('env.Requires(gyp_target, prerequisites)\n')
  if run_as:
	fp.write(_run_as_template_suffix % {
	  'target_name': target_name,
	})
  fp.write('Return("gyp_target")\n')
  fp.close()
_wrapper_template =
def GenerateSConscriptWrapper(build_file, build_file_data, name,
							  output_filename, sconscript_files,
							  default_configuration):
  output_dir = os.path.dirname(output_filename)
  src_dir = build_file_data['_DEPTH']
  src_dir_rel = gyp.common.RelativePath(src_dir, output_dir)
  if not src_dir_rel:
	src_dir_rel = '.'
  scons_settings = build_file_data.get('scons_settings', {})
  sconsbuild_dir = scons_settings.get('sconsbuild_dir', '
  scons_tools = scons_settings.get('tools', ['default'])
  sconscript_file_lines = ['dict(']
  for target in sorted(sconscript_files.keys()):
	sconscript = sconscript_files[target]
	sconscript_file_lines.append('	%s = %r,' % (target, sconscript))
  sconscript_file_lines.append(')')
  fp = open(output_filename, 'w')
  fp.write(header)
  fp.write(_wrapper_template % {
			   'default_configuration' : default_configuration,
			   'name' : name,
			   'scons_tools' : repr(scons_tools),
			   'sconsbuild_dir' : repr(sconsbuild_dir),
			   'sconscript_files' : '\n'.join(sconscript_file_lines),
			   'src_dir' : src_dir_rel,
		   })
  fp.close()
  dir, fname = os.path.split(output_filename)
  SConstruct = os.path.join(dir, 'SConstruct')
  fp = open(SConstruct, 'w')
  fp.write(header)
  fp.write('SConscript(%s)\n' % repr(fname))
  fp.close()
def TargetFilename(target, build_file=None, output_suffix=''):
  if build_file is None:
	build_file, target = gyp.common.ParseQualifiedTarget(target)[:2]
  output_file = os.path.join(os.path.dirname(build_file),
							 target + output_suffix + '.scons')
  return output_file
def PerformBuild(data, configurations, params):
  options = params['options']
  scons = 'scons'
  paths = os.environ['PATH'].split(os.pathsep)
  for scons_name in ['scons', 'scons.py']:
	for path in paths:
	  test_scons = os.path.join(path, scons_name)
	  print 'looking for: %s' % test_scons
	  if os.path.exists(test_scons):
		print "found scons: %s" % scons
		scons = test_scons
		break
  for config in configurations:
	arguments = [scons, '-C', options.toplevel_dir, '--mode=%s' % config]
	print "Building [%s]: %s" % (config, arguments)
	subprocess.check_call(arguments)
def GenerateOutput(target_list, target_dicts, data, params):
  options = params['options']
  if options.generator_output:
	def output_path(filename):
	  return filename.replace(params['cwd'], options.generator_output)
  else:
	def output_path(filename):
	  return filename
  default_configuration = None
  for qualified_target in target_list:
	spec = target_dicts[qualified_target]
	if spec['toolset'] != 'target':
	  raise Exception(
		  'Multiple toolsets not supported in scons build (target %s)' %
		  qualified_target)
	scons_target = SCons.Target(spec)
	if scons_target.is_ignored:
	  continue
	if (not default_configuration and
		spec['default_configuration'] != 'Default'):
	  default_configuration = spec['default_configuration']
	build_file, target = gyp.common.ParseQualifiedTarget(qualified_target)[:2]
	output_file = TargetFilename(target, build_file, options.suffix)
	if options.generator_output:
	  output_file = output_path(output_file)
	if not spec.has_key('libraries'):
	  spec['libraries'] = []
	deps = spec.get('dependencies', [])
	spec['scons_dependencies'] = []
	for d in deps:
	  td = target_dicts[d]
	  target_name = td['target_name']
	  spec['scons_dependencies'].append("Alias('%s')" % target_name)
	  if td['type'] in ('static_library', 'shared_library'):
		libname = td.get('product_name', target_name)
		spec['libraries'].append('lib' + libname)
	  if td['type'] == 'loadable_module':
		prereqs = spec.get('scons_prerequisites', [])
		td_target = SCons.Target(td)
		td_target.target_prefix = '${SHLIBPREFIX}'
		td_target.target_suffix = '${SHLIBSUFFIX}'
	GenerateSConscript(output_file, spec, build_file, data[build_file])
  if not default_configuration:
	default_configuration = 'Default'
  for build_file in sorted(data.keys()):
	path, ext = os.path.splitext(build_file)
	if ext != '.gyp':
	  continue
	output_dir, basename = os.path.split(path)
	output_filename  = path + '_main' + options.suffix + '.scons'
	all_targets = gyp.common.AllTargets(target_list, target_dicts, build_file)
	sconscript_files = {}
	for t in all_targets:
	  scons_target = SCons.Target(target_dicts[t])
	  if scons_target.is_ignored:
		continue
	  bf, target = gyp.common.ParseQualifiedTarget(t)[:2]
	  target_filename = TargetFilename(target, bf, options.suffix)
	  tpath = gyp.common.RelativePath(target_filename, output_dir)
	  sconscript_files[target] = tpath
	output_filename = output_path(output_filename)
	if sconscript_files:
	  GenerateSConscriptWrapper(build_file, data[build_file], basename,
								output_filename, sconscript_files,
								default_configuration)