def main(args):
  executor = MacTool()
  exit_code = executor.Dispatch(args)
  if exit_code is not None:
	sys.exit(exit_code)
class MacTool(object):
  def Dispatch(self, args):
	if len(args) < 1:
	  raise Exception("Not enough arguments")
	method = "Exec%s" % self._CommandifyName(args[0])
	return getattr(self, method)(*args[1:])
  def _CommandifyName(self, name_string):
	return name_string.title().replace('-', '')
  def ExecCopyBundleResource(self, source, dest):
	extension = os.path.splitext(source)[1].lower()
	if os.path.isdir(source):
	  if os.path.exists(dest):
		shutil.rmtree(dest)
	  shutil.copytree(source, dest)
	elif extension == '.xib':
	  return self._CopyXIBFile(source, dest)
	elif extension == '.storyboard':
	  return self._CopyXIBFile(source, dest)
	elif extension == '.strings':
	  self._CopyStringsFile(source, dest)
	else:
	  shutil.copy(source, dest)
  def _CopyXIBFile(self, source, dest):
	base = os.path.dirname(os.path.realpath(__file__))
	if os.path.relpath(source):
	  source = os.path.join(base, source)
	if os.path.relpath(dest):
	  dest = os.path.join(base, dest)
	args = ['xcrun', 'ibtool', '--errors', '--warnings', '--notices',
		'--output-format', 'human-readable-text', '--compile', dest, source]
	ibtool_section_re = re.compile(r'/\*.*\*/')
	ibtool_re = re.compile(r'.*note:.*is clipping its content')
	ibtoolout = subprocess.Popen(args, stdout=subprocess.PIPE)
	current_section_header = None
	for line in ibtoolout.stdout:
	  if ibtool_section_re.match(line):
		current_section_header = line
	  elif not ibtool_re.match(line):
		if current_section_header:
		  sys.stdout.write(current_section_header)
		  current_section_header = None
		sys.stdout.write(line)
	return ibtoolout.returncode
  def _CopyStringsFile(self, source, dest):
	input_code = self._DetectInputEncoding(source) or "UTF-8"
	s = open(source, 'rb').read()
	d = CoreFoundation.CFDataCreate(None, s, len(s))
	_, error = CoreFoundation.CFPropertyListCreateFromXMLData(None, d, 0, None)
	if error:
	  return
	fp = open(dest, 'wb')
	fp.write(s.decode(input_code).encode('UTF-16'))
	fp.close()
  def _DetectInputEncoding(self, file_name):
	fp = open(file_name, 'rb')
	try:
	  header = fp.read(3)
	except e:
	  fp.close()
	  return None
	fp.close()
	if header.startswith("\xFE\xFF"):
	  return "UTF-16"
	elif header.startswith("\xFF\xFE"):
	  return "UTF-16"
	elif header.startswith("\xEF\xBB\xBF"):
	  return "UTF-8"
	else:
	  return None
  def ExecCopyInfoPlist(self, source, dest, *keys):
	fd = open(source, 'r')
	lines = fd.read()
	fd.close()
	plist = plistlib.readPlistFromString(lines)
	if keys:
	  plist = dict(plist.items() + json.loads(keys[0]).items())
	lines = plistlib.writePlistToString(plist)
	IDENT_RE = re.compile('[/\s]')
	for key in os.environ:
	  if key.startswith('_'):
		continue
	  evar = '${%s}' % key
	  evalue = os.environ[key]
	  lines = string.replace(lines, evar, evalue)
	  evar = '${%s:identifier}' % key
	  evalue = IDENT_RE.sub('_', os.environ[key])
	  lines = string.replace(lines, evar, evalue)
	  evar = '${%s:rfc1034identifier}' % key
	  evalue = IDENT_RE.sub('-', os.environ[key])
	  lines = string.replace(lines, evar, evalue)
	lines = lines.split('\n')
	for i in range(len(lines)):
	  if lines[i].strip().startswith("<string>${"):
		lines[i] = None
		lines[i - 1] = None
	lines = '\n'.join(filter(lambda x: x is not None, lines))
	fd = open(dest, 'w')
	fd.write(lines)
	fd.close()
	self._WritePkgInfo(dest)
  def _WritePkgInfo(self, info_plist):
	plist = plistlib.readPlist(info_plist)
	if not plist:
	  return
	package_type = plist['CFBundlePackageType']
	if package_type != 'APPL':
	  return
	signature_code = plist.get('CFBundleSignature', '????')
	if len(signature_code) != 4:
	  signature_code = '?' * 4
	dest = os.path.join(os.path.dirname(info_plist), 'PkgInfo')
	fp = open(dest, 'w')
	fp.write('%s%s' % (package_type, signature_code))
	fp.close()
  def ExecFlock(self, lockfile, *cmd_list):
	fd = os.open(lockfile, os.O_RDONLY|os.O_NOCTTY|os.O_CREAT, 0o666)
	fcntl.flock(fd, fcntl.LOCK_EX)
	return subprocess.call(cmd_list)
  def ExecFilterLibtool(self, *cmd_list):
	libtool_re = re.compile(r'^.*libtool: file: .* has no symbols$')
	libtoolout = subprocess.Popen(cmd_list, stderr=subprocess.PIPE)
	_, err = libtoolout.communicate()
	for line in err.splitlines():
	  if not libtool_re.match(line):
		print >>sys.stderr, line
	return libtoolout.returncode
  def ExecPackageFramework(self, framework, version):
	binary = os.path.basename(framework).split('.')[0]
	CURRENT = 'Current'
	RESOURCES = 'Resources'
	VERSIONS = 'Versions'
	if not os.path.exists(os.path.join(framework, VERSIONS, version, binary)):
	  return
	pwd = os.getcwd()
	os.chdir(framework)
	self._Relink(version, os.path.join(VERSIONS, CURRENT))
	self._Relink(os.path.join(VERSIONS, CURRENT, binary), binary)
	self._Relink(os.path.join(VERSIONS, CURRENT, RESOURCES), RESOURCES)
	os.chdir(pwd)
  def _Relink(self, dest, link):
	if os.path.lexists(link):
	  os.remove(link)
	os.symlink(dest, link)
  def ExecCodeSignBundle(self, key, resource_rules, entitlements, provisioning):
	resource_rules_path = self._InstallResourceRules(resource_rules)
	substitutions, overrides = self._InstallProvisioningProfile(
		provisioning, self._GetCFBundleIdentifier())
	entitlements_path = self._InstallEntitlements(
		entitlements, substitutions, overrides)
	subprocess.check_call([
		'codesign', '--force', '--sign', key, '--resource-rules',
		resource_rules_path, '--entitlements', entitlements_path,
		os.path.join(
			os.environ['TARGET_BUILD_DIR'],
			os.environ['FULL_PRODUCT_NAME'])])
  def _InstallResourceRules(self, resource_rules):
	source_path = resource_rules
	target_path = os.path.join(
		os.environ['BUILT_PRODUCTS_DIR'],
		os.environ['CONTENTS_FOLDER_PATH'],
		'ResourceRules.plist')
	if not source_path:
	  source_path = os.path.join(
		  os.environ['SDKROOT'], 'ResourceRules.plist')
	shutil.copy2(source_path, target_path)
	return target_path
  def _InstallProvisioningProfile(self, profile, bundle_identifier):
	source_path, provisioning_data, team_id = self._FindProvisioningProfile(
		profile, bundle_identifier)
	target_path = os.path.join(
		os.environ['BUILT_PRODUCTS_DIR'],
		os.environ['CONTENTS_FOLDER_PATH'],
		'embedded.mobileprovision')
	shutil.copy2(source_path, target_path)
	substitutions = self._GetSubstitutions(bundle_identifier, team_id + '.')
	return substitutions, provisioning_data['Entitlements']
  def _FindProvisioningProfile(self, profile, bundle_identifier):
	profiles_dir = os.path.join(
		os.environ['HOME'], 'Library', 'MobileDevice', 'Provisioning Profiles')
	if not os.path.isdir(profiles_dir):
	  print >>sys.stderr, (
		  'cannot find mobile provisioning for %s' % bundle_identifier)
	  sys.exit(1)
	provisioning_profiles = None
	if profile:
	  profile_path = os.path.join(profiles_dir, profile + '.mobileprovision')
	  if os.path.exists(profile_path):
		provisioning_profiles = [profile_path]
	if not provisioning_profiles:
	  provisioning_profiles = glob.glob(
		  os.path.join(profiles_dir, '*.mobileprovision'))
	valid_provisioning_profiles = {}
	for profile_path in provisioning_profiles:
	  profile_data = self._LoadProvisioningProfile(profile_path)
	  app_id_pattern = profile_data.get(
		  'Entitlements', {}).get('application-identifier', '')
	  for team_identifier in profile_data.get('TeamIdentifier', []):
		app_id = '%s.%s' % (team_identifier, bundle_identifier)
		if fnmatch.fnmatch(app_id, app_id_pattern):
		  valid_provisioning_profiles[app_id_pattern] = (
			  profile_path, profile_data, team_identifier)
	if not valid_provisioning_profiles:
	  print >>sys.stderr, (
		  'cannot find mobile provisioning for %s' % bundle_identifier)
	  sys.exit(1)
	selected_key = max(valid_provisioning_profiles, key=lambda v: len(v))
	return valid_provisioning_profiles[selected_key]
  def _LoadProvisioningProfile(self, profile_path):
	with tempfile.NamedTemporaryFile() as temp:
	  subprocess.check_call([
		  'security', 'cms', '-D', '-i', profile_path, '-o', temp.name])
	  return self._LoadPlistMaybeBinary(temp.name)
  def _LoadPlistMaybeBinary(self, plist_path):
	try:
	  return plistlib.readPlist(plist_path)
	except:
	  pass
	with tempfile.NamedTemporaryFile() as temp:
	  shutil.copy2(plist_path, temp.name)
	  subprocess.check_call(['plutil', '-convert', 'xml1', temp.name])
	  return plistlib.readPlist(temp.name)
  def _GetSubstitutions(self, bundle_identifier, app_identifier_prefix):
	return {
	  'CFBundleIdentifier': bundle_identifier,
	  'AppIdentifierPrefix': app_identifier_prefix,
	}
  def _GetCFBundleIdentifier(self):
	info_plist_path = os.path.join(
		os.environ['TARGET_BUILD_DIR'],
		os.environ['INFOPLIST_PATH'])
	info_plist_data = self._LoadPlistMaybeBinary(info_plist_path)
	return info_plist_data['CFBundleIdentifier']
  def _InstallEntitlements(self, entitlements, substitutions, overrides):
	source_path = entitlements
	target_path = os.path.join(
		os.environ['BUILT_PRODUCTS_DIR'],
		os.environ['PRODUCT_NAME'] + '.xcent')
	if not source_path:
	  source_path = os.path.join(
		  os.environ['SDKROOT'],
		  'Entitlements.plist')
	shutil.copy2(source_path, target_path)
	data = self._LoadPlistMaybeBinary(target_path)
	data = self._ExpandVariables(data, substitutions)
	if overrides:
	  for key in overrides:
		if key not in data:
		  data[key] = overrides[key]
	plistlib.writePlist(data, target_path)
	return target_path
  def _ExpandVariables(self, data, substitutions):
	if isinstance(data, str):
	  for key, value in substitutions.iteritems():
		data = data.replace('$(%s)' % key, value)
	  return data
	if isinstance(data, list):
	  return [self._ExpandVariables(v, substitutions) for v in data]
	if isinstance(data, dict):
	  return dict((k, self._ExpandVariables(data[k],
											substitutions)) for k in data)
	return data
if __name__ == '__main__':
  sys.exit(main(sys.argv[1:]))