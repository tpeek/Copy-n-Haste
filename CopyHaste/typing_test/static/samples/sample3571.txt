'GCC':	 (4,4,0),
'CXXABI':  (1,3,3),
'GLIBCXX': (3,4,13),
'GLIBC':   (2,11)
}
IGNORE_EXPORTS = {
'_edata', '_end', '_init', '__bss_start', '_fini'
}
READELF_CMD = '/usr/bin/readelf'
CPPFILT_CMD = '/usr/bin/c++filt'
class CPPFilt(object):
	def __init__(self):
		self.proc = subprocess.Popen(CPPFILT_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
	def __call__(self, mangled):
		self.proc.stdin.write(mangled + '\n')
		return self.proc.stdout.readline().rstrip()
	def close(self):
		self.proc.stdin.close()
		self.proc.stdout.close()
		self.proc.wait()
def read_symbols(executable,
	p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
	(stdout, stderr) = p.communicate()
	if p.returncode:
		raise IOError('Could not read symbols for %s: %s' % (executable, stderr.strip()))
	syms = []
	for line in stdout.split('\n'):
		line = line.split()
		if len(line)>7 and re.match('[0-9]+:$', line[0]):
			(sym, _, version) = line[7].partition('@')
			is_
			if version.startswith('@'):
				version = version[1:]
			if is_
				syms.append((sym, version))
	return syms
def check_version(max_versions, version):
	if '_' in version:
		(lib, _, ver) = version.rpartition('_')
	else:
		lib = version
		ver = '0'
	ver = tuple([int(x) for x in ver.split('.')])
	if not lib in max_versions:
		return False
	return ver <= max_versions[lib]
if __name__ == '__main__':
	cppfilt = CPPFilt()
	retval = 0
	for filename in sys.argv[1:]:
		for sym,version in read_symbols(filename, True):
			if version and not check_version(MAX_VERSIONS, version):
				print('%s: symbol %s
				retval = 1
		for sym,version in read_symbols(filename, False):
			if sym in IGNORE_EXPORTS:
				continue
			print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym)))
			retval = 1
	exit(retval)