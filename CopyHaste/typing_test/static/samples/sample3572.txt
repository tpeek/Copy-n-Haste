TX = 'tx'
SOURCE_LANG = 'bitcredit_en.ts'
LOCALE_DIR = 'src/qt/locale'
def check_at_repository_root():
	if not os.path.exists('.git'):
		print('No .git directory found')
		print('Execute this script at the root of the repository', file=sys.stderr)
		exit(1)
def fetch_all_translations():
	if subprocess.call([TX, 'pull', '-f']):
		print('Error while fetching translations', file=sys.stderr)
		exit(1)
def find_format_specifiers(s):
	pos = 0
	specifiers = []
	while True:
		percent = s.find('%', pos)
		if percent < 0:
			break
		specifiers.append(s[percent+1])
		pos = percent+2
	return specifiers
def split_format_specifiers(specifiers):
	numeric = []
	other = []
	for s in specifiers:
		if s in {'1','2','3','4','5','6','7','8','9'}:
			numeric.append(s)
		else:
			other.append(s)
	return set(numeric),other
def sanitize_string(s):
	return s.replace('\n',' ')
def check_format_specifiers(source, translation, errors):
	source_f = split_format_specifiers(find_format_specifiers(source))
	assert(not(source_f[0] and source_f[1]))
	try:
		translation_f = split_format_specifiers(find_format_specifiers(translation))
	except IndexError:
		errors.append("Parse error in translation '%s'" % sanitize_string(translation))
		return False
	else:
		if source_f != translation_f:
			errors.append("Mismatch between '%s' and '%s'" % (sanitize_string(source), sanitize_string(translation)))
			return False
	return True
def all_ts_files(suffix=''):
	for filename in os.listdir(LOCALE_DIR):
		if not filename.endswith('.ts'+suffix) or filename == SOURCE_LANG+suffix:
			continue
		if suffix:
			filename = filename[0:-len(suffix)]
		filepath = os.path.join(LOCALE_DIR, filename)
		yield(filename, filepath)
FIX_RE = re.compile(b'[\x00-\x09\x0b\x0c\x0e-\x1f]')
def remove_invalid_characters(s):
	return FIX_RE.sub(b'', s)
_orig_escape_cdata = None
def escape_cdata(text):
	text = _orig_escape_cdata(text)
	text = text.replace("'", '&apos;')
	text = text.replace('"', '&quot;')
	return text
def postprocess_translations(reduce_diff_hacks=False):
	print('Checking and postprocessing...')
	if reduce_diff_hacks:
		global _orig_escape_cdata
		_orig_escape_cdata = ET._escape_cdata
		ET._escape_cdata = escape_cdata
	for (filename,filepath) in all_ts_files():
		os.rename(filepath, filepath+'.orig')
	have_errors = False
	for (filename,filepath) in all_ts_files('.orig'):
		parser = ET.XMLParser(encoding='utf-8')
		with open(filepath + '.orig', 'rb') as f:
			data = f.read()
		data = remove_invalid_characters(data)
		tree = ET.parse(io.BytesIO(data), parser=parser)
		root = tree.getroot()
		for context in root.findall('context'):
			for message in context.findall('message'):
				numerus = message.get('numerus') == 'yes'
				source = message.find('source').text
				translation_node = message.find('translation')
				if numerus:
					translations = [i.text for i in translation_node.findall('numerusform')]
				else:
					translations = [translation_node.text]
				for translation in translations:
					if translation is None:
						continue
					errors = []
					valid = check_format_specifiers(source, translation, errors)
					for error in errors:
						print('%s: %s' % (filename, error))
					if not valid:
						translation_node.clear()
						translation_node.set('type', 'unfinished')
						have_errors = True
				for location in message.findall('location'):
					message.remove(location)
				if translation_node.get('type') == 'unfinished':
					context.remove(message)
		if reduce_diff_hacks:
			out = io.BytesIO()
			tree.write(out, encoding='utf-8')
			out = out.getvalue()
			out = out.replace(b' />', b'/>')
			with open(filepath, 'wb') as f:
				f.write(out)
		else:
			tree.write(filepath, encoding='utf-8')
	return have_errors
if __name__ == '__main__':
	check_at_repository_root()
	fetch_all_translations()
	postprocess_translations()