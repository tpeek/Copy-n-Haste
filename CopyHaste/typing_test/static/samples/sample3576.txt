BASE_FEE=Decimal("0.001")
def check_json_precision():
	n = Decimal("20000000.00000003")
	satoshis = int(json.loads(json.dumps(float(n)))*1.0e8)
	if satoshis != 2000000000000003:
		raise RuntimeError("JSON encode/decode loses precision")
def determine_db_dir():
	if platform.system() == "Darwin":
		return os.path.expanduser("~/Library/Application Support/Bitcredit/")
	elif platform.system() == "Windows":
		return os.path.join(os.environ['APPDATA'], "Bitcredit")
	return os.path.expanduser("~/.bitcredit")
def read_bitcredit_config(dbdir):
	class FakeSecHead(object):
		def __init__(self, fp):
			self.fp = fp
			self.sechead = '[all]\n'
		def readline(self):
			if self.sechead:
				try: return self.sechead
				finally: self.sechead = None
			else:
				s = self.fp.readline()
				if s.find('
					s = s[0:s.find('
				return s
	config_parser = SafeConfigParser()
	config_parser.readfp(FakeSecHead(open(os.path.join(dbdir, "bitcredit.conf"))))
	return dict(config_parser.items("all"))
def connect_JSON(config):
	testnet = config.get('testnet', '0')
	testnet = (int(testnet) > 0)
	if not 'rpcport' in config:
		config['rpcport'] = 18332 if testnet else 8332
	connect = "http://%s:%s@127.0.0.1:%s"%(config['rpcuser'], config['rpcpassword'], config['rpcport'])
	try:
		result = ServiceProxy(connect)
		if result.getmininginfo()['testnet'] != testnet:
			sys.stderr.write("RPC server at "+connect+" testnet setting mismatch\n")
			sys.exit(1)
		return result
	except:
		sys.stderr.write("Error connecting to RPC server at "+connect+"\n")
		sys.exit(1)
def unlock_wallet(bitcreditd):
	info = bitcreditd.getinfo()
	if 'unlocked_until' not in info:
		return True
	t = int(info['unlocked_until'])
	if t <= time.time():
		try:
			passphrase = getpass.getpass("Wallet is locked; enter passphrase: ")
			bitcreditd.walletpassphrase(passphrase, 5)
		except:
			sys.stderr.write("Wrong passphrase\n")
	info = bitcreditd.getinfo()
	return int(info['unlocked_until']) > time.time()
def list_available(bitcreditd):
	address_summary = dict()
	address_to_account = dict()
	for info in bitcreditd.listreceivedbyaddress(0):
		address_to_account[info["address"]] = info["account"]
	unspent = bitcreditd.listunspent(0)
	for output in unspent:
		rawtx = bitcreditd.getrawtransaction(output['txid'], 1)
		vout = rawtx["vout"][output['vout']]
		pk = vout["scriptPubKey"]
		if pk["type"] != "pubkeyhash" and pk["type"] != "scripthash":
			continue
		
		address = pk["addresses"][0]
		if address in address_summary:
			address_summary[address]["total"] += vout["value"]
			address_summary[address]["outputs"].append(output)
		else:
			address_summary[address] = {
				"total" : vout["value"],
				"outputs" : [output],
				"account" : address_to_account.get(address, "")
				}
	return address_summary
def select_coins(needed, inputs):
	outputs = []
	have = Decimal("0.0")
	n = 0
	while have < needed and n < len(inputs):
		outputs.append({ "txid":inputs[n]["txid"], "vout":inputs[n]["vout"]})
		have += inputs[n]["amount"]
		n += 1
	return (outputs, have-needed)
def create_tx(bitcreditd,
	all_coins = list_available(bitcreditd)
	total_available = Decimal("0.0")
	needed = amount+fee
	potential_inputs = []
	for addr in
		if addr not in all_coins:
			continue
		potential_inputs.extend(all_coins[addr]["outputs"])
		total_available += all_coins[addr]["total"]
	if total_available < needed:
		sys.stderr.write("Error, only %f BTC available, need %f\n"%(total_available, needed));
		sys.exit(1)
	outputs = { toaddress : float(amount) }
	(inputs, change_amount) = select_coins(needed, potential_inputs)
	if change_amount > BASE_FEE:
		change_address =
		if change_address in outputs:
			outputs[change_address] += float(change_amount)
		else:
			outputs[change_address] = float(change_amount)
	rawtx = bitcreditd.createrawtransaction(inputs, outputs)
	signed_rawtx = bitcreditd.signrawtransaction(rawtx)
	if not signed_rawtx["complete"]:
		sys.stderr.write("signrawtransaction failed\n")
		sys.exit(1)
	txdata = signed_rawtx["hex"]
	return txdata
def compute_amount_in(bitcreditd, txinfo):
	result = Decimal("0.0")
	for vin in txinfo['vin']:
		in_info = bitcreditd.getrawtransaction(vin['txid'], 1)
		vout = in_info['vout'][vin['vout']]
		result = result + vout['value']
	return result
def compute_amount_out(txinfo):
	result = Decimal("0.0")
	for vout in txinfo['vout']:
		result = result + vout['value']
	return result
def sanity_test_fee(bitcreditd, txdata_hex, max_fee):
	class FeeError(RuntimeError):
		pass
	try:
		txinfo = bitcreditd.decoderawtransaction(txdata_hex)
		total_in = compute_amount_in(bitcreditd, txinfo)
		total_out = compute_amount_out(txinfo)
		if total_in-total_out > max_fee:
			raise FeeError("Rejecting transaction, unreasonable fee of "+str(total_in-total_out))
		tx_size = len(txdata_hex)/2
		kb = tx_size/1000
		if kb > 1 and fee < BASE_FEE:
			raise FeeError("Rejecting no-fee transaction, larger than 1000 bytes")
		if total_in < 0.01 and fee < BASE_FEE:
			raise FeeError("Rejecting no-fee, tiny-amount transaction")
	except FeeError as err:
		sys.stderr.write((str(err)+"\n"))
		sys.exit(1)
def main():
	parser = optparse.OptionParser(usage="%prog [options]")
	parser.add_option("--
					  help="addresses to get bitcredits
	parser.add_option("--to", dest="to", default=None,
					  help="address to get send bitcredits to")
	parser.add_option("--amount", dest="amount", default=None,
					  help="amount to send")
	parser.add_option("--fee", dest="fee", default="0.0",
					  help="fee to include")
	parser.add_option("--datadir", dest="datadir", default=determine_db_dir(),
					  help="location of bitcredit.conf file with RPC username/password (default: %default)")
	parser.add_option("--testnet", dest="testnet", default=False, action="store_true",
					  help="Use the test network")
	parser.add_option("--dry_run", dest="dry_run", default=False, action="store_true",
					  help="Don't broadcast the transaction, just create and print the transaction data")
	(options, args) = parser.parse_args()
	check_json_precision()
	config = read_bitcredit_config(options.datadir)
	if options.testnet: config['testnet'] = True
	bitcreditd = connect_JSON(config)
	if options.amount is None:
		address_summary = list_available(bitcreditd)
		for address,info in address_summary.iteritems():
			n_transactions = len(info['outputs'])
			if n_transactions > 1:
				print("%s %.8f %s (%d transactions)"%(address, info['total'], info['account'], n_transactions))
			else:
				print("%s %.8f %s"%(address, info['total'], info['account']))
	else:
		fee = Decimal(options.fee)
		amount = Decimal(options.amount)
		while unlock_wallet(bitcreditd) == False:
			pass
		txdata = create_tx(bitcreditd, options.
		sanity_test_fee(bitcreditd, txdata, amount*Decimal("0.01"))
		if options.dry_run:
			print(txdata)
		else:
			txid = bitcreditd.sendrawtransaction(txdata)
			print(txid)
if __name__ == '__main__':
	main()