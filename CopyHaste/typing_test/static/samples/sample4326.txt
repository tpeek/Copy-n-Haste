class AsyncMethodError(Exception):
	pass
class AlreadyRunningError(AsyncMethodError, RuntimeError):
	pass
class TimedOutError(AsyncMethodError, RuntimeError):
	pass
class AsyncResult:
	def __init__(self):
		self._event = threading.Event()
		self._exception = None
		self._result = None
	def __call__(self, timeout = None):
		if not self._event.wait(timeout):
			raise TimedOutError
		elif self._exception is not None:
			raise self._exception
		else:
			return self._result
	def _raise(self, exception):
		self._exception = exception
		self._event.set()
	def _return(self, result):
		self._result = result
		self._event.set()
class AsyncMethod:
	def __init__(self, function):
		self._function = function
		self._running = threading.Lock()
	def __call