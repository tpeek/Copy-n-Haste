def calculate(func, args):
	result = func(*args)
	return '%s says that %s%s = %s' % (
		multiprocessing.current_process().name,
		func.__name__, args, result
		)
def calculatestar(args):
	return calculate(*args)
def mul(a, b):
	time.sleep(0.5 * random.random())
	return a * b
def plus(a, b):
	time.sleep(0.5 * random.random())
	return a + b
def f(x):
	return 1.0 / (x - 5.0)
def pow3(x):
	return x ** 3
def noop(x):
	pass
def test():
	PROCESSES = 4
	print('Creating pool with %d processes\n' % PROCESSES)
	with multiprocessing.Pool(PROCESSES) as pool:
		TASKS = [(mul, (i, 7)) for i in range(10)] + \
				[(plus, (i, 8)) for i in range(10)]
		results = [pool.apply_async(calculate, t) for t in TASKS]
		imap_it = pool.imap(calculatestar, TASKS)
		imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)
		print('Ordered results using pool.apply_async():')
		for r in results:
			print('\t', r.get())
		print()
		print('Ordered results using pool.imap():')
		for x in imap_it:
			print('\t', x)
		print()
		print('Unordered results using pool.imap_unordered():')
		for x in imap_unordered_it:
			print('\t', x)
		print()
		print('Ordered results using pool.map() --- will block till complete:')
