def abstractmethod(funcobj):
	funcobj.__isabstractmethod__ = True
	return funcobj
class abstractclassmethod(classmethod):
	__isabstractmethod__ = True
	def __init__(self, callable):
		callable.__isabstractmethod__ = True
		super().__init__(callable)
class abstractstaticmethod(staticmethod):
	__isabstractmethod__ = True
	def __init__(self, callable):
		callable.__isabstractmethod__ = True
		super().__init__(callable)
class abstractproperty(property):
	__isabstractmethod__ = True
class ABCMeta(type):
	_abc_invalidation_counter = 0
	def __new__(mcls, name, bases, namespace):
		cls = super().__new__(mcls, name, bases, namespace)
		abstracts = {name
					 for name, value in namespace.items()
					 if getattr(value, "__isabstractmethod__", False)}
		for base in bases:
			for name in getattr(base, "__abstractmethods__", set()):
				value = getattr(cls, name, None)
				if getattr(value, "__isabstractmethod__", False):
					abstracts.add(name)
		cls.__abstractmethods__ = frozenset(abstracts)
		cls._abc_registry = WeakSet()
		cls._abc_cache = WeakSet()
		cls._abc_negative_cache = WeakSet()
		cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
		return cls
	def register(cls, s