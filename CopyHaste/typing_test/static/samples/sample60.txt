class Error(Exception):
	pass
error = Error
try:
except ImportError:
	PyStringMap = None
__all__ = ["Error", "copy", "deepcopy"]
def copy(x):
	cls = type(x)
	copier = _copy_dispatch.get(cls)
	if copier:
		return copier(x)
	try:
		issc = issubclass(cls, type)
	except TypeError:
		issc = False
	if issc:
		return _copy_immutable(x)
	copier = getattr(cls, "__copy__", None)
	if copier:
		return copier(x)
	reductor = dispatch_table.get(cls)
	if reductor:
		rv = reductor(x)
	else:
		reductor = getattr(x, "__reduce_ex__", None)
		if reductor:
			rv = reductor(2)
		else:
			reductor = getattr(x, "__reduce__", None)
			if reductor:
				rv = reductor()
			else:
				raise Error("un(shallow)copyable object of type %s" % cls)
	return _reconstruct(x, rv, 0)
_copy_dispatch = d = {}
def _copy_immutable(x):
	return x
for t in (type(None), int, float, bool, str, tuple,
		  bytes, frozenset, type, range,
		  types.BuiltinFunctionType, type(Ellipsis),
		  types.FunctionType, weakref.ref):
	d[t] = _copy_immutable
t = getattr(types, "CodeType", None)
if t is not None:
	d[t] = _copy_immutable
for name in ("complex", "unicode"):
	t = getattr(builtins, name, None)
	if t is not None:
		d[t] = _copy_immutable