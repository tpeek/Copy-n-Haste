
def normalise_z(features):
	   
	mu = np.mean(features, axis=0)
	sigma = np.std(features, axis=0)
	return (features - mu) / sigma
	
def normalise_unit_var(features):
	
	sigma = np.std(features, axis=0)
	return features / sigma
	
	
def normalise_01(features):
	
	minimum = np.min(features, axis=0)
	maximum = np.max(features, axis=0)
	return (features - minimum) / (maximum - minimum)
def _get_train_test_size(train_size, test_size, n_samples):
	if test_size is None and train_size is None:
		test_size = 0.3
		train_size = 1.0 - test_size
	if isinstance(test_size, float):
		test_size = np.round(test_size * n_samples).astype(int)
	if isinstance(train_size, float):
		train_size = np.round(train_size * n_samples).astype(int)
	if test_size is None:
