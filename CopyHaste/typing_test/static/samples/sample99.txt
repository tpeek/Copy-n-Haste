def gen_landscape(x, Type):
	s = [0] * len(x)
	for i in range(0, len(x) - 1):
		s[i + 1] = s[i] + np.linalg.norm(x[i + 1] - x[i])
	if Type == "elevation":
		xlnglat = proj.geospatials_to_latlngs(x, config.PROJ)
		z = elevation.usgs_elevation(xlnglat)
	elif Type == "velocity":
		R = [curvature.points_to_radius(x[i - 1:i + 2])
			 for i in range(1, len(x) - 1)]
		z = [0] + [min(np.sqrt(r * parameters.MAX_LATERAL_ACCEL),
					   parameters.MAX_SPEED) for r in R] + [0]
	return [s, z]
def sort_indices(z, Type):
	z_indices = range(len(z))
	if Type == "elevation":
		return sorted(z_indices, key=lambda i: z[i], reverse=True)
	elif Type == "velocity":
		return sorted(z_indices, key=lambda i: z[i], reverse=False)
def match_landscape(s, z, Type, tradeoffs):
	K = [0, len(z) - 1]
	J = sort_indices(z[1:len(z) - 1], Type)
	J = [j + 1 for j in J]
	cached = [[0 for i in range(len(z))] for i in range(len(z))]
	def bad(index, Type):
		new = util.sorted_insert(index, K)
		result = test(K[new - 1], K[new], Type) or test(K[new],
														K[new + 1], Type)
		K.pop(new)
		return result
	def test(i, j, Type):
		if cached[i][j]:
			return True
		elif Type == "elevation":
			cached[i][j] = cached[j][i] 